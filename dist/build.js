!function(g){var I={};function C(n){if(I[n])return I[n].exports;var c=I[n]={i:n,l:!1,exports:{}};return g[n].call(c.exports,c,c.exports,C),c.l=!0,c.exports}C.m=g,C.c=I,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var c in g)C.d(n,c,function(I){return g[I]}.bind(null,c));return n},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="/dist/",C(C.s=9)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return EMPTY_ARR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return EMPTY_OBJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return NO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return NOOP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return PatchFlagNames; });\n/* unused harmony export babelParserDefaultPlugins */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return camelize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return capitalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return def; });\n/* unused harmony export escapeHtml */\n/* unused harmony export escapeHtmlComment */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return extend; });\n/* unused harmony export generateCodeFrame */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return getGlobalThis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return hasChanged; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return hasOwn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return hyphenate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return invokeArrayFns; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return isArray; });\n/* unused harmony export isBooleanAttr */\n/* unused harmony export isDate */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return isGloballyWhitelisted; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return isHTMLTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return isIntegerKey; });\n/* unused harmony export isKnownAttr */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return isMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return isModelListener; });\n/* unused harmony export isNoUnitNumericStyleProp */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return isOn; });\n/* unused harmony export isPlainObject */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return isPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return isReservedProp; });\n/* unused harmony export isSSRSafeAttrName */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return isSVGTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return isSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return isSpecialBooleanAttr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return isSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return isVoidTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return looseEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return looseIndexOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return makeMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I\", function() { return normalizeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"J\", function() { return normalizeStyle; });\n/* unused harmony export objectToString */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"K\", function() { return parseStringStyle; });\n/* unused harmony export propsToAttrMap */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return remove; });\n/* unused harmony export slotFlagsText */\n/* unused harmony export stringifyStyle */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return toDisplayString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return toHandlerKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"O\", function() { return toNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"P\", function() { return toRawType; });\n/* unused harmony export toTypeString */\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    const lines = source.split(/\\r?\\n/);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - lineLength) + 1;\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|\x3c!--|--\x3e|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = ( false)\r\n    ? undefined\r\n    : {};\r\nconst EMPTY_ARR = ( false) ? undefined : [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanM/OWZmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxFQUFFLGlEQUFpRCxLQUFLLFNBQVM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRW92QiIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcclxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cclxuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xyXG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcclxuICovXHJcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xyXG4gICAgWzEgLyogVEVYVCAqL106IGBURVhUYCxcclxuICAgIFsyIC8qIENMQVNTICovXTogYENMQVNTYCxcclxuICAgIFs0IC8qIFNUWUxFICovXTogYFNUWUxFYCxcclxuICAgIFs4IC8qIFBST1BTICovXTogYFBST1BTYCxcclxuICAgIFsxNiAvKiBGVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxyXG4gICAgWzMyIC8qIEhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcclxuICAgIFs2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcclxuICAgIFsxMjggLyogS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzUxMiAvKiBORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxyXG4gICAgWzEwMjQgLyogRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcclxuICAgIFsyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcclxuICAgIFstMSAvKiBIT0lTVEVEICovXTogYEhPSVNURURgLFxyXG4gICAgWy0yIC8qIEJBSUwgKi9dOiBgQkFJTGBcclxufTtcblxuLyoqXHJcbiAqIERldiBvbmx5XHJcbiAqL1xyXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xyXG4gICAgWzEgLyogU1RBQkxFICovXTogJ1NUQUJMRScsXHJcbiAgICBbMiAvKiBEWU5BTUlDICovXTogJ0RZTkFNSUMnLFxyXG4gICAgWzMgLyogRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcclxufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcclxuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xyXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcclxuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xyXG4gICAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7JyAnLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XHJcbn1cblxuLyoqXHJcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XHJcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcclxuICogLSBpdGVtc2NvcGUgLT4gTi9BXHJcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxyXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXHJcbiAqIC0gaXNtYXAgLT4gaXNNYXBcclxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxyXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxyXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XHJcbiAqL1xyXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XHJcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xyXG4vKipcclxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxyXG4gKi9cclxuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcclxuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xyXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXHJcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xyXG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XHJcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xyXG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xyXG4gICAgaWYgKGlzVW5zYWZlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xyXG59XHJcbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xyXG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcclxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcclxuICAgIGh0bWxGb3I6ICdmb3InLFxyXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcclxufTtcclxuLyoqXHJcbiAqIENTUyBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IHBsYWluIG51bWJlcnNcclxuICovXHJcbmNvbnN0IGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCxib3JkZXItaW1hZ2Utb3V0c2V0LGJvcmRlci1pbWFnZS1zbGljZSxgICtcclxuICAgIGBib3JkZXItaW1hZ2Utd2lkdGgsYm94LWZsZXgsYm94LWZsZXgtZ3JvdXAsYm94LW9yZGluYWwtZ3JvdXAsY29sdW1uLWNvdW50LGAgK1xyXG4gICAgYGNvbHVtbnMsZmxleCxmbGV4LWdyb3csZmxleC1wb3NpdGl2ZSxmbGV4LXNocmluayxmbGV4LW5lZ2F0aXZlLGZsZXgtb3JkZXIsYCArXHJcbiAgICBgZ3JpZC1yb3csZ3JpZC1yb3ctZW5kLGdyaWQtcm93LXNwYW4sZ3JpZC1yb3ctc3RhcnQsZ3JpZC1jb2x1bW4sYCArXHJcbiAgICBgZ3JpZC1jb2x1bW4tZW5kLGdyaWQtY29sdW1uLXNwYW4sZ3JpZC1jb2x1bW4tc3RhcnQsZm9udC13ZWlnaHQsbGluZS1jbGFtcCxgICtcclxuICAgIGBsaW5lLWhlaWdodCxvcGFjaXR5LG9yZGVyLG9ycGhhbnMsdGFiLXNpemUsd2lkb3dzLHotaW5kZXgsem9vbSxgICtcclxuICAgIC8vIFNWR1xyXG4gICAgYGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LGAgK1xyXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xyXG4vKipcclxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcclxuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cclxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcclxuICovXHJcbmNvbnN0IGlzS25vd25BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXHJcbiAgICBgYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYCArXHJcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXHJcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xyXG4gICAgYGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGAgK1xyXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcclxuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xyXG4gICAgYGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxgICtcclxuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXHJcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcclxuICAgIGBvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHksYCArXHJcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcclxuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXHJcbiAgICBgc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsYCArXHJcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHlsZShpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBpdGVtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcclxuICAgIGxldCByZXQgPSAnJztcclxuICAgIGlmICghc3R5bGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05vVW5pdE51bWVyaWNTdHlsZVByb3Aobm9ybWFsaXplZEtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xyXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcclxufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcclxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXHJcbiAgICAnaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbiwnICtcclxuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcclxuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXHJcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcclxuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXHJcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xyXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXHJcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XHJcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcclxuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xyXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXHJcbiAgICAnZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXHJcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcclxuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xyXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcclxuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcclxuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xyXG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xyXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcclxuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XHJcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgbGV0IGh0bWwgPSAnJztcclxuICAgIGxldCBlc2NhcGVkO1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XHJcbn1cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xyXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcclxuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xyXG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XHJcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBlcXVhbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xyXG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXHJcbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xyXG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbFxyXG4gICAgICAgID8gJydcclxuICAgICAgICA6IGlzT2JqZWN0KHZhbClcclxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xyXG59O1xyXG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcclxuICAgIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuLyoqXHJcbiAqIExpc3Qgb2YgQGJhYmVsL3BhcnNlciBwbHVnaW5zIHRoYXQgYXJlIHVzZWQgZm9yIHRlbXBsYXRlIGV4cHJlc3Npb25cclxuICogdHJhbnNmb3JtcyBhbmQgU0ZDIHNjcmlwdCB0cmFuc2Zvcm1zLiBCeSBkZWZhdWx0IHdlIGVuYWJsZSBwcm9wb3NhbHMgc2xhdGVkXHJcbiAqIGZvciBFUzIwMjAuIFRoaXMgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWQgYXMgdGhlIHNwZWMgbW92ZXMgZm9yd2FyZC5cclxuICogRnVsbCBsaXN0IGF0IGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL2VuL25leHQvYmFiZWwtcGFyc2VyI3BsdWdpbnNcclxuICovXHJcbmNvbnN0IGJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnMgPSBbXHJcbiAgICAnYmlnSW50JyxcclxuICAgICdvcHRpb25hbENoYWluaW5nJyxcclxuICAgICdudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yJ1xyXG5dO1xyXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XHJcbi8qKlxyXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcclxuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xyXG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XHJcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcclxuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcclxuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcclxuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xyXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XHJcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xyXG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBEYXRlO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcclxuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcclxuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcclxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XHJcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcclxufTtcclxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcclxuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcclxuICAgIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcclxuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJlxyXG4gICAga2V5ICE9PSAnTmFOJyAmJlxyXG4gICAga2V5WzBdICE9PSAnLScgJiZcclxuICAgICcnICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcclxuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcclxuJyxrZXkscmVmLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiAoc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKSk7XHJcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXHJcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB2YWx1ZSAhPT0gb2xkVmFsdWUgJiYgKHZhbHVlID09PSB2YWx1ZSB8fCBvbGRWYWx1ZSA9PT0gb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ shared_esm_bundler["M" /* toDisplayString */]; });\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ Fragment; });\n__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ createBlock; });\n__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ createTextVNode; });\n__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ createVNode; });\n__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ h; });\n__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ openBlock; });\n__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ renderList; });\n__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ renderSlot; });\n__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ resolveComponent; });\n__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ withCtx; });\n__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ runtime_dom_esm_bundler_createApp; });\n__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ withModifiers; });\n\n// UNUSED EXPORTS: customRef, isProxy, isReactive, isReadonly, isRef, markRaw, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, camelize, capitalize, toHandlerKey, BaseTransition, Comment, KeepAlive, Static, Suspense, Teleport, Text, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, computed, createCommentVNode, createHydrationRenderer, createRenderer, createSlots, createStaticVNode, defineAsyncComponent, defineComponent, defineEmit, defineProps, devtools, getCurrentInstance, getTransitionRawChildren, handleError, initCustomFormatter, inject, isRuntimeOnly, isVNode, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useContext, useSSRContext, useTransitionState, version, warn, watch, watchEffect, withDirectives, withScopeId, Transition, TransitionGroup, createSSRApp, hydrate, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, compile\n\n// NAMESPACE OBJECT: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\nvar runtime_dom_esm_bundler_namespaceObject = {};\n__webpack_require__.r(runtime_dom_esm_bundler_namespaceObject);\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "customRef", function() { return customRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isProxy", function() { return isProxy; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isReactive", function() { return isReactive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isReadonly", function() { return reactivity_esm_bundler_isReadonly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isRef", function() { return isRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "markRaw", function() { return markRaw; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "proxyRefs", function() { return proxyRefs; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "reactive", function() { return reactive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "readonly", function() { return readonly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "ref", function() { return reactivity_esm_bundler_ref; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "shallowReactive", function() { return shallowReactive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "shallowReadonly", function() { return shallowReadonly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "shallowRef", function() { return shallowRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toRaw", function() { return toRaw; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toRef", function() { return toRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toRefs", function() { return toRefs; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "triggerRef", function() { return triggerRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "unref", function() { return unref; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "camelize", function() { return shared_esm_bundler["f" /* camelize */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "capitalize", function() { return shared_esm_bundler["g" /* capitalize */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toDisplayString", function() { return shared_esm_bundler["M" /* toDisplayString */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toHandlerKey", function() { return shared_esm_bundler["N" /* toHandlerKey */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "BaseTransition", function() { return BaseTransition; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Comment", function() { return Comment; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Fragment", function() { return Fragment; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "KeepAlive", function() { return KeepAlive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Static", function() { return Static; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Suspense", function() { return Suspense; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Teleport", function() { return Teleport; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Text", function() { return Text; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "callWithAsyncErrorHandling", function() { return callWithAsyncErrorHandling; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "callWithErrorHandling", function() { return callWithErrorHandling; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "cloneVNode", function() { return cloneVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "computed", function() { return runtime_core_esm_bundler_computed; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createBlock", function() { return createBlock; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createCommentVNode", function() { return createCommentVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createHydrationRenderer", function() { return createHydrationRenderer; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createRenderer", function() { return createRenderer; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createSlots", function() { return createSlots; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createStaticVNode", function() { return createStaticVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createTextVNode", function() { return createTextVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createVNode", function() { return createVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineAsyncComponent", function() { return defineAsyncComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineComponent", function() { return defineComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineEmit", function() { return defineEmit; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineProps", function() { return defineProps; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "devtools", function() { return devtools; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "getCurrentInstance", function() { return getCurrentInstance; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "getTransitionRawChildren", function() { return getTransitionRawChildren; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "h", function() { return h; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "handleError", function() { return handleError; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "initCustomFormatter", function() { return initCustomFormatter; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "inject", function() { return inject; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isRuntimeOnly", function() { return isRuntimeOnly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isVNode", function() { return isVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "mergeProps", function() { return mergeProps; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "nextTick", function() { return nextTick; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onActivated", function() { return onActivated; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onBeforeMount", function() { return onBeforeMount; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onBeforeUnmount", function() { return onBeforeUnmount; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onBeforeUpdate", function() { return onBeforeUpdate; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onDeactivated", function() { return onDeactivated; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onErrorCaptured", function() { return onErrorCaptured; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onMounted", function() { return onMounted; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onRenderTracked", function() { return onRenderTracked; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onRenderTriggered", function() { return onRenderTriggered; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onUnmounted", function() { return onUnmounted; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onUpdated", function() { return onUpdated; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "openBlock", function() { return openBlock; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "popScopeId", function() { return popScopeId; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "provide", function() { return provide; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "pushScopeId", function() { return pushScopeId; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "queuePostFlushCb", function() { return queuePostFlushCb; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "registerRuntimeCompiler", function() { return registerRuntimeCompiler; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "renderList", function() { return renderList; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "renderSlot", function() { return renderSlot; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveComponent", function() { return resolveComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveDirective", function() { return resolveDirective; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveDynamicComponent", function() { return resolveDynamicComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveTransitionHooks", function() { return resolveTransitionHooks; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "setBlockTracking", function() { return setBlockTracking; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "setDevtoolsHook", function() { return setDevtoolsHook; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "setTransitionHooks", function() { return setTransitionHooks; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "ssrContextKey", function() { return ssrContextKey; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "ssrUtils", function() { return ssrUtils; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toHandlers", function() { return toHandlers; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "transformVNodeArgs", function() { return transformVNodeArgs; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useContext", function() { return useContext; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useSSRContext", function() { return useSSRContext; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useTransitionState", function() { return useTransitionState; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "version", function() { return version; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "warn", function() { return warn; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "watch", function() { return watch; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "watchEffect", function() { return watchEffect; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withCtx", function() { return withCtx; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withDirectives", function() { return withDirectives; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withScopeId", function() { return withScopeId; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Transition", function() { return Transition; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "TransitionGroup", function() { return TransitionGroup; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createApp", function() { return runtime_dom_esm_bundler_createApp; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createSSRApp", function() { return createSSRApp; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "hydrate", function() { return runtime_dom_esm_bundler_hydrate; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "render", function() { return runtime_dom_esm_bundler_render; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useCssModule", function() { return useCssModule; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useCssVars", function() { return useCssVars; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelCheckbox", function() { return vModelCheckbox; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelDynamic", function() { return vModelDynamic; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelRadio", function() { return vModelRadio; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelSelect", function() { return vModelSelect; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelText", function() { return vModelText; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vShow", function() { return vShow; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withKeys", function() { return withKeys; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withModifiers", function() { return withModifiers; });\n\n// EXTERNAL MODULE: ./node_modules/@vue/shared/dist/shared.esm-bundler.js\nvar shared_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol(( false) ? undefined : \'\');\r\nconst MAP_KEY_ITERATE_KEY = Symbol(( false) ? undefined : \'\');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction reactivity_esm_bundler_effect(fn, options = shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        reactivity_esm_bundler_cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            reactivity_esm_bundler_cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction reactivity_esm_bundler_cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if (false) {}\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === "clear" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === \'length\' && Object(shared_esm_bundler["o" /* isArray */])(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === \'length\' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case "add" /* ADD */:\r\n                if (!Object(shared_esm_bundler["o" /* isArray */])(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (Object(shared_esm_bundler["t" /* isMap */])(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (Object(shared_esm_bundler["s" /* isIntegerKey */])(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get(\'length\'));\r\n                }\r\n                break;\r\n            case "delete" /* DELETE */:\r\n                if (!Object(shared_esm_bundler["o" /* isArray */])(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (Object(shared_esm_bundler["t" /* isMap */])(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case "set" /* SET */:\r\n                if (Object(shared_esm_bundler["t" /* isMap */])(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if (false) {}\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(shared_esm_bundler["D" /* isSymbol */]));\r\nconst reactivity_esm_bundler_get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n[\'includes\', \'indexOf\', \'lastIndexOf\'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, "get" /* GET */, i + \'\');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn\'t work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n[\'push\', \'pop\', \'shift\', \'unshift\', \'splice\'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === "__v_isReactive" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === "__v_isReadonly" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === "__v_raw" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = Object(shared_esm_bundler["o" /* isArray */])(target);\r\n        if (!isReadonly && targetIsArray && Object(shared_esm_bundler["l" /* hasOwn */])(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (Object(shared_esm_bundler["D" /* isSymbol */])(key)\r\n            ? builtInSymbols.has(key)\r\n            : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, "get" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !Object(shared_esm_bundler["s" /* isIntegerKey */])(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (Object(shared_esm_bundler["v" /* isObject */])(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst reactivity_esm_bundler_set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!Object(shared_esm_bundler["o" /* isArray */])(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = Object(shared_esm_bundler["o" /* isArray */])(target) && Object(shared_esm_bundler["s" /* isIntegerKey */])(key)\r\n            ? Number(key) < target.length\r\n            : Object(shared_esm_bundler["l" /* hasOwn */])(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don\'t trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, "add" /* ADD */, key, value);\r\n            }\r\n            else if (Object(shared_esm_bundler["k" /* hasChanged */])(value, oldValue)) {\r\n                trigger(target, "set" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = Object(shared_esm_bundler["l" /* hasOwn */])(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction reactivity_esm_bundler_has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!Object(shared_esm_bundler["D" /* isSymbol */])(key) || !builtInSymbols.has(key)) {\r\n        track(target, "has" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, "iterate" /* ITERATE */, Object(shared_esm_bundler["o" /* isArray */])(target) ? \'length\' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get: reactivity_esm_bundler_get,\r\n    set: reactivity_esm_bundler_set,\r\n    deleteProperty,\r\n    has: reactivity_esm_bundler_has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((false)) {}\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((false)) {}\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = Object(shared_esm_bundler["i" /* extend */])({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = Object(shared_esm_bundler["i" /* extend */])({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => Object(shared_esm_bundler["v" /* isObject */])(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => Object(shared_esm_bundler["v" /* isObject */])(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target["__v_raw" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, "get" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this["__v_raw" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, "has" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target["__v_raw" /* RAW */];\r\n    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, \'size\', target);\r\n}\r\nfunction reactivity_esm_bundler_add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, "add" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((false)) {}\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, "add" /* ADD */, key, value);\r\n    }\r\n    else if (Object(shared_esm_bundler["k" /* hasChanged */])(value, oldValue)) {\r\n        trigger(target, "set" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((false)) {}\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = ( false)\r\n        ? undefined\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed["__v_raw" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this["__v_raw" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = Object(shared_esm_bundler["t" /* isMap */])(rawTarget);\r\n        const isPair = method === \'entries\' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === \'keys\' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((false)) {}\r\n        return type === "delete" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add: reactivity_esm_bundler_add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add: reactivity_esm_bundler_add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod("add" /* ADD */),\r\n    set: createReadonlyMethod("set" /* SET */),\r\n    delete: createReadonlyMethod("delete" /* DELETE */),\r\n    clear: createReadonlyMethod("clear" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = [\'keys\', \'values\', \'entries\', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === "__v_isReactive" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === "__v_isReadonly" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === "__v_raw" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(Object(shared_esm_bundler["l" /* hasOwn */])(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = Object(shared_esm_bundler["P" /* toRawType */])(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case \'Object\':\r\n        case \'Array\':\r\n            return 1 /* COMMON */;\r\n        case \'Map\':\r\n        case \'Set\':\r\n        case \'WeakMap\':\r\n        case \'WeakSet\':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(Object(shared_esm_bundler["P" /* toRawType */])(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target["__v_isReadonly" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!Object(shared_esm_bundler["v" /* isObject */])(target)) {\r\n        if ((false)) {}\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target["__v_raw" /* RAW */] &&\r\n        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (reactivity_esm_bundler_isReadonly(value)) {\r\n        return isReactive(value["__v_raw" /* RAW */]);\r\n    }\r\n    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);\r\n}\r\nfunction reactivity_esm_bundler_isReadonly(value) {\r\n    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || reactivity_esm_bundler_isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed["__v_raw" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    Object(shared_esm_bundler["h" /* def */])(value, "__v_skip" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => Object(shared_esm_bundler["v" /* isObject */])(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction reactivity_esm_bundler_ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass reactivity_esm_bundler_RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), "get" /* GET */, \'value\');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (Object(shared_esm_bundler["k" /* hasChanged */])(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), "set" /* SET */, \'value\', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new reactivity_esm_bundler_RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), "set" /* SET */, \'value\', ( false) ? undefined : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, "get" /* GET */, \'value\'), () => trigger(this, "set" /* SET */, \'value\'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if (false) {}\r\n    const ret = Object(shared_esm_bundler["o" /* isArray */])(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = reactivity_esm_bundler_effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), "set" /* SET */, \'value\');\r\n                }\r\n            }\r\n        });\r\n        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect();\r\n            this._dirty = false;\r\n        }\r\n        track(toRaw(this), "get" /* GET */, \'value\');\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction reactivity_esm_bundler_computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = ( false)\r\n            ? undefined\r\n            : shared_esm_bundler["d" /* NOOP */];\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, Object(shared_esm_bundler["p" /* isFunction */])(getterOrOptions) || !getterOrOptions.set);\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\n\n\n\n\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(\'\'),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join(\'\\n\'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can\'t just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === \'number\' ||\r\n        typeof value === \'boolean\' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    ["bc" /* BEFORE_CREATE */]: \'beforeCreate hook\',\r\n    ["c" /* CREATED */]: \'created hook\',\r\n    ["bm" /* BEFORE_MOUNT */]: \'beforeMount hook\',\r\n    ["m" /* MOUNTED */]: \'mounted hook\',\r\n    ["bu" /* BEFORE_UPDATE */]: \'beforeUpdate hook\',\r\n    ["u" /* UPDATED */]: \'updated\',\r\n    ["bum" /* BEFORE_UNMOUNT */]: \'beforeUnmount hook\',\r\n    ["um" /* UNMOUNTED */]: \'unmounted hook\',\r\n    ["a" /* ACTIVATED */]: \'activated hook\',\r\n    ["da" /* DEACTIVATED */]: \'deactivated hook\',\r\n    ["ec" /* ERROR_CAPTURED */]: \'errorCaptured hook\',\r\n    ["rtc" /* RENDER_TRACKED */]: \'renderTracked hook\',\r\n    ["rtg" /* RENDER_TRIGGERED */]: \'renderTriggered hook\',\r\n    [0 /* SETUP_FUNCTION */]: \'setup function\',\r\n    [1 /* RENDER_FUNCTION */]: \'render function\',\r\n    [2 /* WATCH_GETTER */]: \'watcher getter\',\r\n    [3 /* WATCH_CALLBACK */]: \'watcher callback\',\r\n    [4 /* WATCH_CLEANUP */]: \'watcher cleanup function\',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: \'native event handler\',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: \'component event handler\',\r\n    [7 /* VNODE_HOOK */]: \'vnode hook\',\r\n    [8 /* DIRECTIVE_HOOK */]: \'directive hook\',\r\n    [9 /* TRANSITION_HOOK */]: \'transition hook\',\r\n    [10 /* APP_ERROR_HANDLER */]: \'app errorHandler\',\r\n    [11 /* APP_WARN_HANDLER */]: \'app warnHandler\',\r\n    [12 /* FUNCTION_REF */]: \'ref function\',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: \'async component loader\',\r\n    [14 /* SCHEDULER */]: \'scheduler flush. This is likely a Vue internals bug. \' +\r\n        \'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next\'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && Object(shared_esm_bundler["x" /* isPromise */])(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = ( false) ? undefined : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((false)) {}\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job\'s id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(job) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = queue.length;\r\n    const jobId = getId(job);\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(queue[middle]);\r\n        middleJobId < jobId ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user\'s responsibility to\r\n    // ensure it doesn\'t end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        const pos = findInsertionIndex(job);\r\n        if (pos > -1) {\r\n            queue.splice(pos, 0, job);\r\n        }\r\n        else {\r\n            queue.push(job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction invalidateJob(job) {\r\n    const i = queue.indexOf(job);\r\n    if (i > -1) {\r\n        queue.splice(i, 1);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!Object(shared_esm_bundler["o" /* isArray */])(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((false)) {}\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((false)) {}\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((false)) {}\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((false)) {}\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((false)) {}\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component\'s update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((false)) {}\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\n\n/* eslint-disable no-restricted-globals */\r\nlet isHmrUpdating = false;\r\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((false)) {}\r\nconst map = new Map();\r\nfunction registerHMR(instance) {\r\n    const id = instance.type.__hmrId;\r\n    let record = map.get(id);\r\n    if (!record) {\r\n        createRecord(id, instance.type);\r\n        record = map.get(id);\r\n    }\r\n    record.instances.add(instance);\r\n}\r\nfunction unregisterHMR(instance) {\r\n    map.get(instance.type.__hmrId).instances.delete(instance);\r\n}\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `dependency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        // this flag forces child components with slot content to update\r\n        isHmrUpdating = true;\r\n        instance.update();\r\n        isHmrUpdating = false;\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        Object(shared_esm_bundler["i" /* extend */])(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don\'t end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== \'undefined\') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn(\'[HMR] Root or manually mounted instance modified. Full reload required.\');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\n\nlet devtools;\r\nfunction setDevtoolsHook(hook) {\r\n    devtools = hook;\r\n}\r\nfunction devtoolsInitApp(app, version) {\r\n    // TODO queue if devtools is undefined\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit("app:init" /* APP_INIT */, app, version, {\r\n        Fragment,\r\n        Text,\r\n        Comment,\r\n        Static\r\n    });\r\n}\r\nfunction devtoolsUnmountApp(app) {\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit("app:unmount" /* APP_UNMOUNT */, app);\r\n}\r\nconst devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);\r\nconst devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);\r\nconst devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);\r\nfunction createDevtoolsComponentHook(hook) {\r\n    return (component) => {\r\n        if (!devtools)\r\n            return;\r\n        devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\r\n    };\r\n}\r\nfunction devtoolsComponentEmit(component, event, params) {\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\r\n}\n\nfunction runtime_core_esm_bundler_emit(instance, event, ...rawArgs) {\r\n    const props = instance.vnode.props || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n    if ((false)) {}\r\n    let args = rawArgs;\r\n    const isModelListener = event.startsWith(\'update:\');\r\n    // for v-model update:xxx events, apply modifiers on args\r\n    const modelArg = isModelListener && event.slice(7);\r\n    if (modelArg && modelArg in props) {\r\n        const modifiersKey = `${modelArg === \'modelValue\' ? \'model\' : modelArg}Modifiers`;\r\n        const { number, trim } = props[modifiersKey] || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        if (trim) {\r\n            args = rawArgs.map(a => a.trim());\r\n        }\r\n        else if (number) {\r\n            args = rawArgs.map(shared_esm_bundler["O" /* toNumber */]);\r\n        }\r\n    }\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        devtoolsComponentEmit(instance, event, args);\r\n    }\r\n    if ((false)) {}\r\n    // convert handler name to camelCase. See issue #2249\r\n    let handlerName = Object(shared_esm_bundler["N" /* toHandlerKey */])(Object(shared_esm_bundler["f" /* camelize */])(event));\r\n    let handler = props[handlerName];\r\n    // for v-model update:xxx events, also trigger kebab-case equivalent\r\n    // for props passed via kebab-case\r\n    if (!handler && isModelListener) {\r\n        handlerName = Object(shared_esm_bundler["N" /* toHandlerKey */])(Object(shared_esm_bundler["m" /* hyphenate */])(event));\r\n        handler = props[handlerName];\r\n    }\r\n    if (handler) {\r\n        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n    const onceHandler = props[handlerName + `Once`];\r\n    if (onceHandler) {\r\n        if (!instance.emitted) {\r\n            (instance.emitted = {})[handlerName] = true;\r\n        }\r\n        else if (instance.emitted[handlerName]) {\r\n            return;\r\n        }\r\n        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n}\r\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__emits !== undefined) {\r\n        return comp.__emits;\r\n    }\r\n    const raw = comp.emits;\r\n    let normalized = {};\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !Object(shared_esm_bundler["p" /* isFunction */])(comp)) {\r\n        const extendEmits = (raw) => {\r\n            hasExtends = true;\r\n            Object(shared_esm_bundler["i" /* extend */])(normalized, normalizeEmitsOptions(raw, appContext, true));\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendEmits);\r\n        }\r\n        if (comp.extends) {\r\n            extendEmits(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendEmits);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__emits = null);\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(raw)) {\r\n        raw.forEach(key => (normalized[key] = null));\r\n    }\r\n    else {\r\n        Object(shared_esm_bundler["i" /* extend */])(normalized, raw);\r\n    }\r\n    return (comp.__emits = normalized);\r\n}\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nfunction isEmitListener(options, key) {\r\n    if (!options || !Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n        return false;\r\n    }\r\n    key = key.slice(2).replace(/Once$/, \'\');\r\n    return (Object(shared_esm_bundler["l" /* hasOwn */])(options, key[0].toLowerCase() + key.slice(1)) ||\r\n        Object(shared_esm_bundler["l" /* hasOwn */])(options, Object(shared_esm_bundler["m" /* hyphenate */])(key)) ||\r\n        Object(shared_esm_bundler["l" /* hasOwn */])(options, key));\r\n}\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction setCurrentRenderingInstance(instance) {\r\n    currentRenderingInstance = instance;\r\n}\r\n/**\r\n * dev only flag to track whether $attrs was used during render.\r\n * If $attrs was used during render then the warning for failed attrs\r\n * fallthrough can be suppressed.\r\n */\r\nlet accessedAttrs = false;\r\nfunction markAttrsAccessed() {\r\n    accessedAttrs = true;\r\n}\r\nfunction renderComponentRoot(instance) {\r\n    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx } = instance;\r\n    let result;\r\n    currentRenderingInstance = instance;\r\n    if ((false)) {}\r\n    try {\r\n        let fallthroughAttrs;\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            // withProxy is a proxy with a different `has` trap only for\r\n            // runtime-compiled render functions using `with` block.\r\n            const proxyToUse = withProxy || proxy;\r\n            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\r\n            fallthroughAttrs = attrs;\r\n        }\r\n        else {\r\n            // functional\r\n            const render = Component;\r\n            // in dev, mark attrs accessed if optional props (attrs === props)\r\n            if (false) {}\r\n            result = normalizeVNode(render.length > 1\r\n                ? render(props, ( false)\r\n                    ? undefined\r\n                    : { attrs, slots, emit })\r\n                : render(props, null /* we know it doesn\'t need it */));\r\n            fallthroughAttrs = Component.props\r\n                ? attrs\r\n                : getFunctionalFallthrough(attrs);\r\n        }\r\n        // attr merging\r\n        // in dev mode, comments are preserved, and it\'s possible for a template\r\n        // to have comments along side the root element which makes it a fragment\r\n        let root = result;\r\n        let setRoot = undefined;\r\n        if (false /* DEV_ROOT_FRAGMENT */) {}\r\n        if (Component.inheritAttrs !== false && fallthroughAttrs) {\r\n            const keys = Object.keys(fallthroughAttrs);\r\n            const { shapeFlag } = root;\r\n            if (keys.length) {\r\n                if (shapeFlag & 1 /* ELEMENT */ ||\r\n                    shapeFlag & 6 /* COMPONENT */) {\r\n                    if (propsOptions && keys.some(shared_esm_bundler["u" /* isModelListener */])) {\r\n                        // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n                        // prop, it indicates this component expects to handle v-model and\r\n                        // it should not fallthrough.\r\n                        // related: #1543, #1643, #1989\r\n                        fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\r\n                    }\r\n                    root = cloneVNode(root, fallthroughAttrs);\r\n                }\r\n                else if (false) {}\r\n            }\r\n        }\r\n        // inherit directives\r\n        if (vnode.dirs) {\r\n            if (false) {}\r\n            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\r\n        }\r\n        // inherit transition data\r\n        if (vnode.transition) {\r\n            if (false) {}\r\n            root.transition = vnode.transition;\r\n        }\r\n        if (false) {}\r\n        else {\r\n            result = root;\r\n        }\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n        result = createVNode(Comment);\r\n    }\r\n    currentRenderingInstance = null;\r\n    return result;\r\n}\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode) => {\r\n    const rawChildren = vnode.children;\r\n    const dynamicChildren = vnode.dynamicChildren;\r\n    const childRoot = filterSingleRoot(rawChildren);\r\n    if (!childRoot) {\r\n        return [vnode, undefined];\r\n    }\r\n    const index = rawChildren.indexOf(childRoot);\r\n    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\r\n    const setRoot = (updatedRoot) => {\r\n        rawChildren[index] = updatedRoot;\r\n        if (dynamicChildren) {\r\n            if (dynamicIndex > -1) {\r\n                dynamicChildren[dynamicIndex] = updatedRoot;\r\n            }\r\n            else if (updatedRoot.patchFlag > 0) {\r\n                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\r\n            }\r\n        }\r\n    };\r\n    return [normalizeVNode(childRoot), setRoot];\r\n};\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === \'v-if\') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\nconst getFunctionalFallthrough = (attrs) => {\r\n    let res;\r\n    for (const key in attrs) {\r\n        if (key === \'class\' || key === \'style\' || Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n            (res || (res = {}))[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst filterModelListeners = (attrs, props) => {\r\n    const res = {};\r\n    for (const key in attrs) {\r\n        if (!Object(shared_esm_bundler["u" /* isModelListener */])(key) || !(key.slice(9) in props)) {\r\n            res[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst isElementRoot = (vnode) => {\r\n    return (vnode.shapeFlag & 6 /* COMPONENT */ ||\r\n        vnode.shapeFlag & 1 /* ELEMENT */ ||\r\n        vnode.type === Comment // potential v-if branch switch\r\n    );\r\n};\r\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n    const { props: prevProps, children: prevChildren, component } = prevVNode;\r\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n    const emits = component.emitsOptions;\r\n    // Parent component\'s render function was hot-updated. Since this may have\r\n    // caused the child component\'s slots content to have changed, we need to\r\n    // force the child to update as well.\r\n    if (false) {}\r\n    // force child update for runtime directive or transition on component vnode.\r\n    if (nextVNode.dirs || nextVNode.transition) {\r\n        return true;\r\n    }\r\n    if (optimized && patchFlag >= 0) {\r\n        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n            // slot content that references values that might have changed,\r\n            // e.g. in a v-for\r\n            return true;\r\n        }\r\n        if (patchFlag & 16 /* FULL_PROPS */) {\r\n            if (!prevProps) {\r\n                return !!nextProps;\r\n            }\r\n            // presence of this flag indicates props are always non-null\r\n            return hasPropsChanged(prevProps, nextProps, emits);\r\n        }\r\n        else if (patchFlag & 8 /* PROPS */) {\r\n            const dynamicProps = nextVNode.dynamicProps;\r\n            for (let i = 0; i < dynamicProps.length; i++) {\r\n                const key = dynamicProps[i];\r\n                if (nextProps[key] !== prevProps[key] &&\r\n                    !isEmitListener(emits, key)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // this path is only taken by manually written render functions\r\n        // so presence of any children leads to a forced update\r\n        if (prevChildren || nextChildren) {\r\n            if (!nextChildren || !nextChildren.$stable) {\r\n                return true;\r\n            }\r\n        }\r\n        if (prevProps === nextProps) {\r\n            return false;\r\n        }\r\n        if (!prevProps) {\r\n            return !!nextProps;\r\n        }\r\n        if (!nextProps) {\r\n            return true;\r\n        }\r\n        return hasPropsChanged(prevProps, nextProps, emits);\r\n    }\r\n    return false;\r\n}\r\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\r\n    const nextKeys = Object.keys(nextProps);\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i];\r\n        if (nextProps[key] !== prevProps[key] &&\r\n            !isEmitListener(emitsOptions, key)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction updateHOCHostEl({ vnode, parent }, el // HostNode\r\n) {\r\n    while (parent && parent.subTree === vnode) {\r\n        (vnode = parent.vnode).el = el;\r\n        parent = parent.parent;\r\n    }\r\n}\n\nconst isSuspense = (type) => type.__isSuspense;\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it\'s a special built-in type that hooks\r\n// directly into the renderer.\r\nconst SuspenseImpl = {\r\n    // In order to make Suspense tree-shakable, we need to avoid importing it\r\n    // directly in the renderer. The renderer checks for the __isSuspense flag\r\n    // on a vnode\'s type and calls the `process` method, passing in renderer\r\n    // internals.\r\n    __isSuspense: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, \r\n    // platform-specific impl passed from renderer\r\n    rendererInternals) {\r\n        if (n1 == null) {\r\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);\r\n        }\r\n        else {\r\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, rendererInternals);\r\n        }\r\n    },\r\n    hydrate: hydrateSuspense,\r\n    create: createSuspenseBoundary\r\n};\r\n// Force-casted public typing for h and TSX props inference\r\nconst Suspense = (SuspenseImpl\r\n    );\r\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {\r\n    const { p: patch, o: { createElement } } = rendererInternals;\r\n    const hiddenContainer = createElement(\'div\');\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));\r\n    // start mounting the content subtree in an off-dom container\r\n    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG);\r\n    // now check if we have encountered any async deps\r\n    if (suspense.deps > 0) {\r\n        // has async\r\n        // mount the fallback tree\r\n        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n        isSVG);\r\n        setActiveBranch(suspense, vnode.ssFallback);\r\n    }\r\n    else {\r\n        // Suspense has no async deps. Just resolve.\r\n        suspense.resolve();\r\n    }\r\n}\r\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, { p: patch, um: unmount, o: { createElement } }) {\r\n    const suspense = (n2.suspense = n1.suspense);\r\n    suspense.vnode = n2;\r\n    n2.el = n1.el;\r\n    const newBranch = n2.ssContent;\r\n    const newFallback = n2.ssFallback;\r\n    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\r\n    if (pendingBranch) {\r\n        suspense.pendingBranch = newBranch;\r\n        if (isSameVNodeType(newBranch, pendingBranch)) {\r\n            // same root type but content may have changed.\r\n            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n            if (suspense.deps <= 0) {\r\n                suspense.resolve();\r\n            }\r\n            else if (isInFallback) {\r\n                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG);\r\n                setActiveBranch(suspense, newFallback);\r\n            }\r\n        }\r\n        else {\r\n            // toggled before pending tree is resolved\r\n            suspense.pendingId++;\r\n            if (isHydrating) {\r\n                // if toggled before hydration is finished, the current DOM tree is\r\n                // no longer valid. set it as the active branch so it will be unmounted\r\n                // when resolved\r\n                suspense.isHydrating = false;\r\n                suspense.activeBranch = pendingBranch;\r\n            }\r\n            else {\r\n                unmount(pendingBranch, parentComponent, suspense);\r\n            }\r\n            // increment pending ID. this is used to invalidate async callbacks\r\n            // reset suspense state\r\n            suspense.deps = 0;\r\n            // discard effects from pending branch\r\n            suspense.effects.length = 0;\r\n            // discard previous container\r\n            suspense.hiddenContainer = createElement(\'div\');\r\n            if (isInFallback) {\r\n                // already in fallback state\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n                else {\r\n                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                    isSVG);\r\n                    setActiveBranch(suspense, newFallback);\r\n                }\r\n            }\r\n            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n                // toggled "back" to current active branch\r\n                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);\r\n                // force resolve\r\n                suspense.resolve(true);\r\n            }\r\n            else {\r\n                // switched to a 3rd branch\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n            // root did not change, just normal patch\r\n            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);\r\n            setActiveBranch(suspense, newBranch);\r\n        }\r\n        else {\r\n            // root node toggled\r\n            // invoke @pending event\r\n            const onPending = n2.props && n2.props.onPending;\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(onPending)) {\r\n                onPending();\r\n            }\r\n            // mount pending branch in off-dom container\r\n            suspense.pendingBranch = newBranch;\r\n            suspense.pendingId++;\r\n            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n            if (suspense.deps <= 0) {\r\n                // incoming branch has no async deps, resolve now.\r\n                suspense.resolve();\r\n            }\r\n            else {\r\n                const { timeout, pendingId } = suspense;\r\n                if (timeout > 0) {\r\n                    setTimeout(() => {\r\n                        if (suspense.pendingId === pendingId) {\r\n                            suspense.fallback(newFallback);\r\n                        }\r\n                    }, timeout);\r\n                }\r\n                else if (timeout === 0) {\r\n                    suspense.fallback(newFallback);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nlet hasWarned = false;\r\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {\r\n    /* istanbul ignore if */\r\n    if (false) {}\r\n    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\r\n    const timeout = Object(shared_esm_bundler["O" /* toNumber */])(vnode.props && vnode.props.timeout);\r\n    const suspense = {\r\n        vnode,\r\n        parent,\r\n        parentComponent,\r\n        isSVG,\r\n        container,\r\n        hiddenContainer,\r\n        anchor,\r\n        deps: 0,\r\n        pendingId: 0,\r\n        timeout: typeof timeout === \'number\' ? timeout : -1,\r\n        activeBranch: null,\r\n        pendingBranch: null,\r\n        isInFallback: true,\r\n        isHydrating,\r\n        isUnmounted: false,\r\n        effects: [],\r\n        resolve(resume = false) {\r\n            if ((false)) {}\r\n            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\r\n            if (suspense.isHydrating) {\r\n                suspense.isHydrating = false;\r\n            }\r\n            else if (!resume) {\r\n                const delayEnter = activeBranch &&\r\n                    pendingBranch.transition &&\r\n                    pendingBranch.transition.mode === \'out-in\';\r\n                if (delayEnter) {\r\n                    activeBranch.transition.afterLeave = () => {\r\n                        if (pendingId === suspense.pendingId) {\r\n                            move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                        }\r\n                    };\r\n                }\r\n                // this is initial anchor on mount\r\n                let { anchor } = suspense;\r\n                // unmount current active tree\r\n                if (activeBranch) {\r\n                    // if the fallback tree was mounted, it may have been moved\r\n                    // as part of a parent suspense. get the latest anchor for insertion\r\n                    anchor = next(activeBranch);\r\n                    unmount(activeBranch, parentComponent, suspense, true);\r\n                }\r\n                if (!delayEnter) {\r\n                    // move content from off-dom container to actual container\r\n                    move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                }\r\n            }\r\n            setActiveBranch(suspense, pendingBranch);\r\n            suspense.pendingBranch = null;\r\n            suspense.isInFallback = false;\r\n            // flush buffered effects\r\n            // check if there is a pending parent suspense\r\n            let parent = suspense.parent;\r\n            let hasUnresolvedAncestor = false;\r\n            while (parent) {\r\n                if (parent.pendingBranch) {\r\n                    // found a pending parent suspense, merge buffered post jobs\r\n                    // into that parent\r\n                    parent.effects.push(...effects);\r\n                    hasUnresolvedAncestor = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n            // no pending parent suspense, flush all jobs\r\n            if (!hasUnresolvedAncestor) {\r\n                queuePostFlushCb(effects);\r\n            }\r\n            suspense.effects = [];\r\n            // invoke @resolve event\r\n            const onResolve = vnode.props && vnode.props.onResolve;\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(onResolve)) {\r\n                onResolve();\r\n            }\r\n        },\r\n        fallback(fallbackVNode) {\r\n            if (!suspense.pendingBranch) {\r\n                return;\r\n            }\r\n            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\r\n            // invoke @fallback event\r\n            const onFallback = vnode.props && vnode.props.onFallback;\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(onFallback)) {\r\n                onFallback();\r\n            }\r\n            const anchor = next(activeBranch);\r\n            const mountFallback = () => {\r\n                if (!suspense.isInFallback) {\r\n                    return;\r\n                }\r\n                // mount the fallback tree\r\n                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG);\r\n                setActiveBranch(suspense, fallbackVNode);\r\n            };\r\n            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \'out-in\';\r\n            if (delayEnter) {\r\n                activeBranch.transition.afterLeave = mountFallback;\r\n            }\r\n            // unmount current active branch\r\n            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\r\n            true // shouldRemove\r\n            );\r\n            suspense.isInFallback = true;\r\n            if (!delayEnter) {\r\n                mountFallback();\r\n            }\r\n        },\r\n        move(container, anchor, type) {\r\n            suspense.activeBranch &&\r\n                move(suspense.activeBranch, container, anchor, type);\r\n            suspense.container = container;\r\n        },\r\n        next() {\r\n            return suspense.activeBranch && next(suspense.activeBranch);\r\n        },\r\n        registerDep(instance, setupRenderEffect) {\r\n            const isInPendingSuspense = !!suspense.pendingBranch;\r\n            if (isInPendingSuspense) {\r\n                suspense.deps++;\r\n            }\r\n            const hydratedEl = instance.vnode.el;\r\n            instance\r\n                .asyncDep.catch(err => {\r\n                handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n            })\r\n                .then(asyncSetupResult => {\r\n                // retry when the setup() promise resolves.\r\n                // component may have been unmounted before resolve.\r\n                if (instance.isUnmounted ||\r\n                    suspense.isUnmounted ||\r\n                    suspense.pendingId !== instance.suspenseId) {\r\n                    return;\r\n                }\r\n                // retry from this component\r\n                instance.asyncResolved = true;\r\n                const { vnode } = instance;\r\n                if ((false)) {}\r\n                handleSetupResult(instance, asyncSetupResult);\r\n                if (hydratedEl) {\r\n                    // vnode may have been replaced if an update happened before the\r\n                    // async dep is resolved.\r\n                    vnode.el = hydratedEl;\r\n                }\r\n                const placeholder = !hydratedEl && instance.subTree.el;\r\n                setupRenderEffect(instance, vnode, \r\n                // component may have been moved before resolve.\r\n                // if this is not a hydration, instance.subTree will be the comment\r\n                // placeholder.\r\n                parentNode(hydratedEl || instance.subTree.el), \r\n                // anchor will not be used if this is hydration, so only need to\r\n                // consider the comment placeholder case.\r\n                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\r\n                if (placeholder) {\r\n                    remove(placeholder);\r\n                }\r\n                updateHOCHostEl(instance, vnode.el);\r\n                if ((false)) {}\r\n                // only decrease deps count if suspense is not already resolved\r\n                if (isInPendingSuspense && --suspense.deps === 0) {\r\n                    suspense.resolve();\r\n                }\r\n            });\r\n        },\r\n        unmount(parentSuspense, doRemove) {\r\n            suspense.isUnmounted = true;\r\n            if (suspense.activeBranch) {\r\n                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n            if (suspense.pendingBranch) {\r\n                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n        }\r\n    };\r\n    return suspense;\r\n}\r\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {\r\n    /* eslint-disable no-restricted-globals */\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement(\'div\'), null, isSVG, optimized, rendererInternals, true /* hydrating */));\r\n    // there are two possible scenarios for server-rendered suspense:\r\n    // - success: ssr content should be fully resolved\r\n    // - failure: ssr content should be the fallback branch.\r\n    // however, on the client we don\'t really know if it has failed or not\r\n    // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n    // need to construct a suspense boundary first\r\n    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, optimized);\r\n    if (suspense.deps === 0) {\r\n        suspense.resolve();\r\n    }\r\n    return result;\r\n    /* eslint-enable no-restricted-globals */\r\n}\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(s)) {\r\n        s = s();\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if (false) {}\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\nfunction setActiveBranch(suspense, branch) {\r\n    suspense.activeBranch = branch;\r\n    const { vnode, parentComponent } = suspense;\r\n    const el = (vnode.el = branch.el);\r\n    // in case suspense is the root node of a component,\r\n    // recursively update the HOC el\r\n    if (parentComponent && parentComponent.subTree === vnode) {\r\n        parentComponent.vnode.el = el;\r\n        updateHOCHostEl(parentComponent, el);\r\n    }\r\n}\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\r\nfunction renderSlot(slots, name, props = {}, \r\n// this is not a user-facing function, so the fallback is always generated by\r\n// the compiler and guaranteed to be a function returning an array\r\nfallback) {\r\n    let slot = slots[name];\r\n    if (false) {}\r\n    // a compiled slot disables block tracking by default to avoid manual\r\n    // invocation interfering with template-based block tracking, but in\r\n    // `renderSlot` we can be sure that it\'s template-based so we can force\r\n    // enable it.\r\n    isRenderingCompiledSlot++;\r\n    openBlock();\r\n    const validSlotContent = slot && ensureValidVNode(slot(props));\r\n    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */\r\n        ? 64 /* STABLE_FRAGMENT */\r\n        : -2 /* BAIL */);\r\n    isRenderingCompiledSlot--;\r\n    return rendered;\r\n}\r\nfunction ensureValidVNode(vnodes) {\r\n    return vnodes.some(child => {\r\n        if (!isVNode(child))\r\n            return true;\r\n        if (child.type === Comment)\r\n            return false;\r\n        if (child.type === Fragment &&\r\n            !ensureValidVNode(child.children))\r\n            return false;\r\n        return true;\r\n    })\r\n        ? vnodes\r\n        : null;\r\n}\n\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance) {\r\n    if (!ctx)\r\n        return fn;\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we need to push a null block to\r\n        // avoid that. This isn\'t necessary if rendering a compiled `<slot>`.\r\n        if (!isRenderingCompiledSlot) {\r\n            openBlock(true /* null block that disables tracking */);\r\n        }\r\n        const owner = currentRenderingInstance;\r\n        setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(owner);\r\n        if (!isRenderingCompiledSlot) {\r\n            closeBlock();\r\n        }\r\n        return res;\r\n    };\r\n    renderFnWithContext._c = true;\r\n    return renderFnWithContext;\r\n}\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\nconst scopeIdStack = [];\r\n/**\r\n * @private\r\n */\r\nfunction pushScopeId(id) {\r\n    scopeIdStack.push((currentScopeId = id));\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    scopeIdStack.pop();\r\n    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction withScopeId(id) {\r\n    return ((fn) => withCtx(function () {\r\n        pushScopeId(id);\r\n        const res = fn.apply(this, arguments);\r\n        popScopeId();\r\n        return res;\r\n    }));\r\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\nisSSR = false) {\r\n    const props = {};\r\n    const attrs = {};\r\n    Object(shared_esm_bundler["h" /* def */])(attrs, InternalObjectKey, 1);\r\n    setFullProps(instance, rawProps, props, attrs);\r\n    // validation\r\n    if ((false)) {}\r\n    if (isStateful) {\r\n        // stateful\r\n        instance.props = isSSR ? props : shallowReactive(props);\r\n    }\r\n    else {\r\n        if (!instance.type.props) {\r\n            // functional w/ optional props, props === attrs\r\n            instance.props = attrs;\r\n        }\r\n        else {\r\n            // functional w/ declared props\r\n            instance.props = props;\r\n        }\r\n    }\r\n    instance.attrs = attrs;\r\n}\r\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\r\n    const { props, attrs, vnode: { patchFlag } } = instance;\r\n    const rawCurrentProps = toRaw(props);\r\n    const [options] = instance.propsOptions;\r\n    if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n     true &&\r\n        (optimized || patchFlag > 0) &&\r\n        !(patchFlag & 16 /* FULL_PROPS */)) {\r\n        if (patchFlag & 8 /* PROPS */) {\r\n            // Compiler-generated props & no keys change, just set the updated\r\n            // the props.\r\n            const propsToUpdate = instance.vnode.dynamicProps;\r\n            for (let i = 0; i < propsToUpdate.length; i++) {\r\n                const key = propsToUpdate[i];\r\n                // PROPS flag guarantees rawProps to be non-null\r\n                const value = rawProps[key];\r\n                if (options) {\r\n                    // attr / props separation was done on init and will be consistent\r\n                    // in this code path, so just check if attrs have it.\r\n                    if (Object(shared_esm_bundler["l" /* hasOwn */])(attrs, key)) {\r\n                        attrs[key] = value;\r\n                    }\r\n                    else {\r\n                        const camelizedKey = Object(shared_esm_bundler["f" /* camelize */])(key);\r\n                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    attrs[key] = value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // full props update.\r\n        setFullProps(instance, rawProps, props, attrs);\r\n        // in case of dynamic props, check if we need to delete keys from\r\n        // the props object\r\n        let kebabKey;\r\n        for (const key in rawCurrentProps) {\r\n            if (!rawProps ||\r\n                // for camelCase\r\n                (!Object(shared_esm_bundler["l" /* hasOwn */])(rawProps, key) &&\r\n                    // it\'s possible the original props was passed in as kebab-case\r\n                    // and converted to camelCase (#955)\r\n                    ((kebabKey = Object(shared_esm_bundler["m" /* hyphenate */])(key)) === key || !Object(shared_esm_bundler["l" /* hasOwn */])(rawProps, kebabKey)))) {\r\n                if (options) {\r\n                    if (rawPrevProps &&\r\n                        // for camelCase\r\n                        (rawPrevProps[key] !== undefined ||\r\n                            // for kebab-case\r\n                            rawPrevProps[kebabKey] !== undefined)) {\r\n                        props[key] = resolvePropValue(options, rawProps || shared_esm_bundler["b" /* EMPTY_OBJ */], key, undefined, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    delete props[key];\r\n                }\r\n            }\r\n        }\r\n        // in the case of functional component w/o props declaration, props and\r\n        // attrs point to the same object so it should already have been updated.\r\n        if (attrs !== rawCurrentProps) {\r\n            for (const key in attrs) {\r\n                if (!rawProps || !Object(shared_esm_bundler["l" /* hasOwn */])(rawProps, key)) {\r\n                    delete attrs[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // trigger updates for $attrs in case it\'s used in component slots\r\n    trigger(instance, "set" /* SET */, \'$attrs\');\r\n    if (false) {}\r\n}\r\nfunction setFullProps(instance, rawProps, props, attrs) {\r\n    const [options, needCastKeys] = instance.propsOptions;\r\n    if (rawProps) {\r\n        for (const key in rawProps) {\r\n            const value = rawProps[key];\r\n            // key, ref are reserved and never passed down\r\n            if (Object(shared_esm_bundler["y" /* isReservedProp */])(key)) {\r\n                continue;\r\n            }\r\n            // prop option names are camelized during normalization, so to support\r\n            // kebab -> camel conversion here we need to camelize the key.\r\n            let camelKey;\r\n            if (options && Object(shared_esm_bundler["l" /* hasOwn */])(options, (camelKey = Object(shared_esm_bundler["f" /* camelize */])(key)))) {\r\n                props[camelKey] = value;\r\n            }\r\n            else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                // Any non-declared (either as a prop or an emitted event) props are put\r\n                // into a separate `attrs` object for spreading. Make sure to preserve\r\n                // original key casing\r\n                attrs[key] = value;\r\n            }\r\n        }\r\n    }\r\n    if (needCastKeys) {\r\n        const rawCurrentProps = toRaw(props);\r\n        for (let i = 0; i < needCastKeys.length; i++) {\r\n            const key = needCastKeys[i];\r\n            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);\r\n        }\r\n    }\r\n}\r\nfunction resolvePropValue(options, props, key, value, instance) {\r\n    const opt = options[key];\r\n    if (opt != null) {\r\n        const hasDefault = Object(shared_esm_bundler["l" /* hasOwn */])(opt, \'default\');\r\n        // default values\r\n        if (hasDefault && value === undefined) {\r\n            const defaultValue = opt.default;\r\n            if (opt.type !== Function && Object(shared_esm_bundler["p" /* isFunction */])(defaultValue)) {\r\n                setCurrentInstance(instance);\r\n                value = defaultValue(props);\r\n                setCurrentInstance(null);\r\n            }\r\n            else {\r\n                value = defaultValue;\r\n            }\r\n        }\r\n        // boolean casting\r\n        if (opt[0 /* shouldCast */]) {\r\n            if (!Object(shared_esm_bundler["l" /* hasOwn */])(props, key) && !hasDefault) {\r\n                value = false;\r\n            }\r\n            else if (opt[1 /* shouldCastTrue */] &&\r\n                (value === \'\' || value === Object(shared_esm_bundler["m" /* hyphenate */])(key))) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__props) {\r\n        return comp.__props;\r\n    }\r\n    const raw = comp.props;\r\n    const normalized = {};\r\n    const needCastKeys = [];\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !Object(shared_esm_bundler["p" /* isFunction */])(comp)) {\r\n        const extendProps = (raw) => {\r\n            hasExtends = true;\r\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n            Object(shared_esm_bundler["i" /* extend */])(normalized, props);\r\n            if (keys)\r\n                needCastKeys.push(...keys);\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendProps);\r\n        }\r\n        if (comp.extends) {\r\n            extendProps(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendProps);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__props = shared_esm_bundler["a" /* EMPTY_ARR */]);\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            if (false) {}\r\n            const normalizedKey = Object(shared_esm_bundler["f" /* camelize */])(raw[i]);\r\n            if (validatePropName(normalizedKey)) {\r\n                normalized[normalizedKey] = shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n            }\r\n        }\r\n    }\r\n    else if (raw) {\r\n        if (false) {}\r\n        for (const key in raw) {\r\n            const normalizedKey = Object(shared_esm_bundler["f" /* camelize */])(key);\r\n            if (validatePropName(normalizedKey)) {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    Object(shared_esm_bundler["o" /* isArray */])(opt) || Object(shared_esm_bundler["p" /* isFunction */])(opt) ? { type: opt } : opt);\r\n                if (prop) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                    prop[1 /* shouldCastTrue */] =\r\n                        stringIndex < 0 || booleanIndex < stringIndex;\r\n                    // if the prop needs boolean casting or default value\r\n                    if (booleanIndex > -1 || Object(shared_esm_bundler["l" /* hasOwn */])(prop, \'default\')) {\r\n                        needCastKeys.push(normalizedKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (comp.__props = [normalized, needCastKeys]);\r\n}\r\nfunction validatePropName(key) {\r\n    if (key[0] !== \'$\') {\r\n        return true;\r\n    }\r\n    else if ((false)) {}\r\n    return false;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : \'\';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(expectedTypes)) {\r\n        for (let i = 0, len = expectedTypes.length; i < len; i++) {\r\n            if (isSameType(expectedTypes[i], type)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(props, instance) {\r\n    const rawValues = toRaw(props);\r\n    const options = instance.propsOptions[0];\r\n    for (const key in options) {\r\n        let opt = options[key];\r\n        if (opt == null)\r\n            continue;\r\n        validateProp(key, rawValues[key], opt, !Object(shared_esm_bundler["l" /* hasOwn */])(rawValues, key));\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(name, value, prop, isAbsent) {\r\n    const { type, required, validator } = prop;\r\n    // required!\r\n    if (required && isAbsent) {\r\n        warn(\'Missing required prop: "\' + name + \'"\');\r\n        return;\r\n    }\r\n    // missing but optional\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    // type check\r\n    if (type != null && type !== true) {\r\n        let isValid = false;\r\n        const types = Object(shared_esm_bundler["o" /* isArray */])(type) ? type : [type];\r\n        const expectedTypes = [];\r\n        // value is valid as long as one of the specified types match\r\n        for (let i = 0; i < types.length && !isValid; i++) {\r\n            const { valid, expectedType } = assertType(value, types[i]);\r\n            expectedTypes.push(expectedType || \'\');\r\n            isValid = valid;\r\n        }\r\n        if (!isValid) {\r\n            warn(getInvalidTypeMessage(name, value, expectedTypes));\r\n            return;\r\n        }\r\n    }\r\n    // custom validator\r\n    if (validator && !validator(value)) {\r\n        warn(\'Invalid prop: custom validator check failed for prop "\' + name + \'".\');\r\n    }\r\n}\r\nconst isSimpleType = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'String,Number,Boolean,Function,Symbol,BigInt\');\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value, type) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (isSimpleType(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === \'object\') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === \'Object\') {\r\n        valid = Object(shared_esm_bundler["v" /* isObject */])(value);\r\n    }\r\n    else if (expectedType === \'Array\') {\r\n        valid = Object(shared_esm_bundler["o" /* isArray */])(value);\r\n    }\r\n    else {\r\n        valid = value instanceof type;\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop "${name}".` +\r\n        ` Expected ${expectedTypes.map(shared_esm_bundler["g" /* capitalize */]).join(\', \')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = Object(shared_esm_bundler["P" /* toRawType */])(value);\r\n    const expectedValue = styleValue(value, expectedType);\r\n    const receivedValue = styleValue(value, receivedType);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        !runtime_core_esm_bundler_isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${expectedValue}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${receivedValue}.`;\r\n    }\r\n    return message;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value, type) {\r\n    if (type === \'String\') {\r\n        return `"${value}"`;\r\n    }\r\n    else if (type === \'Number\') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type) {\r\n    const explicitTypes = [\'string\', \'number\', \'boolean\'];\r\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction runtime_core_esm_bundler_isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === \'boolean\');\r\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\r\n    if (target) {\r\n        const hooks = target[type] || (target[type] = []);\r\n        // cache the error handling wrapper for injected hooks so the same hook\r\n        // can be properly deduped by the scheduler. "__weh" stands for "with error\r\n        // handling".\r\n        const wrappedHook = hook.__weh ||\r\n            (hook.__weh = (...args) => {\r\n                if (target.isUnmounted) {\r\n                    return;\r\n                }\r\n                // disable tracking inside all lifecycle hooks\r\n                // since they can potentially be called inside effects.\r\n                pauseTracking();\r\n                // Set currentInstance during hook invocation.\r\n                // This assumes the hook does not synchronously trigger other hooks, which\r\n                // can only be false when the user does something really funky.\r\n                setCurrentInstance(target);\r\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                setCurrentInstance(null);\r\n                resetTracking();\r\n                return res;\r\n            });\r\n        if (prepend) {\r\n            hooks.unshift(wrappedHook);\r\n        }\r\n        else {\r\n            hooks.push(wrappedHook);\r\n        }\r\n        return wrappedHook;\r\n    }\r\n    else if ((false)) {}\r\n}\r\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \r\n// post-create lifecycle registrations are noops during SSR\r\n!isInSSRComponentSetup && injectHook(lifecycle, hook, target);\r\nconst onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);\r\nconst onMounted = createHook("m" /* MOUNTED */);\r\nconst onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);\r\nconst onUpdated = createHook("u" /* UPDATED */);\r\nconst onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);\r\nconst onUnmounted = createHook("um" /* UNMOUNTED */);\r\nconst onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);\r\nconst onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);\r\nconst onErrorCaptured = (hook, target = currentInstance) => {\r\n    injectHook("ec" /* ERROR_CAPTURED */, hook, target);\r\n};\n\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if (false) {}\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared_esm_bundler["b" /* EMPTY_OBJ */], instance = currentInstance) {\r\n    if (false) {}\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (Object(shared_esm_bundler["p" /* isFunction */])(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */, [\r\n                    instance && instance.proxy\r\n                ]);\r\n            }\r\n            else {\r\n                ( false) && false;\r\n            }\r\n        });\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */, [\r\n                instance && instance.proxy\r\n            ]);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = shared_esm_bundler["d" /* NOOP */];\r\n        ( false) && false;\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = Object(shared_esm_bundler["o" /* isArray */])(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || Object(shared_esm_bundler["k" /* hasChanged */])(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it\'s changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === \'sync\') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === \'post\') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: \'pre\'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with \'pre\' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = reactivity_esm_bundler_effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === \'post\') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            Object(shared_esm_bundler["L" /* remove */])(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = Object(shared_esm_bundler["C" /* isString */])(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!Object(shared_esm_bundler["v" /* isObject */])(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["A" /* isSet */])(value) || Object(shared_esm_bundler["t" /* isMap */])(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\nfunction useTransitionState() {\r\n    const state = {\r\n        isMounted: false,\r\n        isLeaving: false,\r\n        isUnmounting: false,\r\n        leavingVNodes: new Map()\r\n    };\r\n    onMounted(() => {\r\n        state.isMounted = true;\r\n    });\r\n    onBeforeUnmount(() => {\r\n        state.isUnmounting = true;\r\n    });\r\n    return state;\r\n}\r\nconst TransitionHookValidator = [Function, Array];\r\nconst BaseTransitionImpl = {\r\n    name: `BaseTransition`,\r\n    props: {\r\n        mode: String,\r\n        appear: Boolean,\r\n        persisted: Boolean,\r\n        // enter\r\n        onBeforeEnter: TransitionHookValidator,\r\n        onEnter: TransitionHookValidator,\r\n        onAfterEnter: TransitionHookValidator,\r\n        onEnterCancelled: TransitionHookValidator,\r\n        // leave\r\n        onBeforeLeave: TransitionHookValidator,\r\n        onLeave: TransitionHookValidator,\r\n        onAfterLeave: TransitionHookValidator,\r\n        onLeaveCancelled: TransitionHookValidator,\r\n        // appear\r\n        onBeforeAppear: TransitionHookValidator,\r\n        onAppear: TransitionHookValidator,\r\n        onAfterAppear: TransitionHookValidator,\r\n        onAppearCancelled: TransitionHookValidator\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevTransitionKey;\r\n        return () => {\r\n            const children = slots.default && getTransitionRawChildren(slots.default(), true);\r\n            if (!children || !children.length) {\r\n                return;\r\n            }\r\n            // warn multiple elements\r\n            if (false) {}\r\n            // there\'s no need to track reactivity for these props so use the raw\r\n            // props for a bit better perf\r\n            const rawProps = toRaw(props);\r\n            const { mode } = rawProps;\r\n            // check mode\r\n            if (false) {}\r\n            // at this point children has a guaranteed length of 1.\r\n            const child = children[0];\r\n            if (state.isLeaving) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            // in the case of <transition><keep-alive/></transition>, we need to\r\n            // compare the type of the kept-alive children.\r\n            const innerChild = getKeepAliveChild(child);\r\n            if (!innerChild) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\r\n            setTransitionHooks(innerChild, enterHooks);\r\n            const oldChild = instance.subTree;\r\n            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\r\n            let transitionKeyChanged = false;\r\n            const { getTransitionKey } = innerChild.type;\r\n            if (getTransitionKey) {\r\n                const key = getTransitionKey();\r\n                if (prevTransitionKey === undefined) {\r\n                    prevTransitionKey = key;\r\n                }\r\n                else if (key !== prevTransitionKey) {\r\n                    prevTransitionKey = key;\r\n                    transitionKeyChanged = true;\r\n                }\r\n            }\r\n            // handle mode\r\n            if (oldInnerChild &&\r\n                oldInnerChild.type !== Comment &&\r\n                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\r\n                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\r\n                // update old tree\'s hooks in case of dynamic transition\r\n                setTransitionHooks(oldInnerChild, leavingHooks);\r\n                // switching between different views\r\n                if (mode === \'out-in\') {\r\n                    state.isLeaving = true;\r\n                    // return placeholder node and queue update when leave finishes\r\n                    leavingHooks.afterLeave = () => {\r\n                        state.isLeaving = false;\r\n                        instance.update();\r\n                    };\r\n                    return emptyPlaceholder(child);\r\n                }\r\n                else if (mode === \'in-out\') {\r\n                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\r\n                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\r\n                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\r\n                        // early removal callback\r\n                        el._leaveCb = () => {\r\n                            earlyRemove();\r\n                            el._leaveCb = undefined;\r\n                            delete enterHooks.delayedLeave;\r\n                        };\r\n                        enterHooks.delayedLeave = delayedLeave;\r\n                    };\r\n                }\r\n            }\r\n            return child;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst BaseTransition = BaseTransitionImpl;\r\nfunction getLeavingNodesForType(state, vnode) {\r\n    const { leavingVNodes } = state;\r\n    let leavingVNodesCache = leavingVNodes.get(vnode.type);\r\n    if (!leavingVNodesCache) {\r\n        leavingVNodesCache = Object.create(null);\r\n        leavingVNodes.set(vnode.type, leavingVNodesCache);\r\n    }\r\n    return leavingVNodesCache;\r\n}\r\n// The transition hooks are attached to the vnode as vnode.transition\r\n// and will be called at appropriate timing in the renderer.\r\nfunction resolveTransitionHooks(vnode, props, state, instance) {\r\n    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\r\n    const key = String(vnode.key);\r\n    const leavingVNodesCache = getLeavingNodesForType(state, vnode);\r\n    const callHook = (hook, args) => {\r\n        hook &&\r\n            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\r\n    };\r\n    const hooks = {\r\n        mode,\r\n        persisted,\r\n        beforeEnter(el) {\r\n            let hook = onBeforeEnter;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onBeforeAppear || onBeforeEnter;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            // for same element (v-show)\r\n            if (el._leaveCb) {\r\n                el._leaveCb(true /* cancelled */);\r\n            }\r\n            // for toggled element with same key (v-if)\r\n            const leavingVNode = leavingVNodesCache[key];\r\n            if (leavingVNode &&\r\n                isSameVNodeType(vnode, leavingVNode) &&\r\n                leavingVNode.el._leaveCb) {\r\n                // force early removal (not cancelled)\r\n                leavingVNode.el._leaveCb();\r\n            }\r\n            callHook(hook, [el]);\r\n        },\r\n        enter(el) {\r\n            let hook = onEnter;\r\n            let afterHook = onAfterEnter;\r\n            let cancelHook = onEnterCancelled;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onAppear || onEnter;\r\n                    afterHook = onAfterAppear || onAfterEnter;\r\n                    cancelHook = onAppearCancelled || onEnterCancelled;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            let called = false;\r\n            const done = (el._enterCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                if (cancelled) {\r\n                    callHook(cancelHook, [el]);\r\n                }\r\n                else {\r\n                    callHook(afterHook, [el]);\r\n                }\r\n                if (hooks.delayedLeave) {\r\n                    hooks.delayedLeave();\r\n                }\r\n                el._enterCb = undefined;\r\n            });\r\n            if (hook) {\r\n                hook(el, done);\r\n                if (hook.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        leave(el, remove) {\r\n            const key = String(vnode.key);\r\n            if (el._enterCb) {\r\n                el._enterCb(true /* cancelled */);\r\n            }\r\n            if (state.isUnmounting) {\r\n                return remove();\r\n            }\r\n            callHook(onBeforeLeave, [el]);\r\n            let called = false;\r\n            const done = (el._leaveCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                remove();\r\n                if (cancelled) {\r\n                    callHook(onLeaveCancelled, [el]);\r\n                }\r\n                else {\r\n                    callHook(onAfterLeave, [el]);\r\n                }\r\n                el._leaveCb = undefined;\r\n                if (leavingVNodesCache[key] === vnode) {\r\n                    delete leavingVNodesCache[key];\r\n                }\r\n            });\r\n            leavingVNodesCache[key] = vnode;\r\n            if (onLeave) {\r\n                onLeave(el, done);\r\n                if (onLeave.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        clone(vnode) {\r\n            return resolveTransitionHooks(vnode, props, state, instance);\r\n        }\r\n    };\r\n    return hooks;\r\n}\r\n// the placeholder really only handles one special case: KeepAlive\r\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n// placeholder with empty content to avoid the KeepAlive instance from being\r\n// unmounted.\r\nfunction emptyPlaceholder(vnode) {\r\n    if (isKeepAlive(vnode)) {\r\n        vnode = cloneVNode(vnode);\r\n        vnode.children = null;\r\n        return vnode;\r\n    }\r\n}\r\nfunction getKeepAliveChild(vnode) {\r\n    return isKeepAlive(vnode)\r\n        ? vnode.children\r\n            ? vnode.children[0]\r\n            : undefined\r\n        : vnode;\r\n}\r\nfunction setTransitionHooks(vnode, hooks) {\r\n    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\r\n        setTransitionHooks(vnode.component.subTree, hooks);\r\n    }\r\n    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        vnode.ssContent.transition = hooks.clone(vnode.ssContent);\r\n        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\r\n    }\r\n    else {\r\n        vnode.transition = hooks;\r\n    }\r\n}\r\nfunction getTransitionRawChildren(children, keepComment = false) {\r\n    let ret = [];\r\n    let keyedFragmentCount = 0;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // handle fragment children case, e.g. v-for\r\n        if (child.type === Fragment) {\r\n            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\r\n                keyedFragmentCount++;\r\n            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));\r\n        }\r\n        // comment placeholders should be skipped, e.g. v-if\r\n        else if (keepComment || child.type !== Comment) {\r\n            ret.push(child);\r\n        }\r\n    }\r\n    // #1126 if a transition children list contains multiple sub fragments, these\r\n    // fragments will be merged into a flat children array. Since each v-for\r\n    // fragment may contain different static bindings inside, we need to de-op\r\n    // these children to force full diffs to ensure correct behavior.\r\n    if (keyedFragmentCount > 1) {\r\n        for (let i = 0; i < ret.length; i++) {\r\n            ret[i].patchFlag = -2 /* BAIL */;\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\nconst KeepAliveImpl = {\r\n    name: `KeepAlive`,\r\n    // Marker for special handling inside the renderer. We are not using a ===\r\n    // check directly on KeepAlive in the renderer, because importing it directly\r\n    // would prevent it from being tree-shaken.\r\n    __isKeepAlive: true,\r\n    props: {\r\n        include: [String, RegExp, Array],\r\n        exclude: [String, RegExp, Array],\r\n        max: [String, Number]\r\n    },\r\n    setup(props, { slots }) {\r\n        const cache = new Map();\r\n        const keys = new Set();\r\n        let current = null;\r\n        const instance = getCurrentInstance();\r\n        const parentSuspense = instance.suspense;\r\n        // KeepAlive communicates with the instantiated renderer via the\r\n        // ctx where the renderer passes in its internals,\r\n        // and the KeepAlive instance exposes activate/deactivate implementations.\r\n        // The whole point of this is to avoid importing KeepAlive directly in the\r\n        // renderer to facilitate tree-shaking.\r\n        const sharedContext = instance.ctx;\r\n        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\r\n        const storageContainer = createElement(\'div\');\r\n        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n            const instance = vnode.component;\r\n            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\r\n            // in case props have changed\r\n            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);\r\n            queuePostRenderEffect(() => {\r\n                instance.isDeactivated = false;\r\n                if (instance.a) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.a);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n            }, parentSuspense);\r\n        };\r\n        sharedContext.deactivate = (vnode) => {\r\n            const instance = vnode.component;\r\n            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\r\n            queuePostRenderEffect(() => {\r\n                if (instance.da) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.da);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n                instance.isDeactivated = true;\r\n            }, parentSuspense);\r\n        };\r\n        function unmount(vnode) {\r\n            // reset the shapeFlag so it can be properly unmounted\r\n            resetShapeFlag(vnode);\r\n            _unmount(vnode, instance, parentSuspense);\r\n        }\r\n        function pruneCache(filter) {\r\n            cache.forEach((vnode, key) => {\r\n                const name = getComponentName(vnode.type);\r\n                if (name && (!filter || !filter(name))) {\r\n                    pruneCacheEntry(key);\r\n                }\r\n            });\r\n        }\r\n        function pruneCacheEntry(key) {\r\n            const cached = cache.get(key);\r\n            if (!current || cached.type !== current.type) {\r\n                unmount(cached);\r\n            }\r\n            else if (current) {\r\n                // current active instance should no longer be kept-alive.\r\n                // we can\'t unmount it now but it might be later, so reset its flag now.\r\n                resetShapeFlag(current);\r\n            }\r\n            cache.delete(key);\r\n            keys.delete(key);\r\n        }\r\n        // prune cache on include/exclude prop change\r\n        watch(() => [props.include, props.exclude], ([include, exclude]) => {\r\n            include && pruneCache(name => runtime_core_esm_bundler_matches(include, name));\r\n            exclude && pruneCache(name => !runtime_core_esm_bundler_matches(exclude, name));\r\n        }, \r\n        // prune post-render after `current` has been updated\r\n        { flush: \'post\', deep: true });\r\n        // cache sub tree after render\r\n        let pendingCacheKey = null;\r\n        const cacheSubtree = () => {\r\n            // fix #1621, the pendingCacheKey could be 0\r\n            if (pendingCacheKey != null) {\r\n                cache.set(pendingCacheKey, getInnerChild(instance.subTree));\r\n            }\r\n        };\r\n        onMounted(cacheSubtree);\r\n        onUpdated(cacheSubtree);\r\n        onBeforeUnmount(() => {\r\n            cache.forEach(cached => {\r\n                const { subTree, suspense } = instance;\r\n                const vnode = getInnerChild(subTree);\r\n                if (cached.type === vnode.type) {\r\n                    // current instance will be unmounted as part of keep-alive\'s unmount\r\n                    resetShapeFlag(vnode);\r\n                    // but invoke its deactivated hook here\r\n                    const da = vnode.component.da;\r\n                    da && queuePostRenderEffect(da, suspense);\r\n                    return;\r\n                }\r\n                unmount(cached);\r\n            });\r\n        });\r\n        return () => {\r\n            pendingCacheKey = null;\r\n            if (!slots.default) {\r\n                return null;\r\n            }\r\n            const children = slots.default();\r\n            const rawVNode = children[0];\r\n            if (children.length > 1) {\r\n                if ((false)) {}\r\n                current = null;\r\n                return children;\r\n            }\r\n            else if (!isVNode(rawVNode) ||\r\n                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\r\n                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\r\n                current = null;\r\n                return rawVNode;\r\n            }\r\n            let vnode = getInnerChild(rawVNode);\r\n            const comp = vnode.type;\r\n            const name = getComponentName(comp);\r\n            const { include, exclude, max } = props;\r\n            if ((include && (!name || !runtime_core_esm_bundler_matches(include, name))) ||\r\n                (exclude && name && runtime_core_esm_bundler_matches(exclude, name))) {\r\n                current = vnode;\r\n                return rawVNode;\r\n            }\r\n            const key = vnode.key == null ? comp : vnode.key;\r\n            const cachedVNode = cache.get(key);\r\n            // clone vnode if it\'s reused because we are going to mutate it\r\n            if (vnode.el) {\r\n                vnode = cloneVNode(vnode);\r\n                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\r\n                    rawVNode.ssContent = vnode;\r\n                }\r\n            }\r\n            // #1513 it\'s possible for the returned vnode to be cloned due to attr\r\n            // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n            // that is mounted. Instead of caching it directly, we store the pending\r\n            // key and cache `instance.subTree` (the normalized vnode) in\r\n            // beforeMount/beforeUpdate hooks.\r\n            pendingCacheKey = key;\r\n            if (cachedVNode) {\r\n                // copy over mounted state\r\n                vnode.el = cachedVNode.el;\r\n                vnode.component = cachedVNode.component;\r\n                if (vnode.transition) {\r\n                    // recursively update transition hooks on subTree\r\n                    setTransitionHooks(vnode, vnode.transition);\r\n                }\r\n                // avoid vnode being mounted as fresh\r\n                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\r\n                // make this key the freshest\r\n                keys.delete(key);\r\n                keys.add(key);\r\n            }\r\n            else {\r\n                keys.add(key);\r\n                // prune oldest entry\r\n                if (max && keys.size > parseInt(max, 10)) {\r\n                    pruneCacheEntry(keys.values().next().value);\r\n                }\r\n            }\r\n            // avoid vnode being unmounted\r\n            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n            current = vnode;\r\n            return rawVNode;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst KeepAlive = KeepAliveImpl;\r\nfunction runtime_core_esm_bundler_matches(pattern, name) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(pattern)) {\r\n        return pattern.some((p) => runtime_core_esm_bundler_matches(p, name));\r\n    }\r\n    else if (Object(shared_esm_bundler["C" /* isString */])(pattern)) {\r\n        return pattern.split(\',\').indexOf(name) > -1;\r\n    }\r\n    else if (pattern.test) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction onActivated(hook, target) {\r\n    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);\r\n}\r\nfunction onDeactivated(hook, target) {\r\n    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);\r\n}\r\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\r\n    // cache the deactivate branch check wrapper for injected hooks so the same\r\n    // hook can be properly deduped by the scheduler. "__wdc" stands for "with\r\n    // deactivation check".\r\n    const wrappedHook = hook.__wdc ||\r\n        (hook.__wdc = () => {\r\n            // only fire the hook if the target instance is NOT in a deactivated branch.\r\n            let current = target;\r\n            while (current) {\r\n                if (current.isDeactivated) {\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            hook();\r\n        });\r\n    injectHook(type, wrappedHook, target);\r\n    // In addition to registering it on the target instance, we walk up the parent\r\n    // chain and register it on all ancestor instances that are keep-alive roots.\r\n    // This avoids the need to walk the entire component tree when invoking these\r\n    // hooks, and more importantly, avoids the need to track child components in\r\n    // arrays.\r\n    if (target) {\r\n        let current = target.parent;\r\n        while (current && current.parent) {\r\n            if (isKeepAlive(current.parent.vnode)) {\r\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n            }\r\n            current = current.parent;\r\n        }\r\n    }\r\n}\r\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n    // injectHook wraps the original for error handling, so make sure to remove\r\n    // the wrapped version.\r\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n    onUnmounted(() => {\r\n        Object(shared_esm_bundler["L" /* remove */])(keepAliveRoot[type], injected);\r\n    }, target);\r\n}\r\nfunction resetShapeFlag(vnode) {\r\n    let shapeFlag = vnode.shapeFlag;\r\n    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n    }\r\n    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\r\n    }\r\n    vnode.shapeFlag = shapeFlag;\r\n}\r\nfunction getInnerChild(vnode) {\r\n    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\r\n}\n\nconst isInternalKey = (key) => key[0] === \'_\' || key === \'$stable\';\r\nconst normalizeSlotValue = (value) => Object(shared_esm_bundler["o" /* isArray */])(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value)];\r\nconst normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {\r\n    if (false) {}\r\n    return normalizeSlotValue(rawSlot(props));\r\n}, ctx);\r\nconst normalizeObjectSlots = (rawSlots, slots) => {\r\n    const ctx = rawSlots._ctx;\r\n    for (const key in rawSlots) {\r\n        if (isInternalKey(key))\r\n            continue;\r\n        const value = rawSlots[key];\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(value)) {\r\n            slots[key] = normalizeSlot(key, value, ctx);\r\n        }\r\n        else if (value != null) {\r\n            if ((false)) {}\r\n            const normalized = normalizeSlotValue(value);\r\n            slots[key] = () => normalized;\r\n        }\r\n    }\r\n};\r\nconst normalizeVNodeSlots = (instance, children) => {\r\n    if (false) {}\r\n    const normalized = normalizeSlotValue(children);\r\n    instance.slots.default = () => normalized;\r\n};\r\nconst initSlots = (instance, children) => {\r\n    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            instance.slots = children;\r\n            // make compiler marker non-enumerable\r\n            Object(shared_esm_bundler["h" /* def */])(children, \'_\', type);\r\n        }\r\n        else {\r\n            normalizeObjectSlots(children, (instance.slots = {}));\r\n        }\r\n    }\r\n    else {\r\n        instance.slots = {};\r\n        if (children) {\r\n            normalizeVNodeSlots(instance, children);\r\n        }\r\n    }\r\n    Object(shared_esm_bundler["h" /* def */])(instance.slots, InternalObjectKey, 1);\r\n};\r\nconst updateSlots = (instance, children) => {\r\n    const { vnode, slots } = instance;\r\n    let needDeletionCheck = true;\r\n    let deletionComparisonTarget = shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // compiled slots.\r\n            if (false) {}\r\n            else if (type === 1 /* STABLE */) {\r\n                // compiled AND stable.\r\n                // no need to update, and skip stale slots removal.\r\n                needDeletionCheck = false;\r\n            }\r\n            else {\r\n                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n                // normalization.\r\n                Object(shared_esm_bundler["i" /* extend */])(slots, children);\r\n            }\r\n        }\r\n        else {\r\n            needDeletionCheck = !children.$stable;\r\n            normalizeObjectSlots(children, slots);\r\n        }\r\n        deletionComparisonTarget = children;\r\n    }\r\n    else if (children) {\r\n        // non slot object children (direct value) passed to a component\r\n        normalizeVNodeSlots(instance, children);\r\n        deletionComparisonTarget = { default: 1 };\r\n    }\r\n    // delete stale slots\r\n    if (needDeletionCheck) {\r\n        for (const key in slots) {\r\n            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\r\n                delete slots[key];\r\n            }\r\n        }\r\n    }\r\n};\n\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent(\'comp\')\r\nconst foo = resolveDirective(\'foo\')\r\nconst bar = resolveDirective(\'bar\')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\nconst isBuiltInDirective = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text\');\r\nfunction validateDirectiveName(name) {\r\n    if (isBuiltInDirective(name)) {\r\n        warn(\'Do not use built-in directive ids as custom directive id: \' + name);\r\n    }\r\n}\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nfunction withDirectives(vnode, directives) {\r\n    const internalInstance = currentRenderingInstance;\r\n    if (internalInstance === null) {\r\n        ( false) && false;\r\n        return vnode;\r\n    }\r\n    const instance = internalInstance.proxy;\r\n    const bindings = vnode.dirs || (vnode.dirs = []);\r\n    for (let i = 0; i < directives.length; i++) {\r\n        let [dir, value, arg, modifiers = shared_esm_bundler["b" /* EMPTY_OBJ */]] = directives[i];\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(dir)) {\r\n            dir = {\r\n                mounted: dir,\r\n                updated: dir\r\n            };\r\n        }\r\n        bindings.push({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: void 0,\r\n            arg,\r\n            modifiers\r\n        });\r\n    }\r\n    return vnode;\r\n}\r\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\r\n    const bindings = vnode.dirs;\r\n    const oldBindings = prevVNode && prevVNode.dirs;\r\n    for (let i = 0; i < bindings.length; i++) {\r\n        const binding = bindings[i];\r\n        if (oldBindings) {\r\n            binding.oldValue = oldBindings[i].value;\r\n        }\r\n        const hook = binding.dir[name];\r\n        if (hook) {\r\n            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\r\n                vnode.el,\r\n                binding,\r\n                vnode,\r\n                prevVNode\r\n            ]);\r\n        }\r\n    }\r\n}\n\nfunction createAppContext() {\r\n    return {\r\n        app: null,\r\n        config: {\r\n            isNativeTag: shared_esm_bundler["c" /* NO */],\r\n            performance: false,\r\n            globalProperties: {},\r\n            optionMergeStrategies: {},\r\n            isCustomElement: shared_esm_bundler["c" /* NO */],\r\n            errorHandler: undefined,\r\n            warnHandler: undefined\r\n        },\r\n        mixins: [],\r\n        components: {},\r\n        directives: {},\r\n        provides: Object.create(null)\r\n    };\r\n}\r\nlet runtime_core_esm_bundler_uid = 0;\r\nfunction createAppAPI(render, hydrate) {\r\n    return function createApp(rootComponent, rootProps = null) {\r\n        if (rootProps != null && !Object(shared_esm_bundler["v" /* isObject */])(rootProps)) {\r\n            ( false) && false;\r\n            rootProps = null;\r\n        }\r\n        const context = createAppContext();\r\n        const installedPlugins = new Set();\r\n        let isMounted = false;\r\n        const app = (context.app = {\r\n            _uid: runtime_core_esm_bundler_uid++,\r\n            _component: rootComponent,\r\n            _props: rootProps,\r\n            _container: null,\r\n            _context: context,\r\n            version,\r\n            get config() {\r\n                return context.config;\r\n            },\r\n            set config(v) {\r\n                if ((false)) {}\r\n            },\r\n            use(plugin, ...options) {\r\n                if (installedPlugins.has(plugin)) {\r\n                    ( false) && false;\r\n                }\r\n                else if (plugin && Object(shared_esm_bundler["p" /* isFunction */])(plugin.install)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin.install(app, ...options);\r\n                }\r\n                else if (Object(shared_esm_bundler["p" /* isFunction */])(plugin)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin(app, ...options);\r\n                }\r\n                else if ((false)) {}\r\n                return app;\r\n            },\r\n            mixin(mixin) {\r\n                if (__VUE_OPTIONS_API__) {\r\n                    if (!context.mixins.includes(mixin)) {\r\n                        context.mixins.push(mixin);\r\n                        // global mixin with props/emits de-optimizes props/emits\r\n                        // normalization caching.\r\n                        if (mixin.props || mixin.emits) {\r\n                            context.deopt = true;\r\n                        }\r\n                    }\r\n                    else if ((false)) {}\r\n                }\r\n                else if ((false)) {}\r\n                return app;\r\n            },\r\n            component(name, component) {\r\n                if ((false)) {}\r\n                if (!component) {\r\n                    return context.components[name];\r\n                }\r\n                if (false) {}\r\n                context.components[name] = component;\r\n                return app;\r\n            },\r\n            directive(name, directive) {\r\n                if ((false)) {}\r\n                if (!directive) {\r\n                    return context.directives[name];\r\n                }\r\n                if (false) {}\r\n                context.directives[name] = directive;\r\n                return app;\r\n            },\r\n            mount(rootContainer, isHydrate) {\r\n                if (!isMounted) {\r\n                    const vnode = createVNode(rootComponent, rootProps);\r\n                    // store app context on the root VNode.\r\n                    // this will be set on the root instance on initial mount.\r\n                    vnode.appContext = context;\r\n                    // HMR root reload\r\n                    if ((false)) {}\r\n                    if (isHydrate && hydrate) {\r\n                        hydrate(vnode, rootContainer);\r\n                    }\r\n                    else {\r\n                        render(vnode, rootContainer);\r\n                    }\r\n                    isMounted = true;\r\n                    app._container = rootContainer;\r\n                    rootContainer.__vue_app__ = app;\r\n                    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                        devtoolsInitApp(app, version);\r\n                    }\r\n                    return vnode.component.proxy;\r\n                }\r\n                else if ((false)) {}\r\n            },\r\n            unmount() {\r\n                if (isMounted) {\r\n                    render(null, app._container);\r\n                    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                        devtoolsUnmountApp(app);\r\n                    }\r\n                    delete app._container.__vue_app__;\r\n                }\r\n                else if ((false)) {}\r\n            },\r\n            provide(key, value) {\r\n                if (false) {}\r\n                // TypeScript doesn\'t allow symbols as index type\r\n                // https://github.com/Microsoft/TypeScript/issues/24587\r\n                context.provides[key] = value;\r\n                return app;\r\n            }\r\n        });\r\n        return app;\r\n    };\r\n}\n\nlet hasMismatch = false;\r\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== \'foreignObject\';\r\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\r\n// Note: hydration is DOM-specific\r\n// But we have to place it in core due to tight coupling with core - splitting\r\n// it out creates a ton of unnecessary complexity.\r\n// Hydration also depends on some renderer internal logic which needs to be\r\n// passed in via arguments.\r\nfunction createHydrationFunctions(rendererInternals) {\r\n    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\r\n    const hydrate = (vnode, container) => {\r\n        if (false) {}\r\n        hasMismatch = false;\r\n        hydrateNode(container.firstChild, vnode, null, null);\r\n        flushPostFlushCbs();\r\n        if (hasMismatch && !false) {\r\n            // this error should show up in production\r\n            console.error(`Hydration completed but contains mismatches.`);\r\n        }\r\n    };\r\n    const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {\r\n        const isFragmentStart = isComment(node) && node.data === \'[\';\r\n        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, isFragmentStart);\r\n        const { type, ref, shapeFlag } = vnode;\r\n        const domType = node.nodeType;\r\n        vnode.el = node;\r\n        let nextNode = null;\r\n        switch (type) {\r\n            case Text:\r\n                if (domType !== 3 /* TEXT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    if (node.data !== vnode.children) {\r\n                        hasMismatch = true;\r\n                        ( false) &&\r\n                            false;\r\n                        node.data = vnode.children;\r\n                    }\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Comment:\r\n                if (domType !== 8 /* COMMENT */ || isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Static:\r\n                if (domType !== 1 /* ELEMENT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    // determine anchor, adopt content\r\n                    nextNode = node;\r\n                    // if the static vnode has its content stripped during build,\r\n                    // adopt it from the server-rendered HTML.\r\n                    const needToAdoptContent = !vnode.children.length;\r\n                    for (let i = 0; i < vnode.staticCount; i++) {\r\n                        if (needToAdoptContent)\r\n                            vnode.children += nextNode.outerHTML;\r\n                        if (i === vnode.staticCount - 1) {\r\n                            vnode.anchor = nextNode;\r\n                        }\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    return nextNode;\r\n                }\r\n                break;\r\n            case Fragment:\r\n                if (!isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);\r\n                }\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    if (domType !== 1 /* ELEMENT */ ||\r\n                        vnode.type !== node.tagName.toLowerCase()) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    // when setting up the render effect, if the initial vnode already\r\n                    // has .el set, the component will perform hydration instead of mount\r\n                    // on its sub-tree.\r\n                    const container = parentNode(node);\r\n                    const hydrateComponent = () => {\r\n                        mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\r\n                    };\r\n                    // async component\r\n                    const loadAsync = vnode.type.__asyncLoader;\r\n                    if (loadAsync) {\r\n                        loadAsync().then(hydrateComponent);\r\n                    }\r\n                    else {\r\n                        hydrateComponent();\r\n                    }\r\n                    // component may be async, so in the case of fragments we cannot rely\r\n                    // on component\'s rendered output to determine the end of the fragment\r\n                    // instead, we do a lookahead to find the end anchor node.\r\n                    nextNode = isFragmentStart\r\n                        ? locateClosingAsyncAnchor(node)\r\n                        : nextSibling(node);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    if (domType !== 8 /* COMMENT */) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);\r\n                }\r\n                else if ((false)) {}\r\n        }\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode);\r\n        }\r\n        return nextNode;\r\n    };\r\n    const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {\r\n        optimized = optimized || !!vnode.dynamicChildren;\r\n        const { props, patchFlag, shapeFlag, dirs } = vnode;\r\n        // skip props & children if this is hoisted static nodes\r\n        if (patchFlag !== -1 /* HOISTED */) {\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'created\');\r\n            }\r\n            // props\r\n            if (props) {\r\n                if (!optimized ||\r\n                    (patchFlag & 16 /* FULL_PROPS */ ||\r\n                        patchFlag & 32 /* HYDRATE_EVENTS */)) {\r\n                    for (const key in props) {\r\n                        if (!Object(shared_esm_bundler["y" /* isReservedProp */])(key) && Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n                            patchProp(el, key, null, props[key]);\r\n                        }\r\n                    }\r\n                }\r\n                else if (props.onClick) {\r\n                    // Fast path for click listeners (which is most often) to avoid\r\n                    // iterating through props.\r\n                    patchProp(el, \'onClick\', null, props.onClick);\r\n                }\r\n            }\r\n            // vnode / directive hooks\r\n            let vnodeHooks;\r\n            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n                invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'beforeMount\');\r\n            }\r\n            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\r\n                queueEffectWithSuspense(() => {\r\n                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n                    dirs && invokeDirectiveHook(vnode, null, parentComponent, \'mounted\');\r\n                }, parentSuspense);\r\n            }\r\n            // children\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\r\n                // skip if element has innerHTML / textContent\r\n                !(props && (props.innerHTML || props.textContent))) {\r\n                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);\r\n                let hasWarned = false;\r\n                while (next) {\r\n                    hasMismatch = true;\r\n                    if (false) {}\r\n                    // The SSRed DOM contains more nodes than it should. Remove them.\r\n                    const cur = next;\r\n                    next = next.nextSibling;\r\n                    remove(cur);\r\n                }\r\n            }\r\n            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                if (el.textContent !== vnode.children) {\r\n                    hasMismatch = true;\r\n                    ( false) &&\r\n                        false;\r\n                    el.textContent = vnode.children;\r\n                }\r\n            }\r\n        }\r\n        return el.nextSibling;\r\n    };\r\n    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, optimized) => {\r\n        optimized = optimized || !!parentVNode.dynamicChildren;\r\n        const children = parentVNode.children;\r\n        const l = children.length;\r\n        let hasWarned = false;\r\n        for (let i = 0; i < l; i++) {\r\n            const vnode = optimized\r\n                ? children[i]\r\n                : (children[i] = normalizeVNode(children[i]));\r\n            if (node) {\r\n                node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);\r\n            }\r\n            else {\r\n                hasMismatch = true;\r\n                if (false) {}\r\n                // the SSRed DOM didn\'t contain enough nodes. Mount the missing ones.\r\n                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {\r\n        const container = parentNode(node);\r\n        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);\r\n        if (next && isComment(next) && next.data === \']\') {\r\n            return nextSibling((vnode.anchor = next));\r\n        }\r\n        else {\r\n            // fragment didn\'t hydrate successfully, since we didn\'t get a end anchor\r\n            // back. This should have led to node/children mismatch warnings.\r\n            hasMismatch = true;\r\n            // since the anchor is missing, we need to create one and insert it\r\n            insert((vnode.anchor = createComment(`]`)), container, next);\r\n            return next;\r\n        }\r\n    };\r\n    const handleMismatch = (node, vnode, parentComponent, parentSuspense, isFragment) => {\r\n        hasMismatch = true;\r\n        ( false) &&\r\n            false;\r\n        vnode.el = null;\r\n        if (isFragment) {\r\n            // remove excessive fragment nodes\r\n            const end = locateClosingAsyncAnchor(node);\r\n            while (true) {\r\n                const next = nextSibling(node);\r\n                if (next && next !== end) {\r\n                    remove(next);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const next = nextSibling(node);\r\n        const container = parentNode(node);\r\n        remove(node);\r\n        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));\r\n        return next;\r\n    };\r\n    const locateClosingAsyncAnchor = (node) => {\r\n        let match = 0;\r\n        while (node) {\r\n            node = nextSibling(node);\r\n            if (node && isComment(node)) {\r\n                if (node.data === \'[\')\r\n                    match++;\r\n                if (node.data === \']\') {\r\n                    if (match === 0) {\r\n                        return nextSibling(node);\r\n                    }\r\n                    else {\r\n                        match--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    return [hydrate, hydrateNode];\r\n}\n\nlet supported;\r\nlet perf;\r\nfunction startMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        perf.mark(`vue-${type}-${instance.uid}`);\r\n    }\r\n}\r\nfunction endMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        const startTag = `vue-${type}-${instance.uid}`;\r\n        const endTag = startTag + `:end`;\r\n        perf.mark(endTag);\r\n        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\r\n        perf.clearMarks(startTag);\r\n        perf.clearMarks(endTag);\r\n    }\r\n}\r\nfunction isSupported() {\r\n    if (supported !== undefined) {\r\n        return supported;\r\n    }\r\n    /* eslint-disable no-restricted-globals */\r\n    if (typeof window !== \'undefined\' && window.performance) {\r\n        supported = true;\r\n        perf = window.performance;\r\n    }\r\n    else {\r\n        supported = false;\r\n    }\r\n    /* eslint-enable no-restricted-globals */\r\n    return supported;\r\n}\n\n/**\r\n * This is only called in esm-bundler builds.\r\n * It is called when a renderer is created, in `baseCreateRenderer` so that\r\n * importing runtime-core is side-effects free.\r\n *\r\n * istanbul-ignore-next\r\n */\r\nfunction initFeatureFlags() {\r\n    let needWarn = false;\r\n    if (typeof __VUE_OPTIONS_API__ !== \'boolean\') {\r\n        needWarn = true;\r\n        Object(shared_esm_bundler["j" /* getGlobalThis */])().__VUE_OPTIONS_API__ = true;\r\n    }\r\n    if (typeof __VUE_PROD_DEVTOOLS__ !== \'boolean\') {\r\n        needWarn = true;\r\n        Object(shared_esm_bundler["j" /* getGlobalThis */])().__VUE_PROD_DEVTOOLS__ = false;\r\n    }\r\n    if (false) {}\r\n}\n\n// implementation, close to no-op\r\nfunction defineComponent(options) {\r\n    return Object(shared_esm_bundler["p" /* isFunction */])(options) ? { setup: options, name: options.name } : options;\r\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\r\nfunction defineAsyncComponent(source) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(source)) {\r\n        source = { loader: source };\r\n    }\r\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\r\n    suspensible = true, onError: userOnError } = source;\r\n    let pendingRequest = null;\r\n    let resolvedComp;\r\n    let retries = 0;\r\n    const retry = () => {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    const load = () => {\r\n        let thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest = loader()\r\n                .catch(err => {\r\n                err = err instanceof Error ? err : new Error(String(err));\r\n                if (userOnError) {\r\n                    return new Promise((resolve, reject) => {\r\n                        const userRetry = () => resolve(retry());\r\n                        const userFail = () => reject(err);\r\n                        userOnError(err, userRetry, userFail, retries + 1);\r\n                    });\r\n                }\r\n                else {\r\n                    throw err;\r\n                }\r\n            })\r\n                .then((comp) => {\r\n                if (thisRequest !== pendingRequest && pendingRequest) {\r\n                    return pendingRequest;\r\n                }\r\n                if (false) {}\r\n                // interop module default\r\n                if (comp &&\r\n                    (comp.__esModule || comp[Symbol.toStringTag] === \'Module\')) {\r\n                    comp = comp.default;\r\n                }\r\n                if (false) {}\r\n                resolvedComp = comp;\r\n                return comp;\r\n            })));\r\n    };\r\n    return defineComponent({\r\n        __asyncLoader: load,\r\n        name: \'AsyncComponentWrapper\',\r\n        setup() {\r\n            const instance = currentInstance;\r\n            // already resolved\r\n            if (resolvedComp) {\r\n                return () => createInnerComp(resolvedComp, instance);\r\n            }\r\n            const onError = (err) => {\r\n                pendingRequest = null;\r\n                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\r\n            };\r\n            // suspense-controlled or SSR.\r\n            if ((suspensible && instance.suspense) ||\r\n                (false )) {\r\n                return load()\r\n                    .then(comp => {\r\n                    return () => createInnerComp(comp, instance);\r\n                })\r\n                    .catch(err => {\r\n                    onError(err);\r\n                    return () => errorComponent\r\n                        ? createVNode(errorComponent, {\r\n                            error: err\r\n                        })\r\n                        : null;\r\n                });\r\n            }\r\n            const loaded = reactivity_esm_bundler_ref(false);\r\n            const error = reactivity_esm_bundler_ref();\r\n            const delayed = reactivity_esm_bundler_ref(!!delay);\r\n            if (delay) {\r\n                setTimeout(() => {\r\n                    delayed.value = false;\r\n                }, delay);\r\n            }\r\n            if (timeout != null) {\r\n                setTimeout(() => {\r\n                    if (!loaded.value && !error.value) {\r\n                        const err = new Error(`Async component timed out after ${timeout}ms.`);\r\n                        onError(err);\r\n                        error.value = err;\r\n                    }\r\n                }, timeout);\r\n            }\r\n            load()\r\n                .then(() => {\r\n                loaded.value = true;\r\n            })\r\n                .catch(err => {\r\n                onError(err);\r\n                error.value = err;\r\n            });\r\n            return () => {\r\n                if (loaded.value && resolvedComp) {\r\n                    return createInnerComp(resolvedComp, instance);\r\n                }\r\n                else if (error.value && errorComponent) {\r\n                    return createVNode(errorComponent, {\r\n                        error: error.value\r\n                    });\r\n                }\r\n                else if (loadingComponent && !delayed.value) {\r\n                    return createVNode(loadingComponent);\r\n                }\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction createInnerComp(comp, { vnode: { ref, props, children } }) {\r\n    const vnode = createVNode(comp, props, children);\r\n    // ensure inner component inherits the async wrapper\'s ref owner\r\n    vnode.ref = ref;\r\n    return vnode;\r\n}\n\nconst prodEffectOptions = {\r\n    scheduler: queueJob,\r\n    // #1801, #2043 component render effects should allow recursive updates\r\n    allowRecurse: true\r\n};\r\nfunction createDevEffectOptions(instance) {\r\n    return {\r\n        scheduler: queueJob,\r\n        allowRecurse: true,\r\n        onTrack: instance.rtc ? e => Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.rtc, e) : void 0,\r\n        onTrigger: instance.rtg ? e => Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.rtg, e) : void 0\r\n    };\r\n}\r\nconst queuePostRenderEffect = queueEffectWithSuspense\r\n    ;\r\nconst setRef = (rawRef, oldRawRef, parentSuspense, vnode) => {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(rawRef)) {\r\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && (Object(shared_esm_bundler["o" /* isArray */])(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode));\r\n        return;\r\n    }\r\n    let value;\r\n    if (!vnode || isAsyncWrapper(vnode)) {\r\n        value = null;\r\n    }\r\n    else {\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            value = vnode.component.exposed || vnode.component.proxy;\r\n        }\r\n        else {\r\n            value = vnode.el;\r\n        }\r\n    }\r\n    const { i: owner, r: ref } = rawRef;\r\n    if (false) {}\r\n    const oldRef = oldRawRef && oldRawRef.r;\r\n    const refs = owner.refs === shared_esm_bundler["b" /* EMPTY_OBJ */] ? (owner.refs = {}) : owner.refs;\r\n    const setupState = owner.setupState;\r\n    // unset old ref\r\n    if (oldRef != null && oldRef !== ref) {\r\n        if (Object(shared_esm_bundler["C" /* isString */])(oldRef)) {\r\n            refs[oldRef] = null;\r\n            if (Object(shared_esm_bundler["l" /* hasOwn */])(setupState, oldRef)) {\r\n                setupState[oldRef] = null;\r\n            }\r\n        }\r\n        else if (isRef(oldRef)) {\r\n            oldRef.value = null;\r\n        }\r\n    }\r\n    if (Object(shared_esm_bundler["C" /* isString */])(ref)) {\r\n        const doSet = () => {\r\n            refs[ref] = value;\r\n            if (Object(shared_esm_bundler["l" /* hasOwn */])(setupState, ref)) {\r\n                setupState[ref] = value;\r\n            }\r\n        };\r\n        // #1789: for non-null values, set them after render\r\n        // null values means this is unmount and it should not overwrite another\r\n        // ref with the same key\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (isRef(ref)) {\r\n        const doSet = () => {\r\n            ref.value = value;\r\n        };\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(ref)) {\r\n        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);\r\n    }\r\n    else if ((false)) {}\r\n};\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nfunction createRenderer(options) {\r\n    return baseCreateRenderer(options);\r\n}\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nfunction createHydrationRenderer(options) {\r\n    return baseCreateRenderer(options, createHydrationFunctions);\r\n}\r\n// implementation\r\nfunction baseCreateRenderer(options, createHydrationFns) {\r\n    // compile-time feature flags check\r\n    {\r\n        initFeatureFlags();\r\n    }\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        const target = Object(shared_esm_bundler["j" /* getGlobalThis */])();\r\n        target.__VUE__ = true;\r\n        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    }\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = shared_esm_bundler["d" /* NOOP */], cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n    // Note: functions inside this closure should use `const xxx = () => {}`\r\n    // style in order to prevent being inlined by minifiers.\r\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {\r\n        // patching & not same type, unmount old tree\r\n        if (n1 && !isSameVNodeType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        if (n2.patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            n2.dynamicChildren = null;\r\n        }\r\n        const { type, ref, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case Static:\r\n                if (n1 == null) {\r\n                    mountStaticNode(n2, container, anchor, isSVG);\r\n                }\r\n                else if ((false)) {}\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\r\n                }\r\n                else if ((false)) {}\r\n        }\r\n        // set ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, n1 && n1.ref, parentSuspense, n2);\r\n        }\r\n    };\r\n    const processText = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    };\r\n    const processCommentNode = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || \'\')), container, anchor);\r\n        }\r\n        else {\r\n            // there\'s no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    };\r\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const patchStaticNode = (n1, n2, container, isSVG) => {\r\n        // static nodes are only patched during dev for HMR\r\n        if (n2.children !== n1.children) {\r\n            const anchor = hostNextSibling(n1.anchor);\r\n            // remove existing\r\n            removeStaticNode(n1);\r\n            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n        }\r\n        else {\r\n            n2.el = n1.el;\r\n            n2.anchor = n1.anchor;\r\n        }\r\n    };\r\n    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostInsert(el, container, nextSibling);\r\n            el = next;\r\n        }\r\n        hostInsert(anchor, container, nextSibling);\r\n    };\r\n    const removeStaticNode = ({ el, anchor }) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostRemove(el);\r\n            el = next;\r\n        }\r\n        hostRemove(anchor);\r\n    };\r\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        isSVG = isSVG || n2.type === \'svg\';\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n    };\r\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        let el;\r\n        let vnodeHook;\r\n        const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;\r\n        if ( true &&\r\n            vnode.el &&\r\n            hostCloneNode !== undefined &&\r\n            patchFlag === -1 /* HOISTED */) {\r\n            // If a vnode has non-null el, it means it\'s being reused.\r\n            // Only static vnodes can be reused, so its mounted DOM nodes should be\r\n            // exactly the same, and we can simply do a clone here.\r\n            // only do this in production since cloned trees cannot be HMR updated.\r\n            el = vnode.el = hostCloneNode(vnode.el);\r\n        }\r\n        else {\r\n            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);\r\n            // mount children first, since some props may rely on child content\r\n            // being already rendered, e.g. `<select value>`\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                hostSetElementText(el, vnode.children);\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== \'foreignObject\', optimized || !!vnode.dynamicChildren);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'created\');\r\n            }\r\n            // props\r\n            if (props) {\r\n                for (const key in props) {\r\n                    if (!Object(shared_esm_bundler["y" /* isReservedProp */])(key)) {\r\n                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n                if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                }\r\n            }\r\n            // scopeId\r\n            setScopeId(el, scopeId, vnode, parentComponent);\r\n        }\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            Object.defineProperty(el, \'__vnode\', {\r\n                value: vnode,\r\n                enumerable: false\r\n            });\r\n            Object.defineProperty(el, \'__vueParentComponent\', {\r\n                value: parentComponent,\r\n                enumerable: false\r\n            });\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(vnode, null, parentComponent, \'beforeMount\');\r\n        }\r\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n        // #1689 For inside suspense + suspense resolved case, just call it\r\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n            transition &&\r\n            !transition.persisted;\r\n        if (needCallTransitionHooks) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if ((vnodeHook = props && props.onVnodeMounted) ||\r\n            needCallTransitionHooks ||\r\n            dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                needCallTransitionHooks && transition.enter(el);\r\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, \'mounted\');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const setScopeId = (el, scopeId, vnode, parentComponent) => {\r\n        if (scopeId) {\r\n            hostSetScopeId(el, scopeId);\r\n        }\r\n        if (parentComponent) {\r\n            const treeOwnerId = parentComponent.type.__scopeId;\r\n            // vnode\'s own scopeId and the current patched component\'s scopeId is\r\n            // different - this is a slot content node.\r\n            if (treeOwnerId && treeOwnerId !== scopeId) {\r\n                hostSetScopeId(el, treeOwnerId + \'-s\');\r\n            }\r\n            let subTree = parentComponent.subTree;\r\n            if (false) {}\r\n            if (vnode === subTree) {\r\n                setScopeId(el, parentComponent.vnode.scopeId, parentComponent.vnode, parentComponent.parent);\r\n            }\r\n        }\r\n    };\r\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = optimized\r\n                ? cloneIfMounted(children[i])\r\n                : normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n    };\r\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const el = (n2.el = n1.el);\r\n        let { patchFlag, dynamicChildren, dirs } = n2;\r\n        // #1426 take the old vnode\'s patch flag into account since user may clone a\r\n        // compiler-generated vnode, which de-opts to FULL_PROPS\r\n        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n        const oldProps = n1.props || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        const newProps = n2.props || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        let vnodeHook;\r\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(n2, n1, parentComponent, \'beforeUpdate\');\r\n        }\r\n        if (false) {}\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element\'s render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, \'class\', null, newProps.class, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, \'style\', oldProps.style, newProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]="bar" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        if (next !== prev ||\r\n                            (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n            }\r\n        }\r\n        else if (!optimized && dynamicChildren == null) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        const areChildrenSVG = isSVG && n2.type !== \'foreignObject\';\r\n        if (dynamicChildren) {\r\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);\r\n            if (false) {}\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);\r\n        }\r\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, \'updated\');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    // The fast path for blocks.\r\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const oldVNode = oldChildren[i];\r\n            const newVNode = newChildren[i];\r\n            // Determine the container (parent element) for the patch.\r\n            const container = \r\n            // - In the case of a Fragment, we need to provide the actual parent\r\n            // of the Fragment itself so it can move its children.\r\n            oldVNode.type === Fragment ||\r\n                // - In the case of different nodes, there is going to be a replacement\r\n                // which also requires the correct parent container\r\n                !isSameVNodeType(oldVNode, newVNode) ||\r\n                // - In the case of a component, it could contain anything.\r\n                oldVNode.shapeFlag & 6 /* COMPONENT */ ||\r\n                oldVNode.shapeFlag & 64 /* TELEPORT */\r\n                ? hostParentNode(oldVNode.el)\r\n                : // In other cases, the parent container is not actually used so we\r\n                    // just pass the block element here to avoid a DOM parentNode call.\r\n                    fallbackContainer;\r\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);\r\n        }\r\n    };\r\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                // empty string is not valid prop\r\n                if (Object(shared_esm_bundler["y" /* isReservedProp */])(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                if (next !== prev ||\r\n                    (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n                for (const key in oldProps) {\r\n                    if (!Object(shared_esm_bundler["y" /* isReservedProp */])(key) && !(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(\'\'));\r\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(\'\'));\r\n        let { patchFlag, dynamicChildren } = n2;\r\n        if (patchFlag > 0) {\r\n            optimized = true;\r\n        }\r\n        if (false) {}\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        else {\r\n            if (patchFlag > 0 &&\r\n                patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                dynamicChildren &&\r\n                // #2715 the previous fragment could\'ve been a BAILed one as a result\r\n                // of renderSlot() with no valid children\r\n                n1.dynamicChildren) {\r\n                // a stable fragment (template root or <template v-for>) doesn\'t need to\r\n                // patch children order, but it may contain dynamicChildren.\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);\r\n                if (false) {}\r\n                else if (\r\n                // #2080 if the stable fragment has a key, it\'s a <template v-for> that may\r\n                //  get moved around. Make sure all root level vnodes inherit el.\r\n                // #2134 or if it\'s a component root, it may also get moved around\r\n                // as the component is being moved.\r\n                n2.key != null ||\r\n                    (parentComponent && n2 === parentComponent.subTree)) {\r\n                    traverseStaticChildren(n1, n2, true /* shallow */);\r\n                }\r\n            }\r\n            else {\r\n                // keyed / unkeyed, or manual fragments.\r\n                // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                // each child is guaranteed to be a block so the fragment will never\r\n                // have dynamicChildren.\r\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n    };\r\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        if (n1 == null) {\r\n            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n            }\r\n            else {\r\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n        else {\r\n            updateComponent(n1, n2, optimized);\r\n        }\r\n    };\r\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n        if (false) {}\r\n        if ((false)) {}\r\n        // inject renderer internals for keepAlive\r\n        if (isKeepAlive(initialVNode)) {\r\n            instance.ctx.renderer = internals;\r\n        }\r\n        // resolve props and slots for setup context\r\n        if ((false)) {}\r\n        setupComponent(instance);\r\n        if ((false)) {}\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if (instance.asyncDep) {\r\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n            // Give it a placeholder if this is not hydration\r\n            // TODO handle self-defined fallback\r\n            if (!initialVNode.el) {\r\n                const placeholder = (instance.subTree = createVNode(Comment));\r\n                processCommentNode(null, placeholder, container, anchor);\r\n            }\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n        if ((false)) {}\r\n    };\r\n    const updateComponent = (n1, n2, optimized) => {\r\n        const instance = (n2.component = n1.component);\r\n        if (shouldUpdateComponent(n1, n2, optimized)) {\r\n            if (instance.asyncDep &&\r\n                !instance.asyncResolved) {\r\n                // async & still pending - just update props and slots\r\n                // since the component\'s reactive effect for render isn\'t set-up yet\r\n                if ((false)) {}\r\n                updateComponentPreRender(instance, n2, optimized);\r\n                if ((false)) {}\r\n                return;\r\n            }\r\n            else {\r\n                // normal update\r\n                instance.next = n2;\r\n                // in case the child component is also queued, remove it to avoid\r\n                // double updating the same child component in the same flush.\r\n                invalidateJob(instance.update);\r\n                // instance.update is the reactive effect runner.\r\n                instance.update();\r\n            }\r\n        }\r\n        else {\r\n            // no update needed. just copy over properties\r\n            n2.component = n1.component;\r\n            n2.el = n1.el;\r\n            instance.vnode = n2;\r\n        }\r\n    };\r\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n        // create reactive effect for rendering\r\n        instance.update = reactivity_esm_bundler_effect(function componentEffect() {\r\n            if (!instance.isMounted) {\r\n                let vnodeHook;\r\n                const { el, props } = initialVNode;\r\n                const { bm, m, parent } = instance;\r\n                // beforeMount hook\r\n                if (bm) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(bm);\r\n                }\r\n                // onVnodeBeforeMount\r\n                if ((vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                }\r\n                // render\r\n                if ((false)) {}\r\n                const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                if ((false)) {}\r\n                if (el && hydrateNode) {\r\n                    if ((false)) {}\r\n                    // vnode has adopted host node - perform hydration instead of mount.\r\n                    hydrateNode(initialVNode.el, subTree, instance, parentSuspense);\r\n                    if ((false)) {}\r\n                }\r\n                else {\r\n                    if ((false)) {}\r\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                    if ((false)) {}\r\n                    initialVNode.el = subTree.el;\r\n                }\r\n                // mounted hook\r\n                if (m) {\r\n                    queuePostRenderEffect(m, parentSuspense);\r\n                }\r\n                // onVnodeMounted\r\n                if ((vnodeHook = props && props.onVnodeMounted)) {\r\n                    const scopedInitialVNode = initialVNode;\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);\r\n                    }, parentSuspense);\r\n                }\r\n                // activated hook for keep-alive roots.\r\n                // #1742 activated hook must be accessed after first render\r\n                // since the hook may be injected by a child keep-alive\r\n                const { a } = instance;\r\n                if (a &&\r\n                    initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n                    queuePostRenderEffect(a, parentSuspense);\r\n                }\r\n                instance.isMounted = true;\r\n                if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentAdded(instance);\r\n                }\r\n                // #2458: deference mount-only object parameters to prevent memleaks\r\n                initialVNode = container = anchor = null;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component\'s own state (next: null)\r\n                // OR parent calling processComponent (next: VNode)\r\n                let { next, bu, u, parent, vnode } = instance;\r\n                let originNext = next;\r\n                let vnodeHook;\r\n                if ((false)) {}\r\n                if (next) {\r\n                    next.el = vnode.el;\r\n                    updateComponentPreRender(instance, next, optimized);\r\n                }\r\n                else {\r\n                    next = vnode;\r\n                }\r\n                // beforeUpdate hook\r\n                if (bu) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(bu);\r\n                }\r\n                // onVnodeBeforeUpdate\r\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                }\r\n                // render\r\n                if ((false)) {}\r\n                const nextTree = renderComponentRoot(instance);\r\n                if ((false)) {}\r\n                const prevTree = instance.subTree;\r\n                instance.subTree = nextTree;\r\n                if ((false)) {}\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it\'s in a teleport\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it\'s in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                if ((false)) {}\r\n                next.el = nextTree.el;\r\n                if (originNext === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance\'s subTree pointing\r\n                    // to child component\'s vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (u) {\r\n                    queuePostRenderEffect(u, parentSuspense);\r\n                }\r\n                // onVnodeUpdated\r\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                    }, parentSuspense);\r\n                }\r\n                if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentUpdated(instance);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n        }, ( false) ? undefined : prodEffectOptions);\r\n    };\r\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n        nextVNode.component = instance;\r\n        const prevProps = instance.vnode.props;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        updateProps(instance, nextVNode.props, prevProps, optimized);\r\n        updateSlots(instance, nextVNode.children);\r\n        // props update may have triggered pre-flush watchers.\r\n        // flush them before the render update.\r\n        flushPreFlushCbs(undefined, instance.update);\r\n    };\r\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, \'\');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        c1 = c1 || shared_esm_bundler["a" /* EMPTY_ARR */];\r\n        c2 = c2 || shared_esm_bundler["a" /* EMPTY_ARR */];\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);\r\n        }\r\n    };\r\n    // can be all-keyed or mixed\r\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = optimized\r\n                ? cloneIfMounted(c2[e2])\r\n                : normalizeVNode(c2[e2]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = optimized\r\n                        ? cloneIfMounted(c2[i])\r\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = optimized\r\n                    ? cloneIfMounted(c2[i])\r\n                    : normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    if (false) {}\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = new Array(toBePatched);\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap[i] = 0;\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameVNodeType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : shared_esm_bundler["a" /* EMPTY_ARR */];\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor, 2 /* REORDER */);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n        const { el, type, transition, children, shapeFlag } = vnode;\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            move(vnode.component.subTree, container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            vnode.suspense.move(container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type.move(vnode, container, anchor, internals);\r\n            return;\r\n        }\r\n        if (type === Fragment) {\r\n            hostInsert(el, container, anchor);\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor, moveType);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            moveStaticNode(vnode, container, anchor);\r\n            return;\r\n        }\r\n        // single nodes\r\n        const needTransition = moveType !== 2 /* REORDER */ &&\r\n            shapeFlag & 1 /* ELEMENT */ &&\r\n            transition;\r\n        if (needTransition) {\r\n            if (moveType === 0 /* ENTER */) {\r\n                transition.beforeEnter(el);\r\n                hostInsert(el, container, anchor);\r\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n            }\r\n            else {\r\n                const { leave, delayLeave, afterLeave } = transition;\r\n                const remove = () => hostInsert(el, container, anchor);\r\n                const performLeave = () => {\r\n                    leave(el, () => {\r\n                        remove();\r\n                        afterLeave && afterLeave();\r\n                    });\r\n                };\r\n                if (delayLeave) {\r\n                    delayLeave(el, remove, performLeave);\r\n                }\r\n                else {\r\n                    performLeave();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hostInsert(el, container, anchor);\r\n        }\r\n    };\r\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n        // unset ref\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, null);\r\n        }\r\n        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n            parentComponent.ctx.deactivate(vnode);\r\n            return;\r\n        }\r\n        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n        let vnodeHook;\r\n        if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n        }\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            unmountComponent(vnode.component, parentSuspense, doRemove);\r\n        }\r\n        else {\r\n            if (shapeFlag & 128 /* SUSPENSE */) {\r\n                vnode.suspense.unmount(parentSuspense, doRemove);\r\n                return;\r\n            }\r\n            if (shouldInvokeDirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'beforeUnmount\');\r\n            }\r\n            if (dynamicChildren &&\r\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                (type !== Fragment ||\r\n                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                // fast path for block nodes: only need to unmount dynamic children.\r\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n            }\r\n            else if ((type === Fragment &&\r\n                (patchFlag & 128 /* KEYED_FRAGMENT */ ||\r\n                    patchFlag & 256 /* UNKEYED_FRAGMENT */)) ||\r\n                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\r\n                unmountChildren(children, parentComponent, parentSuspense);\r\n            }\r\n            // an unmounted teleport should always remove its children if not disabled\r\n            if (shapeFlag & 64 /* TELEPORT */ &&\r\n                (doRemove || !isTeleportDisabled(vnode.props))) {\r\n                vnode.type.remove(vnode, internals);\r\n            }\r\n            if (doRemove) {\r\n                remove(vnode);\r\n            }\r\n        }\r\n        if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                shouldInvokeDirs &&\r\n                    invokeDirectiveHook(vnode, null, parentComponent, \'unmounted\');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const remove = vnode => {\r\n        const { type, el, anchor, transition } = vnode;\r\n        if (type === Fragment) {\r\n            removeFragment(el, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            removeStaticNode(vnode);\r\n            return;\r\n        }\r\n        const performRemove = () => {\r\n            hostRemove(el);\r\n            if (transition && !transition.persisted && transition.afterLeave) {\r\n                transition.afterLeave();\r\n            }\r\n        };\r\n        if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n            transition &&\r\n            !transition.persisted) {\r\n            const { leave, delayLeave } = transition;\r\n            const performLeave = () => leave(el, performRemove);\r\n            if (delayLeave) {\r\n                delayLeave(vnode.el, performRemove, performLeave);\r\n            }\r\n            else {\r\n                performLeave();\r\n            }\r\n        }\r\n        else {\r\n            performRemove();\r\n        }\r\n    };\r\n    const removeFragment = (cur, end) => {\r\n        // For fragments, directly remove all contained DOM nodes.\r\n        // (fragment child nodes cannot have transition)\r\n        let next;\r\n        while (cur !== end) {\r\n            next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(end);\r\n    };\r\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n        if (false) {}\r\n        const { bum, effects, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum) {\r\n            Object(shared_esm_bundler["n" /* invokeArrayFns */])(bum);\r\n        }\r\n        if (effects) {\r\n            for (let i = 0; i < effects.length; i++) {\r\n                stop(effects[i]);\r\n            }\r\n        }\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update) {\r\n            stop(update);\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        queuePostRenderEffect(() => {\r\n            instance.isUnmounted = true;\r\n        }, parentSuspense);\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (parentSuspense &&\r\n            parentSuspense.pendingBranch &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep &&\r\n            !instance.asyncResolved &&\r\n            instance.suspenseId === parentSuspense.pendingId) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                parentSuspense.resolve();\r\n            }\r\n        }\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            devtoolsComponentRemoved(instance);\r\n        }\r\n    };\r\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n        }\r\n    };\r\n    const getNextHostNode = vnode => {\r\n        if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n            return getNextHostNode(vnode.component.subTree);\r\n        }\r\n        if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n            return vnode.suspense.next();\r\n        }\r\n        return hostNextSibling((vnode.anchor || vnode.el));\r\n    };\r\n    const render = (vnode, container) => {\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    };\r\n    const internals = {\r\n        p: patch,\r\n        um: unmount,\r\n        m: move,\r\n        r: remove,\r\n        mt: mountComponent,\r\n        mc: mountChildren,\r\n        pc: patchChildren,\r\n        pbc: patchBlockChildren,\r\n        n: getNextHostNode,\r\n        o: options\r\n    };\r\n    let hydrate;\r\n    let hydrateNode;\r\n    if (createHydrationFns) {\r\n        [hydrate, hydrateNode] = createHydrationFns(internals);\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n        createApp: createAppAPI(render, hydrate)\r\n    };\r\n}\r\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n        vnode,\r\n        prevVNode\r\n    ]);\r\n}\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always moved so that need inherit el form previous nodes\r\n * to ensure correct moved position.\r\n */\r\nfunction traverseStaticChildren(n1, n2, shallow = false) {\r\n    const ch1 = n1.children;\r\n    const ch2 = n2.children;\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(ch1) && Object(shared_esm_bundler["o" /* isArray */])(ch2)) {\r\n        for (let i = 0; i < ch1.length; i++) {\r\n            // this is only called in the optimized path so array children are\r\n            // guaranteed to be vnodes\r\n            const c1 = ch1[i];\r\n            let c2 = ch2[i];\r\n            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                    c2.el = c1.el;\r\n                }\r\n                if (!shallow)\r\n                    traverseStaticChildren(c1, c2);\r\n            }\r\n            // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n            // would have received .el during block patch)\r\n            if (false) {}\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = ((u + v) / 2) | 0;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === \'\');\r\nconst isTargetSVG = (target) => typeof SVGElement !== \'undefined\' && target instanceof SVGElement;\r\nconst resolveTarget = (props, select) => {\r\n    const targetSelector = props && props.to;\r\n    if (Object(shared_esm_bundler["C" /* isString */])(targetSelector)) {\r\n        if (!select) {\r\n            ( false) &&\r\n                false;\r\n            return null;\r\n        }\r\n        else {\r\n            const target = select(targetSelector);\r\n            if (!target) {\r\n                ( false) &&\r\n                    false;\r\n            }\r\n            return target;\r\n        }\r\n    }\r\n    else {\r\n        if (false) {}\r\n        return targetSelector;\r\n    }\r\n};\r\nconst TeleportImpl = {\r\n    __isTeleport: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {\r\n        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\r\n        const disabled = isTeleportDisabled(n2.props);\r\n        const { shapeFlag, children } = n2;\r\n        if (n1 == null) {\r\n            // insert anchors in the main view\r\n            const placeholder = (n2.el = ( false)\r\n                ? undefined\r\n                : createText(\'\'));\r\n            const mainAnchor = (n2.anchor = ( false)\r\n                ? undefined\r\n                : createText(\'\'));\r\n            insert(placeholder, container, anchor);\r\n            insert(mainAnchor, container, anchor);\r\n            const target = (n2.target = resolveTarget(n2.props, querySelector));\r\n            const targetAnchor = (n2.targetAnchor = createText(\'\'));\r\n            if (target) {\r\n                insert(targetAnchor, target);\r\n                // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n                isSVG = isSVG || isTargetSVG(target);\r\n            }\r\n            else if (false) {}\r\n            const mount = (container, anchor) => {\r\n                // Teleport *always* has Array children. This is enforced in both the\r\n                // compiler and vnode children normalization.\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n            };\r\n            if (disabled) {\r\n                mount(container, mainAnchor);\r\n            }\r\n            else if (target) {\r\n                mount(target, targetAnchor);\r\n            }\r\n        }\r\n        else {\r\n            // update content\r\n            n2.el = n1.el;\r\n            const mainAnchor = (n2.anchor = n1.anchor);\r\n            const target = (n2.target = n1.target);\r\n            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\r\n            const wasDisabled = isTeleportDisabled(n1.props);\r\n            const currentContainer = wasDisabled ? container : target;\r\n            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\r\n            isSVG = isSVG || isTargetSVG(target);\r\n            if (n2.dynamicChildren) {\r\n                // fast path when the teleport happens to be a block root\r\n                patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG);\r\n                // even in block tree mode we need to make sure all root-level nodes\r\n                // in the teleport inherit previous DOM references so that they can\r\n                // be moved in future patches.\r\n                traverseStaticChildren(n1, n2, true);\r\n            }\r\n            else if (!optimized) {\r\n                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            if (disabled) {\r\n                if (!wasDisabled) {\r\n                    // enabled -> disabled\r\n                    // move into main container\r\n                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n            else {\r\n                // target changed\r\n                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\r\n                    if (nextTarget) {\r\n                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\r\n                    }\r\n                    else if ((false)) {}\r\n                }\r\n                else if (wasDisabled) {\r\n                    // disabled -> enabled\r\n                    // move into teleport target\r\n                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    remove(vnode, { r: remove, o: { remove: hostRemove } }) {\r\n        const { shapeFlag, children, anchor } = vnode;\r\n        hostRemove(anchor);\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                remove(children[i]);\r\n            }\r\n        }\r\n    },\r\n    move: moveTeleport,\r\n    hydrate: hydrateTeleport\r\n};\r\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\r\n    // move target anchor if this is a target change.\r\n    if (moveType === 0 /* TARGET_CHANGE */) {\r\n        insert(vnode.targetAnchor, container, parentAnchor);\r\n    }\r\n    const { el, anchor, shapeFlag, children, props } = vnode;\r\n    const isReorder = moveType === 2 /* REORDER */;\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(el, container, parentAnchor);\r\n    }\r\n    // if this is a re-order and teleport is enabled (content is in target)\r\n    // do not move children. So the opposite is: only move children if this\r\n    // is not a reorder, or the teleport is disabled\r\n    if (!isReorder || isTeleportDisabled(props)) {\r\n        // Teleport has either Array children or no children.\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, parentAnchor, 2 /* REORDER */);\r\n            }\r\n        }\r\n    }\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(anchor, container, parentAnchor);\r\n    }\r\n}\r\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\r\n    const target = (vnode.target = resolveTarget(vnode.props, querySelector));\r\n    if (target) {\r\n        // if multiple teleports rendered to the same target element, we need to\r\n        // pick up from where the last teleport finished instead of the first node\r\n        const targetNode = target._lpa || target.firstChild;\r\n        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            if (isTeleportDisabled(vnode.props)) {\r\n                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);\r\n                vnode.targetAnchor = targetNode;\r\n            }\r\n            else {\r\n                vnode.anchor = nextSibling(node);\r\n                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);\r\n            }\r\n            target._lpa =\r\n                vnode.targetAnchor && nextSibling(vnode.targetAnchor);\r\n        }\r\n    }\r\n    return vnode.anchor && nextSibling(vnode.anchor);\r\n}\r\n// Force-casted public typing for h and TSX props inference\r\nconst Teleport = TeleportImpl;\n\nconst COMPONENTS = \'components\';\r\nconst DIRECTIVES = \'directives\';\r\n/**\r\n * @private\r\n */\r\nfunction resolveComponent(name) {\r\n    return resolveAsset(COMPONENTS, name) || name;\r\n}\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n/**\r\n * @private\r\n */\r\nfunction resolveDynamicComponent(component) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(component)) {\r\n        return resolveAsset(COMPONENTS, component, false) || component;\r\n    }\r\n    else {\r\n        // invalid types will fallthrough to createVNode and raise warning\r\n        return (component || NULL_DYNAMIC_COMPONENT);\r\n    }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction resolveDirective(name) {\r\n    return resolveAsset(DIRECTIVES, name);\r\n}\r\n// implementation\r\nfunction resolveAsset(type, name, warnMissing = true) {\r\n    const instance = currentRenderingInstance || currentInstance;\r\n    if (instance) {\r\n        const Component = instance.type;\r\n        // self name has highest priority\r\n        if (type === COMPONENTS) {\r\n            // special self referencing call generated by compiler\r\n            // inferred from SFC filename\r\n            if (name === `_self`) {\r\n                return Component;\r\n            }\r\n            const selfName = getComponentName(Component);\r\n            if (selfName &&\r\n                (selfName === name ||\r\n                    selfName === Object(shared_esm_bundler["f" /* camelize */])(name) ||\r\n                    selfName === Object(shared_esm_bundler["g" /* capitalize */])(Object(shared_esm_bundler["f" /* camelize */])(name)))) {\r\n                return Component;\r\n            }\r\n        }\r\n        const res = \r\n        // local registration\r\n        // check instance[type] first for components with mixin or extends.\r\n        resolve(instance[type] || Component[type], name) ||\r\n            // global registration\r\n            resolve(instance.appContext[type], name);\r\n        if (false) {}\r\n        return res;\r\n    }\r\n    else if ((false)) {}\r\n}\r\nfunction resolve(registry, name) {\r\n    return (registry &&\r\n        (registry[name] ||\r\n            registry[Object(shared_esm_bundler["f" /* camelize */])(name)] ||\r\n            registry[Object(shared_esm_bundler["g" /* capitalize */])(Object(shared_esm_bundler["f" /* camelize */])(name))]));\r\n}\n\nconst Fragment = Symbol(( false) ? undefined : undefined);\r\nconst Text = Symbol(( false) ? undefined : undefined);\r\nconst Comment = Symbol(( false) ? undefined : undefined);\r\nconst Static = Symbol(( false) ? undefined : undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock(\'div\', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet runtime_core_esm_bundler_shouldTrack = 1;\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nfunction setBlockTracking(value) {\r\n    runtime_core_esm_bundler_shouldTrack += value;\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren = currentBlock || shared_esm_bundler["a" /* EMPTY_ARR */];\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if (runtime_core_esm_bundler_shouldTrack > 0 && currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nfunction isSameVNodeType(n1, n2) {\r\n    if (false) {}\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}\r\nlet vnodeArgsTransformer;\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nfunction transformVNodeArgs(transformer) {\r\n    vnodeArgsTransformer = transformer;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? Object(shared_esm_bundler["C" /* isString */])(ref) || isRef(ref) || Object(shared_esm_bundler["p" /* isFunction */])(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = (( false)\r\n    ? undefined\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if (false) {}\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is="vnode"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = Object(shared_esm_bundler["i" /* extend */])({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !Object(shared_esm_bundler["C" /* isString */])(klass)) {\r\n            props.class = Object(shared_esm_bundler["I" /* normalizeClass */])(klass);\r\n        }\r\n        if (Object(shared_esm_bundler["v" /* isObject */])(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !Object(shared_esm_bundler["o" /* isArray */])(style)) {\r\n                style = Object(shared_esm_bundler["i" /* extend */])({}, style);\r\n            }\r\n            props.style = Object(shared_esm_bundler["J" /* normalizeStyle */])(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = Object(shared_esm_bundler["C" /* isString */])(type)\r\n        ? 1 /* ELEMENT */\r\n        : isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : Object(shared_esm_bundler["v" /* isObject */])(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : Object(shared_esm_bundler["p" /* isFunction */])(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if (false) {}\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        ["__v_skip" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if (false) {}\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if (shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (runtime_core_esm_bundler_shouldTrack > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn\'t need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag, children } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        ["__v_skip" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is="vnode" ref="extra"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? Object(shared_esm_bundler["o" /* isArray */])(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children:  false\r\n            ? undefined\r\n            : children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn\'t affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * Dev only, for HMR of hoisted vnodes reused in v-for\r\n * https://github.com/vitejs/vite/issues/2022\r\n */\r\nfunction deepCloneVNode(vnode) {\r\n    const cloned = cloneVNode(vnode);\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(vnode.children)) {\r\n        cloned.children = vnode.children.map(deepCloneVNode);\r\n    }\r\n    return cloned;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = \' \', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createStaticVNode(content, numberOfNodes) {\r\n    // A static vnode can contain multiple stringified elements, and the number\r\n    // of elements is necessary for hydration.\r\n    const vnode = createVNode(Static, null, content);\r\n    vnode.staticCount = numberOfNodes;\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createCommentVNode(text = \'\', \r\n// when used as the v-else branch, the comment node must be created as a\r\n// block to ensure correct updates.\r\nasBlock = false) {\r\n    return asBlock\r\n        ? (openBlock(), createBlock(Comment, null, text))\r\n        : createVNode(Comment, null, text);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === \'boolean\') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === \'object\') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\n// optimized normalization for template-compiled render fns\r\nfunction cloneIfMounted(child) {\r\n    return child.el === null ? child : cloneVNode(child);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === \'object\') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent\'s slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = Object(shared_esm_bundler["i" /* extend */])({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === \'class\') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = Object(shared_esm_bundler["I" /* normalizeClass */])([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === \'style\') {\r\n                ret.style = Object(shared_esm_bundler["J" /* normalizeStyle */])([ret.style, toMerge.style]);\r\n            }\r\n            else if (Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== \'\') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if ((false)) {}\r\n    }\r\n    else {\r\n        let provides = currentInstance.provides;\r\n        // by default an instance inherits its parent\'s provides object\r\n        // but when it needs to provide values of its own, it creates its\r\n        // own provides object using parent provides object as prototype.\r\n        // this way in `inject` we can simply look up injections from direct\r\n        // parent and let the prototype chain do the work.\r\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n        if (parentProvides === provides) {\r\n            provides = currentInstance.provides = Object.create(parentProvides);\r\n        }\r\n        // TS doesn\'t allow symbol as index type\r\n        provides[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance || currentRenderingInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext\'s `provides` if the intance is at root\r\n        const provides = instance.parent == null\r\n            ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n            : instance.parent.provides;\r\n        if (provides && key in provides) {\r\n            // TS doesn\'t allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && Object(shared_esm_bundler["p" /* isFunction */])(defaultValue)\r\n                ? defaultValue()\r\n                : defaultValue;\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    else if ((false)) {}\r\n}\n\nfunction createDuplicateChecker() {\r\n    const cache = Object.create(null);\r\n    return (type, key) => {\r\n        if (cache[key]) {\r\n            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);\r\n        }\r\n        else {\r\n            cache[key] = type;\r\n        }\r\n    };\r\n}\r\nlet isInBeforeCreate = false;\r\nfunction applyOptions(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {\r\n    const { \r\n    // composition\r\n    mixins, extends: extendsOptions, \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // assets\r\n    components, directives, \r\n    // lifecycle\r\n    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, \r\n    // public API\r\n    expose } = options;\r\n    const publicThis = instance.proxy;\r\n    const ctx = instance.ctx;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (asMixin && render && instance.render === shared_esm_bundler["d" /* NOOP */]) {\r\n        instance.render = render;\r\n    }\r\n    // applyOptions is called non-as-mixin once per instance\r\n    if (!asMixin) {\r\n        isInBeforeCreate = true;\r\n        callSyncHook(\'beforeCreate\', "bc" /* BEFORE_CREATE */, options, instance, globalMixins);\r\n        isInBeforeCreate = false;\r\n        // global mixins are applied first\r\n        applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    // extending a base component...\r\n    if (extendsOptions) {\r\n        applyOptions(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n    // local mixins\r\n    if (mixins) {\r\n        applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    const checkDuplicateProperties = ( false) ? undefined : null;\r\n    if ((false)) {}\r\n    // options initialization order (to be consistent with Vue 2):\r\n    // - props (already done outside of this function)\r\n    // - inject\r\n    // - methods\r\n    // - data (deferred since it relies on `this` access)\r\n    // - computed\r\n    // - watch (deferred since it relies on `this` access)\r\n    if (injectOptions) {\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(injectOptions)) {\r\n            for (let i = 0; i < injectOptions.length; i++) {\r\n                const key = injectOptions[i];\r\n                ctx[key] = inject(key);\r\n                if ((false)) {}\r\n            }\r\n        }\r\n        else {\r\n            for (const key in injectOptions) {\r\n                const opt = injectOptions[key];\r\n                if (Object(shared_esm_bundler["v" /* isObject */])(opt)) {\r\n                    ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n                }\r\n                else {\r\n                    ctx[key] = inject(opt);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n        }\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            const methodHandler = methods[key];\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(methodHandler)) {\r\n                // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,\r\n                // and those are read-only but reconfigurable, so it needs to be redefined here\r\n                if ((false)) {}\r\n                else {\r\n                    ctx[key] = methodHandler.bind(publicThis);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n            else if ((false)) {}\r\n        }\r\n    }\r\n    if (!asMixin) {\r\n        if (deferredData.length) {\r\n            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));\r\n        }\r\n        if (dataOptions) {\r\n            // @ts-ignore dataOptions is not fully type safe\r\n            resolveData(instance, dataOptions, publicThis);\r\n        }\r\n        if ((false)) {}\r\n    }\r\n    else if (dataOptions) {\r\n        deferredData.push(dataOptions);\r\n    }\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            const get = Object(shared_esm_bundler["p" /* isFunction */])(opt)\r\n                ? opt.bind(publicThis, publicThis)\r\n                : Object(shared_esm_bundler["p" /* isFunction */])(opt.get)\r\n                    ? opt.get.bind(publicThis, publicThis)\r\n                    : shared_esm_bundler["d" /* NOOP */];\r\n            if (false) {}\r\n            const set = !Object(shared_esm_bundler["p" /* isFunction */])(opt) && Object(shared_esm_bundler["p" /* isFunction */])(opt.set)\r\n                ? opt.set.bind(publicThis)\r\n                : ( false)\r\n                    ? undefined\r\n                    : shared_esm_bundler["d" /* NOOP */];\r\n            const c = runtime_core_esm_bundler_computed({\r\n                get,\r\n                set\r\n            });\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => c.value,\r\n                set: v => (c.value = v)\r\n            });\r\n            if ((false)) {}\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        deferredWatch.push(watchOptions);\r\n    }\r\n    if (!asMixin && deferredWatch.length) {\r\n        deferredWatch.forEach(watchOptions => {\r\n            for (const key in watchOptions) {\r\n                createWatcher(watchOptions[key], ctx, publicThis, key);\r\n            }\r\n        });\r\n    }\r\n    if (provideOptions) {\r\n        deferredProvide.push(provideOptions);\r\n    }\r\n    if (!asMixin && deferredProvide.length) {\r\n        deferredProvide.forEach(provideOptions => {\r\n            const provides = Object(shared_esm_bundler["p" /* isFunction */])(provideOptions)\r\n                ? provideOptions.call(publicThis)\r\n                : provideOptions;\r\n            Reflect.ownKeys(provides).forEach(key => {\r\n                provide(key, provides[key]);\r\n            });\r\n        });\r\n    }\r\n    // asset options.\r\n    // To reduce memory usage, only components with mixins or extends will have\r\n    // resolved asset registry attached to instance.\r\n    if (asMixin) {\r\n        if (components) {\r\n            Object(shared_esm_bundler["i" /* extend */])(instance.components ||\r\n                (instance.components = Object(shared_esm_bundler["i" /* extend */])({}, instance.type.components)), components);\r\n        }\r\n        if (directives) {\r\n            Object(shared_esm_bundler["i" /* extend */])(instance.directives ||\r\n                (instance.directives = Object(shared_esm_bundler["i" /* extend */])({}, instance.type.directives)), directives);\r\n        }\r\n    }\r\n    // lifecycle options\r\n    if (!asMixin) {\r\n        callSyncHook(\'created\', "c" /* CREATED */, options, instance, globalMixins);\r\n    }\r\n    if (beforeMount) {\r\n        onBeforeMount(beforeMount.bind(publicThis));\r\n    }\r\n    if (mounted) {\r\n        onMounted(mounted.bind(publicThis));\r\n    }\r\n    if (beforeUpdate) {\r\n        onBeforeUpdate(beforeUpdate.bind(publicThis));\r\n    }\r\n    if (updated) {\r\n        onUpdated(updated.bind(publicThis));\r\n    }\r\n    if (activated) {\r\n        onActivated(activated.bind(publicThis));\r\n    }\r\n    if (deactivated) {\r\n        onDeactivated(deactivated.bind(publicThis));\r\n    }\r\n    if (errorCaptured) {\r\n        onErrorCaptured(errorCaptured.bind(publicThis));\r\n    }\r\n    if (renderTracked) {\r\n        onRenderTracked(renderTracked.bind(publicThis));\r\n    }\r\n    if (renderTriggered) {\r\n        onRenderTriggered(renderTriggered.bind(publicThis));\r\n    }\r\n    if (false) {}\r\n    if (beforeUnmount) {\r\n        onBeforeUnmount(beforeUnmount.bind(publicThis));\r\n    }\r\n    if (false) {}\r\n    if (unmounted) {\r\n        onUnmounted(unmounted.bind(publicThis));\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(expose)) {\r\n        if (!asMixin) {\r\n            if (expose.length) {\r\n                const exposed = instance.exposed || (instance.exposed = proxyRefs({}));\r\n                expose.forEach(key => {\r\n                    exposed[key] = toRef(publicThis, key);\r\n                });\r\n            }\r\n            else if (!instance.exposed) {\r\n                instance.exposed = shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n            }\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n}\r\nfunction callSyncHook(name, type, options, instance, globalMixins) {\r\n    callHookFromMixins(name, type, globalMixins, instance);\r\n    const { extends: base, mixins } = options;\r\n    if (base) {\r\n        callHookFromExtends(name, type, base, instance);\r\n    }\r\n    if (mixins) {\r\n        callHookFromMixins(name, type, mixins, instance);\r\n    }\r\n    const selfHook = options[name];\r\n    if (selfHook) {\r\n        callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction callHookFromExtends(name, type, base, instance) {\r\n    if (base.extends) {\r\n        callHookFromExtends(name, type, base.extends, instance);\r\n    }\r\n    const baseHook = base[name];\r\n    if (baseHook) {\r\n        callWithAsyncErrorHandling(baseHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction callHookFromMixins(name, type, mixins, instance) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        const chainedMixins = mixins[i].mixins;\r\n        if (chainedMixins) {\r\n            callHookFromMixins(name, type, chainedMixins, instance);\r\n        }\r\n        const fn = mixins[i][name];\r\n        if (fn) {\r\n            callWithAsyncErrorHandling(fn.bind(instance.proxy), instance, type);\r\n        }\r\n    }\r\n}\r\nfunction applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        applyOptions(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n}\r\nfunction resolveData(instance, dataFn, publicThis) {\r\n    if (false) {}\r\n    const data = dataFn.call(publicThis, publicThis);\r\n    if (false) {}\r\n    if (!Object(shared_esm_bundler["v" /* isObject */])(data)) {\r\n        ( false) && false;\r\n    }\r\n    else if (instance.data === shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n        instance.data = reactive(data);\r\n    }\r\n    else {\r\n        // existing data: this is a mixin or extends.\r\n        Object(shared_esm_bundler["i" /* extend */])(instance.data, data);\r\n    }\r\n}\r\nfunction createWatcher(raw, ctx, publicThis, key) {\r\n    const getter = key.includes(\'.\')\r\n        ? createPathGetter(publicThis, key)\r\n        : () => publicThis[key];\r\n    if (Object(shared_esm_bundler["C" /* isString */])(raw)) {\r\n        const handler = ctx[raw];\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(handler)) {\r\n            watch(getter, handler);\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(raw)) {\r\n        watch(getter, raw.bind(publicThis));\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(raw)) {\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(raw)) {\r\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n        }\r\n        else {\r\n            const handler = Object(shared_esm_bundler["p" /* isFunction */])(raw.handler)\r\n                ? raw.handler.bind(publicThis)\r\n                : ctx[raw.handler];\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(handler)) {\r\n                watch(getter, handler, raw);\r\n            }\r\n            else if ((false)) {}\r\n        }\r\n    }\r\n    else if ((false)) {}\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split(\'.\');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && Object(shared_esm_bundler["l" /* hasOwn */])(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => {\r\n    if (!i)\r\n        return null;\r\n    if (isStatefulComponent(i))\r\n        return i.exposed ? i.exposed : i.proxy;\r\n    return getPublicInstance(i.parent);\r\n};\r\nconst publicPropertiesMap = Object(shared_esm_bundler["i" /* extend */])(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (( false) ? undefined : i.props),\r\n    $attrs: i => (( false) ? undefined : i.attrs),\r\n    $slots: i => (( false) ? undefined : i.slots),\r\n    $refs: i => (( false) ? undefined : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : shared_esm_bundler["d" /* NOOP */])\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === "__v_skip" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if (false) {}\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It\'s much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== \'$\') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                Object(shared_esm_bundler["l" /* hasOwn */])(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === \'$attrs\') {\r\n                track(instance, "get" /* GET */, key);\r\n                ( false) && false;\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if (false) {}\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (Object(shared_esm_bundler["l" /* hasOwn */])(instance.props, key)) {\r\n            ( false) &&\r\n                false;\r\n            return false;\r\n        }\r\n        if (key[0] === \'$\' && key.slice(1) in instance) {\r\n            ( false) &&\r\n                false;\r\n            return false;\r\n        }\r\n        else {\r\n            if (false) {}\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(data, key)) ||\r\n            (setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && Object(shared_esm_bundler["l" /* hasOwn */])(normalizedProps, key)) ||\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(ctx, key) ||\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(publicPropertiesMap, key) ||\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif (false) {}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = Object(shared_esm_bundler["i" /* extend */])({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== \'_\' && !Object(shared_esm_bundler["q" /* isGloballyWhitelisted */])(key);\r\n        if (false) {}\r\n        return has;\r\n    }\r\n});\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nfunction createRenderContext(instance) {\r\n    const target = {};\r\n    // expose internal instance for proxy handlers\r\n    Object.defineProperty(target, `_`, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: () => instance\r\n    });\r\n    // expose public properties\r\n    Object.keys(publicPropertiesMap).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => publicPropertiesMap[key](instance),\r\n            // intercepted by the proxy so no need for implementation,\r\n            // but needed to prevent set errors\r\n            set: shared_esm_bundler["d" /* NOOP */]\r\n        });\r\n    });\r\n    // expose global properties\r\n    const { globalProperties } = instance.appContext.config;\r\n    Object.keys(globalProperties).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => globalProperties[key],\r\n            set: shared_esm_bundler["d" /* NOOP */]\r\n        });\r\n    });\r\n    return target;\r\n}\r\n// dev only\r\nfunction exposePropsOnRenderContext(instance) {\r\n    const { ctx, propsOptions: [propsOptions] } = instance;\r\n    if (propsOptions) {\r\n        Object.keys(propsOptions).forEach(key => {\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => instance.props[key],\r\n                set: shared_esm_bundler["d" /* NOOP */]\r\n            });\r\n        });\r\n    }\r\n}\r\n// dev only\r\nfunction exposeSetupStateOnRenderContext(instance) {\r\n    const { ctx, setupState } = instance;\r\n    Object.keys(toRaw(setupState)).forEach(key => {\r\n        if (key[0] === \'$\' || key[0] === \'_\') {\r\n            warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +\r\n                `which are reserved prefixes for Vue internals.`);\r\n            return;\r\n        }\r\n        Object.defineProperty(ctx, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => setupState[key],\r\n            set: shared_esm_bundler["d" /* NOOP */]\r\n        });\r\n    });\r\n}\n\nconst emptyAppContext = createAppContext();\r\nlet uid$1 = 0;\r\nfunction createComponentInstance(vnode, parent, suspense) {\r\n    const type = vnode.type;\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        uid: uid$1++,\r\n        vnode,\r\n        type,\r\n        parent,\r\n        appContext,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        update: null,\r\n        render: null,\r\n        proxy: null,\r\n        exposed: null,\r\n        withProxy: null,\r\n        effects: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        accessCache: null,\r\n        renderCache: [],\r\n        // local resovled assets\r\n        components: null,\r\n        directives: null,\r\n        // resolved props and emits options\r\n        propsOptions: normalizePropsOptions(type, appContext),\r\n        emitsOptions: normalizeEmitsOptions(type, appContext),\r\n        // emit\r\n        emit: null,\r\n        emitted: null,\r\n        // state\r\n        ctx: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        data: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        props: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        attrs: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        slots: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        refs: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        setupState: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        setupContext: null,\r\n        // suspense related\r\n        suspense,\r\n        suspenseId: suspense ? suspense.pendingId : 0,\r\n        asyncDep: null,\r\n        asyncResolved: false,\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isMounted: false,\r\n        isUnmounted: false,\r\n        isDeactivated: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null\r\n    };\r\n    if ((false)) {}\r\n    else {\r\n        instance.ctx = { _: instance };\r\n    }\r\n    instance.root = parent ? parent.root : instance;\r\n    instance.emit = runtime_core_esm_bundler_emit.bind(null, instance);\r\n    return instance;\r\n}\r\nlet currentInstance = null;\r\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n};\r\nconst isBuiltInTag = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'slot,component\');\r\nfunction validateComponentName(name, config) {\r\n    const appIsNativeTag = config.isNativeTag || shared_esm_bundler["c" /* NO */];\r\n    if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n        warn(\'Do not use built-in or reserved HTML elements as component id: \' + name);\r\n    }\r\n}\r\nfunction isStatefulComponent(instance) {\r\n    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n}\r\nlet isInSSRComponentSetup = false;\r\nfunction setupComponent(instance, isSSR = false) {\r\n    isInSSRComponentSetup = isSSR;\r\n    const { props, children } = instance.vnode;\r\n    const isStateful = isStatefulComponent(instance);\r\n    initProps(instance, props, isStateful, isSSR);\r\n    initSlots(instance, children);\r\n    const setupResult = isStateful\r\n        ? setupStatefulComponent(instance, isSSR)\r\n        : undefined;\r\n    isInSSRComponentSetup = false;\r\n    return setupResult;\r\n}\r\nfunction setupStatefulComponent(instance, isSSR) {\r\n    const Component = instance.type;\r\n    if ((false)) {}\r\n    // 0. create render proxy property access cache\r\n    instance.accessCache = Object.create(null);\r\n    // 1. create public instance / render proxy\r\n    // also mark it raw so it\'s never observed\r\n    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\r\n    if ((false)) {}\r\n    // 2. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        currentInstance = instance;\r\n        pauseTracking();\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( false) ? undefined : instance.props, setupContext]);\r\n        resetTracking();\r\n        currentInstance = null;\r\n        if (Object(shared_esm_bundler["x" /* isPromise */])(setupResult)) {\r\n            if (isSSR) {\r\n                // return the promise so server-renderer can wait on it\r\n                return setupResult.then((resolvedResult) => {\r\n                    handleSetupResult(instance, resolvedResult);\r\n                });\r\n            }\r\n            else {\r\n                // async setup returned Promise.\r\n                // bail here and wait for re-entry.\r\n                instance.asyncDep = setupResult;\r\n            }\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult, isSSR) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(setupResult)) {\r\n        // setup returned an inline render function\r\n        {\r\n            instance.render = setupResult;\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(setupResult)) {\r\n        if (false) {}\r\n        // setup returned bindings.\r\n        // assuming a render function compiled from template is present.\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            instance.devtoolsRawSetupState = setupResult;\r\n        }\r\n        instance.setupState = proxyRefs(setupResult);\r\n        if ((false)) {}\r\n    }\r\n    else if (false) {}\r\n    finishComponentSetup(instance);\r\n}\r\nlet compile;\r\n// dev only\r\nconst isRuntimeOnly = () => !compile;\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nfunction registerRuntimeCompiler(_compile) {\r\n    compile = _compile;\r\n}\r\nfunction finishComponentSetup(instance, isSSR) {\r\n    const Component = instance.type;\r\n    // template / render function normalization\r\n    if (!instance.render) {\r\n        // could be set from setup()\r\n        if (compile && Component.template && !Component.render) {\r\n            if ((false)) {}\r\n            Component.render = compile(Component.template, {\r\n                isCustomElement: instance.appContext.config.isCustomElement,\r\n                delimiters: Component.delimiters\r\n            });\r\n            if ((false)) {}\r\n        }\r\n        instance.render = (Component.render || shared_esm_bundler["d" /* NOOP */]);\r\n        // for runtime-compiled render functions using `with` blocks, the render\r\n        // proxy used needs a different `has` handler which is more performant and\r\n        // also only allows a whitelist of globals to fallthrough.\r\n        if (instance.render._rc) {\r\n            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n        }\r\n    }\r\n    // support for 2.x options\r\n    if (__VUE_OPTIONS_API__) {\r\n        currentInstance = instance;\r\n        pauseTracking();\r\n        applyOptions(instance, Component);\r\n        resetTracking();\r\n        currentInstance = null;\r\n    }\r\n    // warn missing template/render\r\n    if (false) {}\r\n}\r\nconst attrHandlers = {\r\n    get: (target, key) => {\r\n        if ((false)) {}\r\n        return target[key];\r\n    },\r\n    set: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    },\r\n    deleteProperty: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    }\r\n};\r\nfunction createSetupContext(instance) {\r\n    const expose = exposed => {\r\n        if (false) {}\r\n        instance.exposed = proxyRefs(exposed);\r\n    };\r\n    if ((false)) {}\r\n    else {\r\n        return {\r\n            attrs: instance.attrs,\r\n            slots: instance.slots,\r\n            emit: instance.emit,\r\n            expose\r\n        };\r\n    }\r\n}\r\n// record effects created during a component\'s setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, \'\');\r\nfunction getComponentName(Component) {\r\n    return Object(shared_esm_bundler["p" /* isFunction */])(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return Object(shared_esm_bundler["p" /* isFunction */])(value) && \'__vccOpts\' in value;\r\n}\n\nfunction runtime_core_esm_bundler_computed(getterOrOptions) {\r\n    const c = reactivity_esm_bundler_computed(getterOrOptions);\r\n    recordInstanceBoundEffect(c.effect);\r\n    return c;\r\n}\n\n// implementation\r\nfunction defineProps() {\r\n    if ((false)) {}\r\n    return null;\r\n}\r\n// implementation\r\nfunction defineEmit() {\r\n    if ((false)) {}\r\n    return null;\r\n}\r\nfunction useContext() {\r\n    const i = getCurrentInstance();\r\n    if (false) {}\r\n    return i.setupContext || (i.setupContext = createSetupContext(i));\r\n}\n\n// Actual implementation\r\nfunction h(type, propsOrChildren, children) {\r\n    const l = arguments.length;\r\n    if (l === 2) {\r\n        if (Object(shared_esm_bundler["v" /* isObject */])(propsOrChildren) && !Object(shared_esm_bundler["o" /* isArray */])(propsOrChildren)) {\r\n            // single vnode without props\r\n            if (isVNode(propsOrChildren)) {\r\n                return createVNode(type, null, [propsOrChildren]);\r\n            }\r\n            // props without children\r\n            return createVNode(type, propsOrChildren);\r\n        }\r\n        else {\r\n            // omit props\r\n            return createVNode(type, null, propsOrChildren);\r\n        }\r\n    }\r\n    else {\r\n        if (l > 3) {\r\n            children = Array.prototype.slice.call(arguments, 2);\r\n        }\r\n        else if (l === 3 && isVNode(children)) {\r\n            children = [children];\r\n        }\r\n        return createVNode(type, propsOrChildren, children);\r\n    }\r\n}\n\nconst ssrContextKey = Symbol(( false) ? undefined : ``);\r\nconst useSSRContext = () => {\r\n    {\r\n        const ctx = inject(ssrContextKey);\r\n        if (!ctx) {\r\n            warn(`Server rendering context not provided. Make sure to only call ` +\r\n                `useSSRContext() conditionally in the server build.`);\r\n        }\r\n        return ctx;\r\n    }\r\n};\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (true) {\r\n        return;\r\n    }\r\n    const vueStyle = { style: \'color:#3ba776\' };\r\n    const numberStyle = { style: \'color:#0b1bc9\' };\r\n    const stringStyle = { style: \'color:#b62e24\' };\r\n    const keywordStyle = { style: \'color:#9d288c\' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!Object(shared_esm_bundler["v" /* isObject */])(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return [\'div\', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    [\'span\', vueStyle, genRefFlag(obj)],\r\n                    \'<\',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    [\'span\', vueStyle, \'Reactive\'],\r\n                    \'<\',\r\n                    formatValue(obj),\r\n                    `>${reactivity_esm_bundler_isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (reactivity_esm_bundler_isReadonly(obj)) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    [\'span\', vueStyle, \'Readonly\'],\r\n                    \'<\',\r\n                    formatValue(obj),\r\n                    \'>\'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock(\'props\', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n            blocks.push(createInstanceBlock(\'setup\', instance.setupState));\r\n        }\r\n        if (instance.data !== shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n            blocks.push(createInstanceBlock(\'data\', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, \'computed\');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock(\'computed\', computed));\r\n        }\r\n        const injected = extractKeys(instance, \'inject\');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock(\'injected\', injected));\r\n        }\r\n        blocks.push([\r\n            \'div\',\r\n            {},\r\n            [\r\n                \'span\',\r\n                {\r\n                    style: keywordStyle.style + \';opacity:0.66\'\r\n                },\r\n                \'$ (internal): \'\r\n            ],\r\n            [\'object\', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = Object(shared_esm_bundler["i" /* extend */])({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return [\'span\', {}];\r\n        }\r\n        return [\r\n            \'div\',\r\n            { style: \'line-height:1.25em;margin-bottom:0.6em\' },\r\n            [\r\n                \'div\',\r\n                {\r\n                    style: \'color:#476582\'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                \'div\',\r\n                {\r\n                    style: \'padding-left:1.25em\'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        \'div\',\r\n                        {},\r\n                        [\'span\', keywordStyle, key + \': \'],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === \'number\') {\r\n            return [\'span\', numberStyle, v];\r\n        }\r\n        else if (typeof v === \'string\') {\r\n            return [\'span\', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === \'boolean\') {\r\n            return [\'span\', keywordStyle, v];\r\n        }\r\n        else if (Object(shared_esm_bundler["v" /* isObject */])(v)) {\r\n            return [\'object\', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return [\'span\', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((Object(shared_esm_bundler["o" /* isArray */])(opts) && opts.includes(key)) ||\r\n            (Object(shared_esm_bundler["v" /* isObject */])(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\n/**\r\n * Actual implementation\r\n */\r\nfunction renderList(source, renderItem) {\r\n    let ret;\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(source) || Object(shared_esm_bundler["C" /* isString */])(source)) {\r\n        ret = new Array(source.length);\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            ret[i] = renderItem(source[i], i);\r\n        }\r\n    }\r\n    else if (typeof source === \'number\') {\r\n        if (false) {}\r\n        ret = new Array(source);\r\n        for (let i = 0; i < source; i++) {\r\n            ret[i] = renderItem(i + 1, i);\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            ret = Array.from(source, renderItem);\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            ret = new Array(keys.length);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                ret[i] = renderItem(source[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        ret = [];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * For prefixing keys in v-on="obj" with "on"\r\n * @private\r\n */\r\nfunction toHandlers(obj) {\r\n    const ret = {};\r\n    if (false) {}\r\n    for (const key in obj) {\r\n        ret[Object(shared_esm_bundler["N" /* toHandlerKey */])(key)] = obj[key];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\r\nfunction createSlots(slots, dynamicSlots) {\r\n    for (let i = 0; i < dynamicSlots.length; i++) {\r\n        const slot = dynamicSlots[i];\r\n        // array of dynamic slot generated by <template v-for="..." #[...]>\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(slot)) {\r\n            for (let j = 0; j < slot.length; j++) {\r\n                slots[slot[j].name] = slot[j].fn;\r\n            }\r\n        }\r\n        else if (slot) {\r\n            // conditional single slot generated by <template v-if="..." #foo>\r\n            slots[slot.name] = slot.fn;\r\n        }\r\n    }\r\n    return slots;\r\n}\n\n// Core API ------------------------------------------------------------------\r\nconst version = "3.0.7";\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\r\n * @internal\r\n */\r\nconst ssrUtils = (null);\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\n\n\n\n\nconst svgNS = \'http://www.w3.org/2000/svg\';\r\nconst doc = (typeof document !== \'undefined\' ? document : null);\r\nlet tempContainer;\r\nlet tempSVGContainer;\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is) => isSVG\r\n        ? doc.createElementNS(svgNS, tag)\r\n        : doc.createElement(tag, is ? { is } : undefined),\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, \'\');\r\n    },\r\n    cloneNode(el) {\r\n        return el.cloneNode(true);\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG) {\r\n        const temp = isSVG\r\n            ? tempSVGContainer ||\r\n                (tempSVGContainer = doc.createElementNS(svgNS, \'svg\'))\r\n            : tempContainer || (tempContainer = doc.createElement(\'div\'));\r\n        temp.innerHTML = content;\r\n        const first = temp.firstChild;\r\n        let node = first;\r\n        let last = node;\r\n        while (node) {\r\n            last = node;\r\n            nodeOps.insert(node, parent, anchor);\r\n            node = temp.firstChild;\r\n        }\r\n        return [first, last];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding [\'staticClass\', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    if (value == null) {\r\n        value = \'\';\r\n    }\r\n    if (isSVG) {\r\n        el.setAttribute(\'class\', value);\r\n    }\r\n    else {\r\n        // directly setting className should be faster than setAttribute in theory\r\n        // if this is an element during a transition, take the temporary transition\r\n        // classes into account.\r\n        const transitionClasses = el._vtc;\r\n        if (transitionClasses) {\r\n            value = (value\r\n                ? [value, ...transitionClasses]\r\n                : [...transitionClasses]).join(\' \');\r\n        }\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    if (!next) {\r\n        el.removeAttribute(\'style\');\r\n    }\r\n    else if (Object(shared_esm_bundler["C" /* isString */])(next)) {\r\n        if (prev !== next) {\r\n            const current = style.display;\r\n            style.cssText = next;\r\n            // indicates that the `display` of the element is controlled by `v-show`,\r\n            // so we always keep the current `display` value regardless of the `style` value,\r\n            // thus handing over control to `v-show`.\r\n            if (\'_vod\' in el) {\r\n                style.display = current;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !Object(shared_esm_bundler["C" /* isString */])(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, \'\');\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (name.startsWith(\'--\')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty(Object(shared_esm_bundler["m" /* hyphenate */])(prefixed), val.replace(importantRE, \'\'), \'important\');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = [\'Webkit\', \'Moz\', \'ms\'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = Object(shared_esm_bundler["f" /* camelize */])(rawName);\r\n    if (name !== \'filter\' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = Object(shared_esm_bundler["g" /* capitalize */])(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = \'http://www.w3.org/1999/xlink\';\r\nfunction patchAttr(el, key, value, isSVG) {\r\n    if (isSVG && key.startsWith(\'xlink:\')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don\'t have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = Object(shared_esm_bundler["B" /* isSpecialBooleanAttr */])(key);\r\n        if (value == null || (isBoolean && value === false)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? \'\' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === \'innerHTML\' || key === \'textContent\') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? \'\' : value;\r\n        return;\r\n    }\r\n    if (key === \'value\' && el.tagName !== \'PROGRESS\') {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? \'\' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n        return;\r\n    }\r\n    if (value === \'\' || value == null) {\r\n        const type = typeof el[key];\r\n        if (value === \'\' && type === \'boolean\') {\r\n            // e.g. <select multiple> compiles to { multiple: \'\' }\r\n            el[key] = true;\r\n            return;\r\n        }\r\n        else if (value == null && type === \'string\') {\r\n            // e.g. <div :id="null">\r\n            el[key] = \'\';\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n        else if (type === \'number\') {\r\n            // e.g. <img :width="null">\r\n            el[key] = 0;\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n        if ((false)) {}\r\n    }\r\n}\n\n// Async edge case fix requires storing an event listener\'s attach timestamp.\r\nlet _getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\nif (typeof document !== \'undefined\' &&\r\n    _getNow() > document.createEvent(\'Event\').timeStamp) {\r\n    // if the low-res timestamp which is bigger than the event timestamp\r\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n    // and we need to use the hi-res version for event listeners as well.\r\n    _getNow = () => performance.now();\r\n}\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst runtime_dom_esm_bundler_p = Promise.resolve();\r\nconst runtime_dom_esm_bundler_reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (runtime_dom_esm_bundler_p.then(runtime_dom_esm_bundler_reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [Object(shared_esm_bundler["m" /* hyphenate */])(name.slice(2)), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (timeStamp >= invoker.attached - 1) {\r\n            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst forcePatchProp = (_, key) => key === \'value\';\r\nconst runtime_dom_esm_bundler_patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    switch (key) {\r\n        // special\r\n        case \'class\':\r\n            patchClass(el, nextValue, isSVG);\r\n            break;\r\n        case \'style\':\r\n            patchStyle(el, prevValue, nextValue);\r\n            break;\r\n        default:\r\n            if (Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n                // ignore v-model listeners\r\n                if (!Object(shared_esm_bundler["u" /* isModelListener */])(key)) {\r\n                    patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n                }\r\n            }\r\n            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n            }\r\n            else {\r\n                // special case for <input v-model type="checkbox"> with\r\n                // :true-value & :false-value\r\n                // store value as dom properties since non-string values will be\r\n                // stringified.\r\n                if (key === \'true-value\') {\r\n                    el._trueValue = nextValue;\r\n                }\r\n                else if (key === \'false-value\') {\r\n                    el._falseValue = nextValue;\r\n                }\r\n                patchAttr(el, key, nextValue, isSVG);\r\n            }\r\n            break;\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML\r\n        if (key === \'innerHTML\') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && Object(shared_esm_bundler["p" /* isFunction */])(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // spellcheck and draggable are numerated attrs, however their\r\n    // corresponding DOM properties are actually booleans - this leads to\r\n    // setting it with a string "false" value leading it to be coerced to\r\n    // `true`, so we need to always treat them as attributes.\r\n    // Note that `contentEditable` doesn\'t have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === \'spellcheck\' || key === \'draggable\') {\r\n        return false;\r\n    }\r\n    // #1787, #2840 form property on form elements is readonly and must be set as\r\n    // attribute.\r\n    if (key === \'form\') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === \'list\' && el.tagName === \'INPUT\') {\r\n        return false;\r\n    }\r\n    // #2766 <textarea type> must be set as attribute\r\n    if (key === \'type\' && el.tagName === \'TEXTAREA\') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && Object(shared_esm_bundler["C" /* isString */])(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nfunction useCssModule(name = \'$style\') {\r\n    /* istanbul ignore else */\r\n    {\r\n        const instance = getCurrentInstance();\r\n        if (!instance) {\r\n            ( false) && false;\r\n            return shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        }\r\n        const modules = instance.type.__cssModules;\r\n        if (!modules) {\r\n            ( false) && false;\r\n            return shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        }\r\n        const mod = modules[name];\r\n        if (!mod) {\r\n            ( false) &&\r\n                false;\r\n            return shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC\'s CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    const instance = getCurrentInstance();\r\n    /* istanbul ignore next */\r\n    if (!instance) {\r\n        ( false) &&\r\n            false;\r\n        return;\r\n    }\r\n    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));\r\n    onMounted(() => watchEffect(setVars, { flush: \'post\' }));\r\n    onUpdated(setVars);\r\n}\r\nfunction setVarsOnVNode(vnode, vars) {\r\n    if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        const suspense = vnode.suspense;\r\n        vnode = suspense.activeBranch;\r\n        if (suspense.pendingBranch && !suspense.isHydrating) {\r\n            suspense.effects.push(() => {\r\n                setVarsOnVNode(suspense.activeBranch, vars);\r\n            });\r\n        }\r\n    }\r\n    // drill down HOCs until it\'s a non-component vnode\r\n    while (vnode.component) {\r\n        vnode = vnode.component.subTree;\r\n    }\r\n    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {\r\n        const style = vnode.el.style;\r\n        for (const key in vars) {\r\n            style.setProperty(`--${key}`, vars[key]);\r\n        }\r\n    }\r\n    else if (vnode.type === Fragment) {\r\n        vnode.children.forEach(c => setVarsOnVNode(c, vars));\r\n    }\r\n}\n\nconst TRANSITION = \'transition\';\r\nconst ANIMATION = \'animation\';\r\n// DOM Transition is a higher-order-component based on the platform-agnostic\r\n// base Transition component, with DOM-specific logic.\r\nconst Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);\r\nTransition.displayName = \'Transition\';\r\nconst DOMTransitionPropsValidators = {\r\n    name: String,\r\n    type: String,\r\n    css: {\r\n        type: Boolean,\r\n        default: true\r\n    },\r\n    duration: [String, Number, Object],\r\n    enterFromClass: String,\r\n    enterActiveClass: String,\r\n    enterToClass: String,\r\n    appearFromClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    leaveFromClass: String,\r\n    leaveActiveClass: String,\r\n    leaveToClass: String\r\n};\r\nconst TransitionPropsValidators = (Transition.props = /*#__PURE__*/ Object(shared_esm_bundler["i" /* extend */])({}, BaseTransition.props, DOMTransitionPropsValidators));\r\nfunction resolveTransitionProps(rawProps) {\r\n    let { name = \'v\', type, css = true, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\r\n    const baseProps = {};\r\n    for (const key in rawProps) {\r\n        if (!(key in DOMTransitionPropsValidators)) {\r\n            baseProps[key] = rawProps[key];\r\n        }\r\n    }\r\n    if (!css) {\r\n        return baseProps;\r\n    }\r\n    const durations = normalizeDuration(duration);\r\n    const enterDuration = durations && durations[0];\r\n    const leaveDuration = durations && durations[1];\r\n    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\r\n    const finishEnter = (el, isAppear, done) => {\r\n        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\r\n        done && done();\r\n    };\r\n    const finishLeave = (el, done) => {\r\n        removeTransitionClass(el, leaveToClass);\r\n        removeTransitionClass(el, leaveActiveClass);\r\n        done && done();\r\n    };\r\n    const makeEnterHook = (isAppear) => {\r\n        return (el, done) => {\r\n            const hook = isAppear ? onAppear : onEnter;\r\n            const resolve = () => finishEnter(el, isAppear, done);\r\n            hook && hook(el, resolve);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\r\n                addTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n                if (!(hook && hook.length > 1)) {\r\n                    whenTransitionEnds(el, type, enterDuration, resolve);\r\n                }\r\n            });\r\n        };\r\n    };\r\n    return Object(shared_esm_bundler["i" /* extend */])(baseProps, {\r\n        onBeforeEnter(el) {\r\n            onBeforeEnter && onBeforeEnter(el);\r\n            addTransitionClass(el, enterFromClass);\r\n            addTransitionClass(el, enterActiveClass);\r\n        },\r\n        onBeforeAppear(el) {\r\n            onBeforeAppear && onBeforeAppear(el);\r\n            addTransitionClass(el, appearFromClass);\r\n            addTransitionClass(el, appearActiveClass);\r\n        },\r\n        onEnter: makeEnterHook(false),\r\n        onAppear: makeEnterHook(true),\r\n        onLeave(el, done) {\r\n            const resolve = () => finishLeave(el, done);\r\n            addTransitionClass(el, leaveFromClass);\r\n            // force reflow so *-leave-from classes immediately take effect (#2593)\r\n            forceReflow();\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, leaveFromClass);\r\n                addTransitionClass(el, leaveToClass);\r\n                if (!(onLeave && onLeave.length > 1)) {\r\n                    whenTransitionEnds(el, type, leaveDuration, resolve);\r\n                }\r\n            });\r\n            onLeave && onLeave(el, resolve);\r\n        },\r\n        onEnterCancelled(el) {\r\n            finishEnter(el, false);\r\n            onEnterCancelled && onEnterCancelled(el);\r\n        },\r\n        onAppearCancelled(el) {\r\n            finishEnter(el, true);\r\n            onAppearCancelled && onAppearCancelled(el);\r\n        },\r\n        onLeaveCancelled(el) {\r\n            finishLeave(el);\r\n            onLeaveCancelled && onLeaveCancelled(el);\r\n        }\r\n    });\r\n}\r\nfunction normalizeDuration(duration) {\r\n    if (duration == null) {\r\n        return null;\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(duration)) {\r\n        return [NumberOf(duration.enter), NumberOf(duration.leave)];\r\n    }\r\n    else {\r\n        const n = NumberOf(duration);\r\n        return [n, n];\r\n    }\r\n}\r\nfunction NumberOf(val) {\r\n    const res = Object(shared_esm_bundler["O" /* toNumber */])(val);\r\n    if ((false))\r\n        {}\r\n    return res;\r\n}\r\nfunction validateDuration(val) {\r\n    if (typeof val !== \'number\') {\r\n        warn(`<transition> explicit duration is not a valid number - ` +\r\n            `got ${JSON.stringify(val)}.`);\r\n    }\r\n    else if (isNaN(val)) {\r\n        warn(`<transition> explicit duration is NaN - ` +\r\n            \'the duration expression might be incorrect.\');\r\n    }\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\r\n    (el._vtc ||\r\n        (el._vtc = new Set())).add(cls);\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\r\n    const { _vtc } = el;\r\n    if (_vtc) {\r\n        _vtc.delete(cls);\r\n        if (!_vtc.size) {\r\n            el._vtc = undefined;\r\n        }\r\n    }\r\n}\r\nfunction nextFrame(cb) {\r\n    requestAnimationFrame(() => {\r\n        requestAnimationFrame(cb);\r\n    });\r\n}\r\nlet endId = 0;\r\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\r\n    const id = (el._endId = ++endId);\r\n    const resolveIfNotStale = () => {\r\n        if (id === el._endId) {\r\n            resolve();\r\n        }\r\n    };\r\n    if (explicitTimeout) {\r\n        return setTimeout(resolveIfNotStale, explicitTimeout);\r\n    }\r\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\r\n    if (!type) {\r\n        return resolve();\r\n    }\r\n    const endEvent = type + \'end\';\r\n    let ended = 0;\r\n    const end = () => {\r\n        el.removeEventListener(endEvent, onEnd);\r\n        resolveIfNotStale();\r\n    };\r\n    const onEnd = (e) => {\r\n        if (e.target === el && ++ended >= propCount) {\r\n            end();\r\n        }\r\n    };\r\n    setTimeout(() => {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(endEvent, onEnd);\r\n}\r\nfunction getTransitionInfo(el, expectedType) {\r\n    const styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    const getStyleProperties = (key) => (styles[key] || \'\').split(\', \');\r\n    const transitionDelays = getStyleProperties(TRANSITION + \'Delay\');\r\n    const transitionDurations = getStyleProperties(TRANSITION + \'Duration\');\r\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    const animationDelays = getStyleProperties(ANIMATION + \'Delay\');\r\n    const animationDurations = getStyleProperties(ANIMATION + \'Duration\');\r\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    let type = null;\r\n    let timeout = 0;\r\n    let propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    const hasTransform = type === TRANSITION &&\r\n        /\\b(transform|all)(,|$)/.test(styles[TRANSITION + \'Property\']);\r\n    return {\r\n        type,\r\n        timeout,\r\n        propCount,\r\n        hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n// numbers in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down\r\n// (i.e. acting as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(\',\', \'.\')) * 1000;\r\n}\r\n// synchronously force layout to put elements into a certain state\r\nfunction forceReflow() {\r\n    return document.body.offsetHeight;\r\n}\n\nconst positionMap = new WeakMap();\r\nconst newPositionMap = new WeakMap();\r\nconst TransitionGroupImpl = {\r\n    name: \'TransitionGroup\',\r\n    props: /*#__PURE__*/ Object(shared_esm_bundler["i" /* extend */])({}, TransitionPropsValidators, {\r\n        tag: String,\r\n        moveClass: String\r\n    }),\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevChildren;\r\n        let children;\r\n        onUpdated(() => {\r\n            // children is guaranteed to exist after initial render\r\n            if (!prevChildren.length) {\r\n                return;\r\n            }\r\n            const moveClass = props.moveClass || `${props.name || \'v\'}-move`;\r\n            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\r\n                return;\r\n            }\r\n            // we divide the work into three loops to avoid mixing DOM reads and writes\r\n            // in each iteration - which helps prevent layout thrashing.\r\n            prevChildren.forEach(callPendingCbs);\r\n            prevChildren.forEach(recordPosition);\r\n            const movedChildren = prevChildren.filter(applyTranslation);\r\n            // force reflow to put everything in position\r\n            forceReflow();\r\n            movedChildren.forEach(c => {\r\n                const el = c.el;\r\n                const style = el.style;\r\n                addTransitionClass(el, moveClass);\r\n                style.transform = style.webkitTransform = style.transitionDuration = \'\';\r\n                const cb = (el._moveCb = (e) => {\r\n                    if (e && e.target !== el) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el.removeEventListener(\'transitionend\', cb);\r\n                        el._moveCb = null;\r\n                        removeTransitionClass(el, moveClass);\r\n                    }\r\n                });\r\n                el.addEventListener(\'transitionend\', cb);\r\n            });\r\n        });\r\n        return () => {\r\n            const rawProps = toRaw(props);\r\n            const cssTransitionProps = resolveTransitionProps(rawProps);\r\n            const tag = rawProps.tag || Fragment;\r\n            prevChildren = children;\r\n            children = slots.default ? getTransitionRawChildren(slots.default()) : [];\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child.key != null) {\r\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                }\r\n                else if ((false)) {}\r\n            }\r\n            if (prevChildren) {\r\n                for (let i = 0; i < prevChildren.length; i++) {\r\n                    const child = prevChildren[i];\r\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                    positionMap.set(child, child.el.getBoundingClientRect());\r\n                }\r\n            }\r\n            return createVNode(tag, null, children);\r\n        };\r\n    }\r\n};\r\nconst TransitionGroup = TransitionGroupImpl;\r\nfunction callPendingCbs(c) {\r\n    const el = c.el;\r\n    if (el._moveCb) {\r\n        el._moveCb();\r\n    }\r\n    if (el._enterCb) {\r\n        el._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    newPositionMap.set(c, c.el.getBoundingClientRect());\r\n}\r\nfunction applyTranslation(c) {\r\n    const oldPos = positionMap.get(c);\r\n    const newPos = newPositionMap.get(c);\r\n    const dx = oldPos.left - newPos.left;\r\n    const dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        const s = c.el.style;\r\n        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\r\n        s.transitionDuration = \'0s\';\r\n        return c;\r\n    }\r\n}\r\nfunction hasCSSTransform(el, root, moveClass) {\r\n    // Detect whether an element with the move class applied has\r\n    // CSS transitions. Since the element may be inside an entering\r\n    // transition at this very moment, we make a clone of it and remove\r\n    // all other transition classes applied to ensure only the move class\r\n    // is applied.\r\n    const clone = el.cloneNode();\r\n    if (el._vtc) {\r\n        el._vtc.forEach(cls => {\r\n            cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\r\n        });\r\n    }\r\n    moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\r\n    clone.style.display = \'none\';\r\n    const container = (root.nodeType === 1\r\n        ? root\r\n        : root.parentNode);\r\n    container.appendChild(clone);\r\n    const { hasTransform } = getTransitionInfo(clone);\r\n    container.removeChild(clone);\r\n    return hasTransform;\r\n}\n\nconst getModelAssigner = (vnode) => {\r\n    const fn = vnode.props[\'onUpdate:modelValue\'];\r\n    return Object(shared_esm_bundler["o" /* isArray */])(fn) ? value => Object(shared_esm_bundler["n" /* invokeArrayFns */])(fn, value) : fn;\r\n};\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    const target = e.target;\r\n    if (target.composing) {\r\n        target.composing = false;\r\n        runtime_dom_esm_bundler_trigger(target, \'input\');\r\n    }\r\n}\r\nfunction runtime_dom_esm_bundler_trigger(el, type) {\r\n    const e = document.createEvent(\'HTMLEvents\');\r\n    e.initEvent(type, true, true);\r\n    el.dispatchEvent(e);\r\n}\r\n// We are exporting the v-model runtime directly as vnode hooks so that it can\r\n// be tree-shaken in case v-model is never used.\r\nconst vModelText = {\r\n    created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        const castToNumber = number || el.type === \'number\';\r\n        addEventListener(el, lazy ? \'change\' : \'input\', e => {\r\n            if (e.target.composing)\r\n                return;\r\n            let domValue = el.value;\r\n            if (trim) {\r\n                domValue = domValue.trim();\r\n            }\r\n            else if (castToNumber) {\r\n                domValue = Object(shared_esm_bundler["O" /* toNumber */])(domValue);\r\n            }\r\n            el._assign(domValue);\r\n        });\r\n        if (trim) {\r\n            addEventListener(el, \'change\', () => {\r\n                el.value = el.value.trim();\r\n            });\r\n        }\r\n        if (!lazy) {\r\n            addEventListener(el, \'compositionstart\', onCompositionStart);\r\n            addEventListener(el, \'compositionend\', onCompositionEnd);\r\n            // Safari < 10.2 & UIWebView doesn\'t fire compositionend when\r\n            // switching focus before confirming composition choice\r\n            // this also fixes the issue where some browsers e.g. iOS Chrome\r\n            // fires "change" instead of "input" on autocomplete.\r\n            addEventListener(el, \'change\', onCompositionEnd);\r\n        }\r\n    },\r\n    // set value on mounted so it\'s after min/max for type="range"\r\n    mounted(el, { value }) {\r\n        el.value = value == null ? \'\' : value;\r\n    },\r\n    beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        // avoid clearing unresolved text. #2302\r\n        if (el.composing)\r\n            return;\r\n        if (document.activeElement === el) {\r\n            if (trim && el.value.trim() === value) {\r\n                return;\r\n            }\r\n            if ((number || el.type === \'number\') && Object(shared_esm_bundler["O" /* toNumber */])(el.value) === value) {\r\n                return;\r\n            }\r\n        }\r\n        const newValue = value == null ? \'\' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n    }\r\n};\r\nconst vModelCheckbox = {\r\n    created(el, _, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, \'change\', () => {\r\n            const modelValue = el._modelValue;\r\n            const elementValue = getValue(el);\r\n            const checked = el.checked;\r\n            const assign = el._assign;\r\n            if (Object(shared_esm_bundler["o" /* isArray */])(modelValue)) {\r\n                const index = Object(shared_esm_bundler["G" /* looseIndexOf */])(modelValue, elementValue);\r\n                const found = index !== -1;\r\n                if (checked && !found) {\r\n                    assign(modelValue.concat(elementValue));\r\n                }\r\n                else if (!checked && found) {\r\n                    const filtered = [...modelValue];\r\n                    filtered.splice(index, 1);\r\n                    assign(filtered);\r\n                }\r\n            }\r\n            else if (Object(shared_esm_bundler["A" /* isSet */])(modelValue)) {\r\n                const cloned = new Set(modelValue);\r\n                if (checked) {\r\n                    cloned.add(elementValue);\r\n                }\r\n                else {\r\n                    cloned.delete(elementValue);\r\n                }\r\n                assign(cloned);\r\n            }\r\n            else {\r\n                assign(getCheckboxValue(el, checked));\r\n            }\r\n        });\r\n    },\r\n    // set initial checked on mount to wait for true-value/false-value\r\n    mounted: setChecked,\r\n    beforeUpdate(el, binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        setChecked(el, binding, vnode);\r\n    }\r\n};\r\nfunction setChecked(el, { value, oldValue }, vnode) {\r\n    el._modelValue = value;\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n        el.checked = Object(shared_esm_bundler["G" /* looseIndexOf */])(value, vnode.props.value) > -1;\r\n    }\r\n    else if (Object(shared_esm_bundler["A" /* isSet */])(value)) {\r\n        el.checked = value.has(vnode.props.value);\r\n    }\r\n    else if (value !== oldValue) {\r\n        el.checked = Object(shared_esm_bundler["F" /* looseEqual */])(value, getCheckboxValue(el, true));\r\n    }\r\n}\r\nconst vModelRadio = {\r\n    created(el, { value }, vnode) {\r\n        el.checked = Object(shared_esm_bundler["F" /* looseEqual */])(value, vnode.props.value);\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, \'change\', () => {\r\n            el._assign(getValue(el));\r\n        });\r\n    },\r\n    beforeUpdate(el, { value, oldValue }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        if (value !== oldValue) {\r\n            el.checked = Object(shared_esm_bundler["F" /* looseEqual */])(value, vnode.props.value);\r\n        }\r\n    }\r\n};\r\nconst vModelSelect = {\r\n    created(el, { value, modifiers: { number } }, vnode) {\r\n        const isSetModel = Object(shared_esm_bundler["A" /* isSet */])(value);\r\n        addEventListener(el, \'change\', () => {\r\n            const selectedVal = Array.prototype.filter\r\n                .call(el.options, (o) => o.selected)\r\n                .map((o) => number ? Object(shared_esm_bundler["O" /* toNumber */])(getValue(o)) : getValue(o));\r\n            el._assign(el.multiple\r\n                ? isSetModel\r\n                    ? new Set(selectedVal)\r\n                    : selectedVal\r\n                : selectedVal[0]);\r\n        });\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    // set value in mounted & updated because <select> relies on its children\r\n    // <option>s.\r\n    mounted(el, { value }) {\r\n        setSelected(el, value);\r\n    },\r\n    beforeUpdate(el, _binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    updated(el, { value }) {\r\n        setSelected(el, value);\r\n    }\r\n};\r\nfunction setSelected(el, value) {\r\n    const isMultiple = el.multiple;\r\n    if (isMultiple && !Object(shared_esm_bundler["o" /* isArray */])(value) && !Object(shared_esm_bundler["A" /* isSet */])(value)) {\r\n        ( false) &&\r\n            false;\r\n        return;\r\n    }\r\n    for (let i = 0, l = el.options.length; i < l; i++) {\r\n        const option = el.options[i];\r\n        const optionValue = getValue(option);\r\n        if (isMultiple) {\r\n            if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n                option.selected = Object(shared_esm_bundler["G" /* looseIndexOf */])(value, optionValue) > -1;\r\n            }\r\n            else {\r\n                option.selected = value.has(optionValue);\r\n            }\r\n        }\r\n        else {\r\n            if (Object(shared_esm_bundler["F" /* looseEqual */])(getValue(option), value)) {\r\n                el.selectedIndex = i;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\n// retrieve raw value set via :value bindings\r\nfunction getValue(el) {\r\n    return \'_value\' in el ? el._value : el.value;\r\n}\r\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\nfunction getCheckboxValue(el, checked) {\r\n    const key = checked ? \'_trueValue\' : \'_falseValue\';\r\n    return key in el ? el[key] : checked;\r\n}\r\nconst vModelDynamic = {\r\n    created(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, \'created\');\r\n    },\r\n    mounted(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, \'mounted\');\r\n    },\r\n    beforeUpdate(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, \'beforeUpdate\');\r\n    },\r\n    updated(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, \'updated\');\r\n    }\r\n};\r\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\r\n    let modelToUse;\r\n    switch (el.tagName) {\r\n        case \'SELECT\':\r\n            modelToUse = vModelSelect;\r\n            break;\r\n        case \'TEXTAREA\':\r\n            modelToUse = vModelText;\r\n            break;\r\n        default:\r\n            switch (vnode.props && vnode.props.type) {\r\n                case \'checkbox\':\r\n                    modelToUse = vModelCheckbox;\r\n                    break;\r\n                case \'radio\':\r\n                    modelToUse = vModelRadio;\r\n                    break;\r\n                default:\r\n                    modelToUse = vModelText;\r\n            }\r\n    }\r\n    const fn = modelToUse[hook];\r\n    fn && fn(el, binding, vnode, prevVNode);\r\n}\n\nconst systemModifiers = [\'ctrl\', \'shift\', \'alt\', \'meta\'];\r\nconst modifierGuards = {\r\n    stop: e => e.stopPropagation(),\r\n    prevent: e => e.preventDefault(),\r\n    self: e => e.target !== e.currentTarget,\r\n    ctrl: e => !e.ctrlKey,\r\n    shift: e => !e.shiftKey,\r\n    alt: e => !e.altKey,\r\n    meta: e => !e.metaKey,\r\n    left: e => \'button\' in e && e.button !== 0,\r\n    middle: e => \'button\' in e && e.button !== 1,\r\n    right: e => \'button\' in e && e.button !== 2,\r\n    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withModifiers = (fn, modifiers) => {\r\n    return (event, ...args) => {\r\n        for (let i = 0; i < modifiers.length; i++) {\r\n            const guard = modifierGuards[modifiers[i]];\r\n            if (guard && guard(event, modifiers))\r\n                return;\r\n        }\r\n        return fn(event, ...args);\r\n    };\r\n};\r\n// Kept for 2.x compat.\r\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\r\nconst keyNames = {\r\n    esc: \'escape\',\r\n    space: \' \',\r\n    up: \'arrow-up\',\r\n    left: \'arrow-left\',\r\n    right: \'arrow-right\',\r\n    down: \'arrow-down\',\r\n    delete: \'backspace\'\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withKeys = (fn, modifiers) => {\r\n    return (event) => {\r\n        if (!(\'key\' in event))\r\n            return;\r\n        const eventKey = Object(shared_esm_bundler["m" /* hyphenate */])(event.key);\r\n        if (\r\n        // None of the provided key modifiers match the current event key\r\n        !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\r\n            return;\r\n        }\r\n        return fn(event);\r\n    };\r\n};\n\nconst vShow = {\r\n    beforeMount(el, { value }, { transition }) {\r\n        el._vod = el.style.display === \'none\' ? \'\' : el.style.display;\r\n        if (transition && value) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    mounted(el, { value }, { transition }) {\r\n        if (transition && value) {\r\n            transition.enter(el);\r\n        }\r\n    },\r\n    updated(el, { value, oldValue }, { transition }) {\r\n        if (!value === !oldValue)\r\n            return;\r\n        if (transition) {\r\n            if (value) {\r\n                transition.beforeEnter(el);\r\n                setDisplay(el, true);\r\n                transition.enter(el);\r\n            }\r\n            else {\r\n                transition.leave(el, () => {\r\n                    setDisplay(el, false);\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    beforeUnmount(el, { value }) {\r\n        setDisplay(el, value);\r\n    }\r\n};\r\nfunction setDisplay(el, value) {\r\n    el.style.display = value ? el._vod : \'none\';\r\n}\n\nconst rendererOptions = Object(shared_esm_bundler["i" /* extend */])({ patchProp: runtime_dom_esm_bundler_patchProp, forcePatchProp }, nodeOps);\r\n// lazy create the renderer - this makes core renderer logic tree-shakable\r\n// in case the user only imports reactivity utilities from Vue.\r\nlet renderer;\r\nlet enabledHydration = false;\r\nfunction ensureRenderer() {\r\n    return renderer || (renderer = createRenderer(rendererOptions));\r\n}\r\nfunction ensureHydrationRenderer() {\r\n    renderer = enabledHydration\r\n        ? renderer\r\n        : createHydrationRenderer(rendererOptions);\r\n    enabledHydration = true;\r\n    return renderer;\r\n}\r\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\r\nconst runtime_dom_esm_bundler_render = ((...args) => {\r\n    ensureRenderer().render(...args);\r\n});\r\nconst runtime_dom_esm_bundler_hydrate = ((...args) => {\r\n    ensureHydrationRenderer().hydrate(...args);\r\n});\r\nconst runtime_dom_esm_bundler_createApp = ((...args) => {\r\n    const app = ensureRenderer().createApp(...args);\r\n    if ((false)) {}\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (!container)\r\n            return;\r\n        const component = app._component;\r\n        if (!Object(shared_esm_bundler["p" /* isFunction */])(component) && !component.render && !component.template) {\r\n            component.template = container.innerHTML;\r\n        }\r\n        // clear content before mounting\r\n        container.innerHTML = \'\';\r\n        const proxy = mount(container);\r\n        if (container instanceof Element) {\r\n            container.removeAttribute(\'v-cloak\');\r\n            container.setAttribute(\'data-v-app\', \'\');\r\n        }\r\n        return proxy;\r\n    };\r\n    return app;\r\n});\r\nconst createSSRApp = ((...args) => {\r\n    const app = ensureHydrationRenderer().createApp(...args);\r\n    if ((false)) {}\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (container) {\r\n            return mount(container, true);\r\n        }\r\n    };\r\n    return app;\r\n});\r\nfunction injectNativeTagCheck(app) {\r\n    // Inject `isNativeTag`\r\n    // this is used for component name validation (dev only)\r\n    Object.defineProperty(app.config, \'isNativeTag\', {\r\n        value: (tag) => Object(shared_esm_bundler["r" /* isHTMLTag */])(tag) || Object(shared_esm_bundler["z" /* isSVGTag */])(tag),\r\n        writable: false\r\n    });\r\n}\r\n// dev only\r\nfunction injectCustomElementCheck(app) {\r\n    if (isRuntimeOnly()) {\r\n        const value = app.config.isCustomElement;\r\n        Object.defineProperty(app.config, \'isCustomElement\', {\r\n            get() {\r\n                return value;\r\n            },\r\n            set() {\r\n                warn(`The \\`isCustomElement\\` config option is only respected when using the runtime compiler.` +\r\n                    `If you are using the runtime-only build, \\`isCustomElement\\` must be passed to \\`@vue/compiler-dom\\` in the build setup instead` +\r\n                    `- for example, via the \\`compilerOptions\\` option in vue-loader: https://vue-loader.vuejs.org/options.html#compileroptions.`);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction normalizeContainer(container) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(container)) {\r\n        const res = document.querySelector(container);\r\n        if (false) {}\r\n        return res;\r\n    }\r\n    if (false) {}\r\n    return container;\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js\n\n\n\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\r\nfunction createCompilerError(code, loc, messages, additionalMessage) {\r\n    const msg =  false\r\n        ? undefined\r\n        : code;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    error.loc = loc;\r\n    return error;\r\n}\r\nconst errorMessages = {\r\n    // parse errors\r\n    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: \'Illegal comment.\',\r\n    [1 /* CDATA_IN_HTML_CONTENT */]: \'CDATA section is allowed only in XML context.\',\r\n    [2 /* DUPLICATE_ATTRIBUTE */]: \'Duplicate attribute.\',\r\n    [3 /* END_TAG_WITH_ATTRIBUTES */]: \'End tag cannot have attributes.\',\r\n    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal \'/\' in tags.",\r\n    [5 /* EOF_BEFORE_TAG_NAME */]: \'Unexpected EOF in tag.\',\r\n    [6 /* EOF_IN_CDATA */]: \'Unexpected EOF in CDATA section.\',\r\n    [7 /* EOF_IN_COMMENT */]: \'Unexpected EOF in comment.\',\r\n    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: \'Unexpected EOF in script.\',\r\n    [9 /* EOF_IN_TAG */]: \'Unexpected EOF in tag.\',\r\n    [10 /* INCORRECTLY_CLOSED_COMMENT */]: \'Incorrectly closed comment.\',\r\n    [11 /* INCORRECTLY_OPENED_COMMENT */]: \'Incorrectly opened comment.\',\r\n    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use \'&lt;\' to print \'<\'.",\r\n    [13 /* MISSING_ATTRIBUTE_VALUE */]: \'Attribute value was expected.\',\r\n    [14 /* MISSING_END_TAG_NAME */]: \'End tag name was expected.\',\r\n    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: \'Whitespace was expected.\',\r\n    [16 /* NESTED_COMMENT */]: "Unexpected \'\x3c!--\' in comment.",\r\n    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: \'Attribute name cannot contain U+0022 ("), U+0027 (\\\'), and U+003C (<).\',\r\n    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: \'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\\\'), U+003C (<), U+003D (=), and U+0060 (`).\',\r\n    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with \'=\'.",\r\n    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "\'<?\' is allowed only in XML context.",\r\n    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal \'/\' in tags.",\r\n    // Vue-specific parse errors\r\n    [23 /* X_INVALID_END_TAG */]: \'Invalid end tag.\',\r\n    [24 /* X_MISSING_END_TAG */]: \'Element is missing end tag.\',\r\n    [25 /* X_MISSING_INTERPOLATION_END */]: \'Interpolation end sign was not found.\',\r\n    [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: \'End bracket for dynamic directive argument was not found. \' +\r\n        \'Note that dynamic directive argument cannot contain spaces.\',\r\n    // transform errors\r\n    [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\r\n    [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\r\n    [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,\r\n    [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\r\n    [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\r\n    [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\r\n    [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\r\n    [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\r\n    [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\r\n    [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +\r\n        `When there are multiple named slots, all slots should use <template> ` +\r\n        `syntax to avoid scope ambiguity.`,\r\n    [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\r\n    [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +\r\n        `default slot. These children will be ignored.`,\r\n    [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\r\n    [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\r\n    [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\r\n    [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n    [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\r\n    [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\r\n    // generic errors\r\n    [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,\r\n    [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\r\n    [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,\r\n    [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`\r\n};\n\nconst FRAGMENT = Symbol(( false) ? undefined : ``);\r\nconst TELEPORT = Symbol(( false) ? undefined : ``);\r\nconst SUSPENSE = Symbol(( false) ? undefined : ``);\r\nconst KEEP_ALIVE = Symbol(( false) ? undefined : ``);\r\nconst BASE_TRANSITION = Symbol(( false) ? undefined : ``);\r\nconst OPEN_BLOCK = Symbol(( false) ? undefined : ``);\r\nconst CREATE_BLOCK = Symbol(( false) ? undefined : ``);\r\nconst CREATE_VNODE = Symbol(( false) ? undefined : ``);\r\nconst CREATE_COMMENT = Symbol(( false) ? undefined : ``);\r\nconst CREATE_TEXT = Symbol(( false) ? undefined : ``);\r\nconst CREATE_STATIC = Symbol(( false) ? undefined : ``);\r\nconst RESOLVE_COMPONENT = Symbol(( false) ? undefined : ``);\r\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol(( false) ? undefined : ``);\r\nconst RESOLVE_DIRECTIVE = Symbol(( false) ? undefined : ``);\r\nconst WITH_DIRECTIVES = Symbol(( false) ? undefined : ``);\r\nconst RENDER_LIST = Symbol(( false) ? undefined : ``);\r\nconst RENDER_SLOT = Symbol(( false) ? undefined : ``);\r\nconst CREATE_SLOTS = Symbol(( false) ? undefined : ``);\r\nconst TO_DISPLAY_STRING = Symbol(( false) ? undefined : ``);\r\nconst MERGE_PROPS = Symbol(( false) ? undefined : ``);\r\nconst TO_HANDLERS = Symbol(( false) ? undefined : ``);\r\nconst CAMELIZE = Symbol(( false) ? undefined : ``);\r\nconst CAPITALIZE = Symbol(( false) ? undefined : ``);\r\nconst TO_HANDLER_KEY = Symbol(( false) ? undefined : ``);\r\nconst SET_BLOCK_TRACKING = Symbol(( false) ? undefined : ``);\r\nconst PUSH_SCOPE_ID = Symbol(( false) ? undefined : ``);\r\nconst POP_SCOPE_ID = Symbol(( false) ? undefined : ``);\r\nconst WITH_SCOPE_ID = Symbol(( false) ? undefined : ``);\r\nconst WITH_CTX = Symbol(( false) ? undefined : ``);\r\nconst UNREF = Symbol(( false) ? undefined : ``);\r\nconst IS_REF = Symbol(( false) ? undefined : ``);\r\n// Name mapping for runtime helpers that need to be imported from \'vue\' in\r\n// generated code. Make sure these are correctly exported in the runtime!\r\n// Using `any` here because TS doesn\'t allow symbols as index type.\r\nconst helperNameMap = {\r\n    [FRAGMENT]: `Fragment`,\r\n    [TELEPORT]: `Teleport`,\r\n    [SUSPENSE]: `Suspense`,\r\n    [KEEP_ALIVE]: `KeepAlive`,\r\n    [BASE_TRANSITION]: `BaseTransition`,\r\n    [OPEN_BLOCK]: `openBlock`,\r\n    [CREATE_BLOCK]: `createBlock`,\r\n    [CREATE_VNODE]: `createVNode`,\r\n    [CREATE_COMMENT]: `createCommentVNode`,\r\n    [CREATE_TEXT]: `createTextVNode`,\r\n    [CREATE_STATIC]: `createStaticVNode`,\r\n    [RESOLVE_COMPONENT]: `resolveComponent`,\r\n    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n    [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n    [WITH_DIRECTIVES]: `withDirectives`,\r\n    [RENDER_LIST]: `renderList`,\r\n    [RENDER_SLOT]: `renderSlot`,\r\n    [CREATE_SLOTS]: `createSlots`,\r\n    [TO_DISPLAY_STRING]: `toDisplayString`,\r\n    [MERGE_PROPS]: `mergeProps`,\r\n    [TO_HANDLERS]: `toHandlers`,\r\n    [CAMELIZE]: `camelize`,\r\n    [CAPITALIZE]: `capitalize`,\r\n    [TO_HANDLER_KEY]: `toHandlerKey`,\r\n    [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n    [PUSH_SCOPE_ID]: `pushScopeId`,\r\n    [POP_SCOPE_ID]: `popScopeId`,\r\n    [WITH_SCOPE_ID]: `withScopeId`,\r\n    [WITH_CTX]: `withCtx`,\r\n    [UNREF]: `unref`,\r\n    [IS_REF]: `isRef`\r\n};\r\nfunction registerRuntimeHelpers(helpers) {\r\n    Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n        helperNameMap[s] = helpers[s];\r\n    });\r\n}\n\n// AST Utilities ---------------------------------------------------------------\r\n// Some expressions, e.g. sequence and conditional expressions, are never\r\n// associated with template nodes, so their source locations are just a stub.\r\n// Container types like CompoundExpression also don\'t need a real location.\r\nconst locStub = {\r\n    source: \'\',\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createRoot(children, loc = locStub) {\r\n    return {\r\n        type: 0 /* ROOT */,\r\n        children,\r\n        helpers: [],\r\n        components: [],\r\n        directives: [],\r\n        hoists: [],\r\n        imports: [],\r\n        cached: 0,\r\n        temps: 0,\r\n        codegenNode: undefined,\r\n        loc\r\n    };\r\n}\r\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {\r\n    if (context) {\r\n        if (isBlock) {\r\n            context.helper(OPEN_BLOCK);\r\n            context.helper(CREATE_BLOCK);\r\n        }\r\n        else {\r\n            context.helper(CREATE_VNODE);\r\n        }\r\n        if (directives) {\r\n            context.helper(WITH_DIRECTIVES);\r\n        }\r\n    }\r\n    return {\r\n        type: 13 /* VNODE_CALL */,\r\n        tag,\r\n        props,\r\n        children,\r\n        patchFlag,\r\n        dynamicProps,\r\n        directives,\r\n        isBlock,\r\n        disableTracking,\r\n        loc\r\n    };\r\n}\r\nfunction createArrayExpression(elements, loc = locStub) {\r\n    return {\r\n        type: 17 /* JS_ARRAY_EXPRESSION */,\r\n        loc,\r\n        elements\r\n    };\r\n}\r\nfunction createObjectExpression(properties, loc = locStub) {\r\n    return {\r\n        type: 15 /* JS_OBJECT_EXPRESSION */,\r\n        loc,\r\n        properties\r\n    };\r\n}\r\nfunction createObjectProperty(key, value) {\r\n    return {\r\n        type: 16 /* JS_PROPERTY */,\r\n        loc: locStub,\r\n        key: Object(shared_esm_bundler["C" /* isString */])(key) ? createSimpleExpression(key, true) : key,\r\n        value\r\n    };\r\n}\r\nfunction createSimpleExpression(content, isStatic, loc = locStub, constType = 0 /* NOT_CONSTANT */) {\r\n    return {\r\n        type: 4 /* SIMPLE_EXPRESSION */,\r\n        loc,\r\n        content,\r\n        isStatic,\r\n        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType\r\n    };\r\n}\r\nfunction createInterpolation(content, loc) {\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        loc,\r\n        content: Object(shared_esm_bundler["C" /* isString */])(content)\r\n            ? createSimpleExpression(content, false, loc)\r\n            : content\r\n    };\r\n}\r\nfunction createCompoundExpression(children, loc = locStub) {\r\n    return {\r\n        type: 8 /* COMPOUND_EXPRESSION */,\r\n        loc,\r\n        children\r\n    };\r\n}\r\nfunction createCallExpression(callee, args = [], loc = locStub) {\r\n    return {\r\n        type: 14 /* JS_CALL_EXPRESSION */,\r\n        loc,\r\n        callee,\r\n        arguments: args\r\n    };\r\n}\r\nfunction createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {\r\n    return {\r\n        type: 18 /* JS_FUNCTION_EXPRESSION */,\r\n        params,\r\n        returns,\r\n        newline,\r\n        isSlot,\r\n        loc\r\n    };\r\n}\r\nfunction createConditionalExpression(test, consequent, alternate, newline = true) {\r\n    return {\r\n        type: 19 /* JS_CONDITIONAL_EXPRESSION */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        newline,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createCacheExpression(index, value, isVNode = false) {\r\n    return {\r\n        type: 20 /* JS_CACHE_EXPRESSION */,\r\n        index,\r\n        value,\r\n        isVNode,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createBlockStatement(body) {\r\n    return {\r\n        type: 21 /* JS_BLOCK_STATEMENT */,\r\n        body,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createTemplateLiteral(elements) {\r\n    return {\r\n        type: 22 /* JS_TEMPLATE_LITERAL */,\r\n        elements,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createIfStatement(test, consequent, alternate) {\r\n    return {\r\n        type: 23 /* JS_IF_STATEMENT */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createAssignmentExpression(left, right) {\r\n    return {\r\n        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,\r\n        left,\r\n        right,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createSequenceExpression(expressions) {\r\n    return {\r\n        type: 25 /* JS_SEQUENCE_EXPRESSION */,\r\n        expressions,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createReturnStatement(returns) {\r\n    return {\r\n        type: 26 /* JS_RETURN_STATEMENT */,\r\n        returns,\r\n        loc: locStub\r\n    };\r\n}\n\nconst isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;\r\nconst isBuiltInType = (tag, expected) => tag === expected || tag === Object(shared_esm_bundler["m" /* hyphenate */])(expected);\r\nfunction isCoreComponent(tag) {\r\n    if (isBuiltInType(tag, \'Teleport\')) {\r\n        return TELEPORT;\r\n    }\r\n    else if (isBuiltInType(tag, \'Suspense\')) {\r\n        return SUSPENSE;\r\n    }\r\n    else if (isBuiltInType(tag, \'KeepAlive\')) {\r\n        return KEEP_ALIVE;\r\n    }\r\n    else if (isBuiltInType(tag, \'BaseTransition\')) {\r\n        return BASE_TRANSITION;\r\n    }\r\n}\r\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/;\r\nconst isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\r\nconst memberExpRE = /^[A-Za-z_$][\\w$]*(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/;\r\nconst isMemberExpression = (path) => {\r\n    if (!path)\r\n        return false;\r\n    return memberExpRE.test(path.trim());\r\n};\r\nfunction getInnerRange(loc, offset, length) {\r\n    const source = loc.source.substr(offset, length);\r\n    const newLoc = {\r\n        source,\r\n        start: advancePositionWithClone(loc.start, loc.source, offset),\r\n        end: loc.end\r\n    };\r\n    if (length != null) {\r\n        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\r\n    }\r\n    return newLoc;\r\n}\r\nfunction advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\r\n    return advancePositionWithMutation(Object(shared_esm_bundler["i" /* extend */])({}, pos), source, numberOfCharacters);\r\n}\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nfunction advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\r\n    let linesCount = 0;\r\n    let lastNewLinePos = -1;\r\n    for (let i = 0; i < numberOfCharacters; i++) {\r\n        if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n            linesCount++;\r\n            lastNewLinePos = i;\r\n        }\r\n    }\r\n    pos.offset += numberOfCharacters;\r\n    pos.line += linesCount;\r\n    pos.column =\r\n        lastNewLinePos === -1\r\n            ? pos.column + numberOfCharacters\r\n            : numberOfCharacters - lastNewLinePos;\r\n    return pos;\r\n}\r\nfunction assert(condition, msg) {\r\n    /* istanbul ignore if */\r\n    if (!condition) {\r\n        throw new Error(msg || `unexpected compiler condition`);\r\n    }\r\n}\r\nfunction findDir(node, name, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 7 /* DIRECTIVE */ &&\r\n            (allowEmpty || p.exp) &&\r\n            (Object(shared_esm_bundler["C" /* isString */])(name) ? p.name === name : name.test(p.name))) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction findProp(node, name, dynamicOnly = false, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (dynamicOnly)\r\n                continue;\r\n            if (p.name === name && (p.value || allowEmpty)) {\r\n                return p;\r\n            }\r\n        }\r\n        else if (p.name === \'bind\' &&\r\n            (p.exp || allowEmpty) &&\r\n            isBindKey(p.arg, name)) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction isBindKey(arg, name) {\r\n    return !!(arg && isStaticExp(arg) && arg.content === name);\r\n}\r\nfunction hasDynamicKeyVBind(node) {\r\n    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&\r\n        p.name === \'bind\' &&\r\n        (!p.arg || // v-bind="obj"\r\n            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]\r\n            !p.arg.isStatic) // v-bind:[foo]\r\n    );\r\n}\r\nfunction isText(node) {\r\n    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;\r\n}\r\nfunction isVSlot(p) {\r\n    return p.type === 7 /* DIRECTIVE */ && p.name === \'slot\';\r\n}\r\nfunction isTemplateNode(node) {\r\n    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);\r\n}\r\nfunction isSlotOutlet(node) {\r\n    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;\r\n}\r\nfunction injectProp(node, prop, context) {\r\n    let propsWithInjection;\r\n    const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];\r\n    if (props == null || Object(shared_esm_bundler["C" /* isString */])(props)) {\r\n        propsWithInjection = createObjectExpression([prop]);\r\n    }\r\n    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n        // merged props... add ours\r\n        // only inject key to object literal if it\'s the first argument so that\r\n        // if doesn\'t override user provided keys\r\n        const first = props.arguments[0];\r\n        if (!Object(shared_esm_bundler["C" /* isString */])(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n            first.properties.unshift(prop);\r\n        }\r\n        else {\r\n            if (props.callee === TO_HANDLERS) {\r\n                // #2366\r\n                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n                    createObjectExpression([prop]),\r\n                    props\r\n                ]);\r\n            }\r\n            else {\r\n                props.arguments.unshift(createObjectExpression([prop]));\r\n            }\r\n        }\r\n        !propsWithInjection && (propsWithInjection = props);\r\n    }\r\n    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        let alreadyExists = false;\r\n        // check existing key to avoid overriding user provided keys\r\n        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            const propKeyName = prop.key.content;\r\n            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                p.key.content === propKeyName);\r\n        }\r\n        if (!alreadyExists) {\r\n            props.properties.unshift(prop);\r\n        }\r\n        propsWithInjection = props;\r\n    }\r\n    else {\r\n        // single v-bind with expression, return a merged replacement\r\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n            createObjectExpression([prop]),\r\n            props\r\n        ]);\r\n    }\r\n    if (node.type === 13 /* VNODE_CALL */) {\r\n        node.props = propsWithInjection;\r\n    }\r\n    else {\r\n        node.arguments[2] = propsWithInjection;\r\n    }\r\n}\r\nfunction toValidAssetId(name, type) {\r\n    return `_${type}_${name.replace(/[^\\w]/g, \'_\')}`;\r\n}\r\n// Check if a node contains expressions that reference current context scope ids\r\nfunction hasScopeRef(node, ids) {\r\n    if (!node || Object.keys(ids).length === 0) {\r\n        return false;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            for (let i = 0; i < node.props.length; i++) {\r\n                const p = node.props[i];\r\n                if (p.type === 7 /* DIRECTIVE */ &&\r\n                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\r\n                    return true;\r\n                }\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 11 /* FOR */:\r\n            if (hasScopeRef(node.source, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 9 /* IF */:\r\n            return node.branches.some(b => hasScopeRef(b, ids));\r\n        case 10 /* IF_BRANCH */:\r\n            if (hasScopeRef(node.condition, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return (!node.isStatic &&\r\n                isSimpleIdentifier(node.content) &&\r\n                !!ids[node.content]);\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            return node.children.some(c => Object(shared_esm_bundler["v" /* isObject */])(c) && hasScopeRef(c, ids));\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return hasScopeRef(node.content, ids);\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return false;\r\n        default:\r\n            if ((false)) {}\r\n            return false;\r\n    }\r\n}\n\n// The default decoder only provides escapes for characters reserved as part of\r\n// the template syntax, and is only used if the custom renderer did not provide\r\n// a platform-specific decoder.\r\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g;\r\nconst decodeMap = {\r\n    gt: \'>\',\r\n    lt: \'<\',\r\n    amp: \'&\',\r\n    apos: "\'",\r\n    quot: \'"\'\r\n};\r\nconst defaultParserOptions = {\r\n    delimiters: [`{{`, `}}`],\r\n    getNamespace: () => 0 /* HTML */,\r\n    getTextMode: () => 0 /* DATA */,\r\n    isVoidTag: shared_esm_bundler["c" /* NO */],\r\n    isPreTag: shared_esm_bundler["c" /* NO */],\r\n    isCustomElement: shared_esm_bundler["c" /* NO */],\r\n    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\r\n    onError: defaultOnError,\r\n    comments: false\r\n};\r\nfunction baseParse(content, options = {}) {\r\n    const context = createParserContext(content, options);\r\n    const start = getCursor(context);\r\n    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));\r\n}\r\nfunction createParserContext(content, rawOptions) {\r\n    const options = Object(shared_esm_bundler["i" /* extend */])({}, defaultParserOptions);\r\n    for (const key in rawOptions) {\r\n        // @ts-ignore\r\n        options[key] = rawOptions[key] || defaultParserOptions[key];\r\n    }\r\n    return {\r\n        options,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        originalSource: content,\r\n        source: content,\r\n        inPre: false,\r\n        inVPre: false\r\n    };\r\n}\r\nfunction parseChildren(context, mode, ancestors) {\r\n    const parent = last(ancestors);\r\n    const ns = parent ? parent.ns : 0 /* HTML */;\r\n    const nodes = [];\r\n    while (!isEnd(context, mode, ancestors)) {\r\n        const s = context.source;\r\n        let node = undefined;\r\n        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {\r\n            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\r\n                // \'{{\'\r\n                node = parseInterpolation(context, mode);\r\n            }\r\n            else if (mode === 0 /* DATA */ && s[0] === \'<\') {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n                if (s.length === 1) {\r\n                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);\r\n                }\r\n                else if (s[1] === \'!\') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n                    if (startsWith(s, \'\x3c!--\')) {\r\n                        node = parseComment(context);\r\n                    }\r\n                    else if (startsWith(s, \'<!DOCTYPE\')) {\r\n                        // Ignore DOCTYPE by a limitation.\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                    else if (startsWith(s, \'<![CDATA[\')) {\r\n                        if (ns !== 0 /* HTML */) {\r\n                            node = parseCDATA(context, ancestors);\r\n                        }\r\n                        else {\r\n                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);\r\n                            node = parseBogusComment(context);\r\n                        }\r\n                    }\r\n                    else {\r\n                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (s[1] === \'/\') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n                    if (s.length === 2) {\r\n                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);\r\n                    }\r\n                    else if (s[2] === \'>\') {\r\n                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);\r\n                        advanceBy(context, 3);\r\n                        continue;\r\n                    }\r\n                    else if (/[a-z]/i.test(s[2])) {\r\n                        emitError(context, 23 /* X_INVALID_END_TAG */);\r\n                        parseTag(context, 1 /* End */, parent);\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (/[a-z]/i.test(s[1])) {\r\n                    node = parseElement(context, ancestors);\r\n                }\r\n                else if (s[1] === \'?\') {\r\n                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\r\n                    node = parseBogusComment(context);\r\n                }\r\n                else {\r\n                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\r\n                }\r\n            }\r\n        }\r\n        if (!node) {\r\n            node = parseText(context, mode);\r\n        }\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(node)) {\r\n            for (let i = 0; i < node.length; i++) {\r\n                pushNode(nodes, node[i]);\r\n            }\r\n        }\r\n        else {\r\n            pushNode(nodes, node);\r\n        }\r\n    }\r\n    // Whitespace management for more efficient output\r\n    // (same as v2 whitespace: \'condense\')\r\n    let removedWhitespace = false;\r\n    if (mode !== 2 /* RAWTEXT */) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            if (!context.inPre && node.type === 2 /* TEXT */) {\r\n                if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n                    const prev = nodes[i - 1];\r\n                    const next = nodes[i + 1];\r\n                    // If:\r\n                    // - the whitespace is the first or last node, or:\r\n                    // - the whitespace is adjacent to a comment, or:\r\n                    // - the whitespace is between two elements AND contains newline\r\n                    // Then the whitespace is ignored.\r\n                    if (!prev ||\r\n                        !next ||\r\n                        prev.type === 3 /* COMMENT */ ||\r\n                        next.type === 3 /* COMMENT */ ||\r\n                        (prev.type === 1 /* ELEMENT */ &&\r\n                            next.type === 1 /* ELEMENT */ &&\r\n                            /[\\r\\n]/.test(node.content))) {\r\n                        removedWhitespace = true;\r\n                        nodes[i] = null;\r\n                    }\r\n                    else {\r\n                        // Otherwise, condensed consecutive whitespace inside the text\r\n                        // down to a single space\r\n                        node.content = \' \';\r\n                    }\r\n                }\r\n                else {\r\n                    node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, \' \');\r\n                }\r\n            }\r\n            // also remove comment nodes in prod by default\r\n            if ( true &&\r\n                node.type === 3 /* COMMENT */ &&\r\n                !context.options.comments) {\r\n                removedWhitespace = true;\r\n                nodes[i] = null;\r\n            }\r\n        }\r\n        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\r\n            // remove leading newline per html spec\r\n            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n            const first = nodes[0];\r\n            if (first && first.type === 2 /* TEXT */) {\r\n                first.content = first.content.replace(/^\\r?\\n/, \'\');\r\n            }\r\n        }\r\n    }\r\n    return removedWhitespace ? nodes.filter(Boolean) : nodes;\r\n}\r\nfunction pushNode(nodes, node) {\r\n    if (node.type === 2 /* TEXT */) {\r\n        const prev = last(nodes);\r\n        // Merge if both this and the previous node are text and those are\r\n        // consecutive. This happens for cases like "a < b".\r\n        if (prev &&\r\n            prev.type === 2 /* TEXT */ &&\r\n            prev.loc.end.offset === node.loc.start.offset) {\r\n            prev.content += node.content;\r\n            prev.loc.end = node.loc.end;\r\n            prev.loc.source += node.loc.source;\r\n            return;\r\n        }\r\n    }\r\n    nodes.push(node);\r\n}\r\nfunction parseCDATA(context, ancestors) {\r\n    advanceBy(context, 9);\r\n    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);\r\n    if (context.source.length === 0) {\r\n        emitError(context, 6 /* EOF_IN_CDATA */);\r\n    }\r\n    else {\r\n        advanceBy(context, 3);\r\n    }\r\n    return nodes;\r\n}\r\nfunction parseComment(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    // Regular comment.\r\n    const match = /--(\\!)?>/.exec(context.source);\r\n    if (!match) {\r\n        content = context.source.slice(4);\r\n        advanceBy(context, context.source.length);\r\n        emitError(context, 7 /* EOF_IN_COMMENT */);\r\n    }\r\n    else {\r\n        if (match.index <= 3) {\r\n            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\r\n        }\r\n        if (match[1]) {\r\n            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);\r\n        }\r\n        content = context.source.slice(4, match.index);\r\n        // Advancing with reporting nested comments.\r\n        const s = context.source.slice(0, match.index);\r\n        let prevIndex = 1, nestedIndex = 0;\r\n        while ((nestedIndex = s.indexOf(\'\x3c!--\', prevIndex)) !== -1) {\r\n            advanceBy(context, nestedIndex - prevIndex + 1);\r\n            if (nestedIndex + 4 < s.length) {\r\n                emitError(context, 16 /* NESTED_COMMENT */);\r\n            }\r\n            prevIndex = nestedIndex + 1;\r\n        }\r\n        advanceBy(context, match.index + match[0].length - prevIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseBogusComment(context) {\r\n    const start = getCursor(context);\r\n    const contentStart = context.source[1] === \'?\' ? 1 : 2;\r\n    let content;\r\n    const closeIndex = context.source.indexOf(\'>\');\r\n    if (closeIndex === -1) {\r\n        content = context.source.slice(contentStart);\r\n        advanceBy(context, context.source.length);\r\n    }\r\n    else {\r\n        content = context.source.slice(contentStart, closeIndex);\r\n        advanceBy(context, closeIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseElement(context, ancestors) {\r\n    // Start tag.\r\n    const wasInPre = context.inPre;\r\n    const wasInVPre = context.inVPre;\r\n    const parent = last(ancestors);\r\n    const element = parseTag(context, 0 /* Start */, parent);\r\n    const isPreBoundary = context.inPre && !wasInPre;\r\n    const isVPreBoundary = context.inVPre && !wasInVPre;\r\n    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n        return element;\r\n    }\r\n    // Children.\r\n    ancestors.push(element);\r\n    const mode = context.options.getTextMode(element, parent);\r\n    const children = parseChildren(context, mode, ancestors);\r\n    ancestors.pop();\r\n    element.children = children;\r\n    // End tag.\r\n    if (startsWithEndTagOpen(context.source, element.tag)) {\r\n        parseTag(context, 1 /* End */, parent);\r\n    }\r\n    else {\r\n        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);\r\n        if (context.source.length === 0 && element.tag.toLowerCase() === \'script\') {\r\n            const first = children[0];\r\n            if (first && startsWith(first.loc.source, \'\x3c!--\')) {\r\n                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\r\n            }\r\n        }\r\n    }\r\n    element.loc = getSelection(context, element.loc.start);\r\n    if (isPreBoundary) {\r\n        context.inPre = false;\r\n    }\r\n    if (isVPreBoundary) {\r\n        context.inVPre = false;\r\n    }\r\n    return element;\r\n}\r\nconst isSpecialTemplateDirective = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`if,else,else-if,for,slot`);\r\n/**\r\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\r\n */\r\nfunction parseTag(context, type, parent) {\r\n    // Tag open.\r\n    const start = getCursor(context);\r\n    const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\r\n    const tag = match[1];\r\n    const ns = context.options.getNamespace(tag, parent);\r\n    advanceBy(context, match[0].length);\r\n    advanceSpaces(context);\r\n    // save current state in case we need to re-parse attributes with v-pre\r\n    const cursor = getCursor(context);\r\n    const currentSource = context.source;\r\n    // Attributes.\r\n    let props = parseAttributes(context, type);\r\n    // check <pre> tag\r\n    if (context.options.isPreTag(tag)) {\r\n        context.inPre = true;\r\n    }\r\n    // check v-pre\r\n    if (!context.inVPre &&\r\n        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === \'pre\')) {\r\n        context.inVPre = true;\r\n        // reset context\r\n        Object(shared_esm_bundler["i" /* extend */])(context, cursor);\r\n        context.source = currentSource;\r\n        // re-parse attrs and filter out v-pre itself\r\n        props = parseAttributes(context, type).filter(p => p.name !== \'v-pre\');\r\n    }\r\n    // Tag close.\r\n    let isSelfClosing = false;\r\n    if (context.source.length === 0) {\r\n        emitError(context, 9 /* EOF_IN_TAG */);\r\n    }\r\n    else {\r\n        isSelfClosing = startsWith(context.source, \'/>\');\r\n        if (type === 1 /* End */ && isSelfClosing) {\r\n            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);\r\n        }\r\n        advanceBy(context, isSelfClosing ? 2 : 1);\r\n    }\r\n    let tagType = 0 /* ELEMENT */;\r\n    const options = context.options;\r\n    if (!context.inVPre && !options.isCustomElement(tag)) {\r\n        const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === \'is\');\r\n        if (options.isNativeTag && !hasVIs) {\r\n            if (!options.isNativeTag(tag))\r\n                tagType = 1 /* COMPONENT */;\r\n        }\r\n        else if (hasVIs ||\r\n            isCoreComponent(tag) ||\r\n            (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\r\n            /^[A-Z]/.test(tag) ||\r\n            tag === \'component\') {\r\n            tagType = 1 /* COMPONENT */;\r\n        }\r\n        if (tag === \'slot\') {\r\n            tagType = 2 /* SLOT */;\r\n        }\r\n        else if (tag === \'template\' &&\r\n            props.some(p => {\r\n                return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));\r\n            })) {\r\n            tagType = 3 /* TEMPLATE */;\r\n        }\r\n    }\r\n    return {\r\n        type: 1 /* ELEMENT */,\r\n        ns,\r\n        tag,\r\n        tagType,\r\n        props,\r\n        isSelfClosing,\r\n        children: [],\r\n        loc: getSelection(context, start),\r\n        codegenNode: undefined // to be created during transform phase\r\n    };\r\n}\r\nfunction parseAttributes(context, type) {\r\n    const props = [];\r\n    const attributeNames = new Set();\r\n    while (context.source.length > 0 &&\r\n        !startsWith(context.source, \'>\') &&\r\n        !startsWith(context.source, \'/>\')) {\r\n        if (startsWith(context.source, \'/\')) {\r\n            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);\r\n            advanceBy(context, 1);\r\n            advanceSpaces(context);\r\n            continue;\r\n        }\r\n        if (type === 1 /* End */) {\r\n            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);\r\n        }\r\n        const attr = parseAttribute(context, attributeNames);\r\n        if (type === 0 /* Start */) {\r\n            props.push(attr);\r\n        }\r\n        if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\r\n        }\r\n        advanceSpaces(context);\r\n    }\r\n    return props;\r\n}\r\nfunction parseAttribute(context, nameSet) {\r\n    // Name.\r\n    const start = getCursor(context);\r\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\r\n    const name = match[0];\r\n    if (nameSet.has(name)) {\r\n        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);\r\n    }\r\n    nameSet.add(name);\r\n    if (name[0] === \'=\') {\r\n        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\r\n    }\r\n    {\r\n        const pattern = /["\'<]/g;\r\n        let m;\r\n        while ((m = pattern.exec(name))) {\r\n            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\r\n        }\r\n    }\r\n    advanceBy(context, name.length);\r\n    // Value\r\n    let value = undefined;\r\n    if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n        advanceSpaces(context);\r\n        advanceBy(context, 1);\r\n        advanceSpaces(context);\r\n        value = parseAttributeValue(context);\r\n        if (!value) {\r\n            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);\r\n        }\r\n    }\r\n    const loc = getSelection(context, start);\r\n    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {\r\n        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\r\n        const dirName = match[1] ||\r\n            (startsWith(name, \':\') ? \'bind\' : startsWith(name, \'@\') ? \'on\' : \'slot\');\r\n        let arg;\r\n        if (match[2]) {\r\n            const isSlot = dirName === \'slot\';\r\n            const startOffset = name.indexOf(match[2]);\r\n            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || \'\').length));\r\n            let content = match[2];\r\n            let isStatic = true;\r\n            if (content.startsWith(\'[\')) {\r\n                isStatic = false;\r\n                if (!content.endsWith(\']\')) {\r\n                    emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\r\n                }\r\n                content = content.substr(1, content.length - 2);\r\n            }\r\n            else if (isSlot) {\r\n                // #1241 special case for v-slot: vuetify relies extensively on slot\r\n                // names containing dots. v-slot doesn\'t have any modifiers and Vue 2.x\r\n                // supports such usage so we are keeping it consistent with 2.x.\r\n                content += match[3] || \'\';\r\n            }\r\n            arg = {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content,\r\n                isStatic,\r\n                constType: isStatic\r\n                    ? 3 /* CAN_STRINGIFY */\r\n                    : 0 /* NOT_CONSTANT */,\r\n                loc\r\n            };\r\n        }\r\n        if (value && value.isQuoted) {\r\n            const valueLoc = value.loc;\r\n            valueLoc.start.offset++;\r\n            valueLoc.start.column++;\r\n            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\r\n            valueLoc.source = valueLoc.source.slice(1, -1);\r\n        }\r\n        return {\r\n            type: 7 /* DIRECTIVE */,\r\n            name: dirName,\r\n            exp: value && {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content: value.content,\r\n                isStatic: false,\r\n                // Treat as non-constant by default. This can be potentially set to\r\n                // other values by `transformExpression` to make it eligible for hoisting.\r\n                constType: 0 /* NOT_CONSTANT */,\r\n                loc: value.loc\r\n            },\r\n            arg,\r\n            modifiers: match[3] ? match[3].substr(1).split(\'.\') : [],\r\n            loc\r\n        };\r\n    }\r\n    return {\r\n        type: 6 /* ATTRIBUTE */,\r\n        name,\r\n        value: value && {\r\n            type: 2 /* TEXT */,\r\n            content: value.content,\r\n            loc: value.loc\r\n        },\r\n        loc\r\n    };\r\n}\r\nfunction parseAttributeValue(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    const quote = context.source[0];\r\n    const isQuoted = quote === `"` || quote === `\'`;\r\n    if (isQuoted) {\r\n        // Quoted value.\r\n        advanceBy(context, 1);\r\n        const endIndex = context.source.indexOf(quote);\r\n        if (endIndex === -1) {\r\n            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);\r\n        }\r\n        else {\r\n            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);\r\n            advanceBy(context, 1);\r\n        }\r\n    }\r\n    else {\r\n        // Unquoted\r\n        const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\r\n        if (!match) {\r\n            return undefined;\r\n        }\r\n        const unexpectedChars = /["\'<=`]/g;\r\n        let m;\r\n        while ((m = unexpectedChars.exec(match[0]))) {\r\n            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\r\n        }\r\n        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n    return { content, isQuoted, loc: getSelection(context, start) };\r\n}\r\nfunction parseInterpolation(context, mode) {\r\n    const [open, close] = context.options.delimiters;\r\n    const closeIndex = context.source.indexOf(close, open.length);\r\n    if (closeIndex === -1) {\r\n        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);\r\n        return undefined;\r\n    }\r\n    const start = getCursor(context);\r\n    advanceBy(context, open.length);\r\n    const innerStart = getCursor(context);\r\n    const innerEnd = getCursor(context);\r\n    const rawContentLength = closeIndex - open.length;\r\n    const rawContent = context.source.slice(0, rawContentLength);\r\n    const preTrimContent = parseTextData(context, rawContentLength, mode);\r\n    const content = preTrimContent.trim();\r\n    const startOffset = preTrimContent.indexOf(content);\r\n    if (startOffset > 0) {\r\n        advancePositionWithMutation(innerStart, rawContent, startOffset);\r\n    }\r\n    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\r\n    advancePositionWithMutation(innerEnd, rawContent, endOffset);\r\n    advanceBy(context, close.length);\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        content: {\r\n            type: 4 /* SIMPLE_EXPRESSION */,\r\n            isStatic: false,\r\n            // Set `isConstant` to false by default and will decide in transformExpression\r\n            constType: 0 /* NOT_CONSTANT */,\r\n            content,\r\n            loc: getSelection(context, innerStart, innerEnd)\r\n        },\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseText(context, mode) {\r\n    const endTokens = [\'<\', context.options.delimiters[0]];\r\n    if (mode === 3 /* CDATA */) {\r\n        endTokens.push(\']]>\');\r\n    }\r\n    let endIndex = context.source.length;\r\n    for (let i = 0; i < endTokens.length; i++) {\r\n        const index = context.source.indexOf(endTokens[i], 1);\r\n        if (index !== -1 && endIndex > index) {\r\n            endIndex = index;\r\n        }\r\n    }\r\n    const start = getCursor(context);\r\n    const content = parseTextData(context, endIndex, mode);\r\n    return {\r\n        type: 2 /* TEXT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\n/**\r\n * Get text data with a given length from the current location.\r\n * This translates HTML entities in the text data.\r\n */\r\nfunction parseTextData(context, length, mode) {\r\n    const rawText = context.source.slice(0, length);\r\n    advanceBy(context, length);\r\n    if (mode === 2 /* RAWTEXT */ ||\r\n        mode === 3 /* CDATA */ ||\r\n        rawText.indexOf(\'&\') === -1) {\r\n        return rawText;\r\n    }\r\n    else {\r\n        // DATA or RCDATA containing "&"". Entity decoding required.\r\n        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n}\r\nfunction getCursor(context) {\r\n    const { column, line, offset } = context;\r\n    return { column, line, offset };\r\n}\r\nfunction getSelection(context, start, end) {\r\n    end = end || getCursor(context);\r\n    return {\r\n        start,\r\n        end,\r\n        source: context.originalSource.slice(start.offset, end.offset)\r\n    };\r\n}\r\nfunction last(xs) {\r\n    return xs[xs.length - 1];\r\n}\r\nfunction startsWith(source, searchString) {\r\n    return source.startsWith(searchString);\r\n}\r\nfunction advanceBy(context, numberOfCharacters) {\r\n    const { source } = context;\r\n    advancePositionWithMutation(context, source, numberOfCharacters);\r\n    context.source = source.slice(numberOfCharacters);\r\n}\r\nfunction advanceSpaces(context) {\r\n    const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\r\n    if (match) {\r\n        advanceBy(context, match[0].length);\r\n    }\r\n}\r\nfunction getNewPosition(context, start, numberOfCharacters) {\r\n    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\r\n}\r\nfunction emitError(context, code, offset, loc = getCursor(context)) {\r\n    if (offset) {\r\n        loc.offset += offset;\r\n        loc.column += offset;\r\n    }\r\n    context.options.onError(createCompilerError(code, {\r\n        start: loc,\r\n        end: loc,\r\n        source: \'\'\r\n    }));\r\n}\r\nfunction isEnd(context, mode, ancestors) {\r\n    const s = context.source;\r\n    switch (mode) {\r\n        case 0 /* DATA */:\r\n            if (startsWith(s, \'</\')) {\r\n                // TODO: probably bad performance\r\n                for (let i = ancestors.length - 1; i >= 0; --i) {\r\n                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case 1 /* RCDATA */:\r\n        case 2 /* RAWTEXT */: {\r\n            const parent = last(ancestors);\r\n            if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n                return true;\r\n            }\r\n            break;\r\n        }\r\n        case 3 /* CDATA */:\r\n            if (startsWith(s, \']]>\')) {\r\n                return true;\r\n            }\r\n            break;\r\n    }\r\n    return !s;\r\n}\r\nfunction startsWithEndTagOpen(source, tag) {\r\n    return (startsWith(source, \'</\') &&\r\n        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\r\n        /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || \'>\'));\r\n}\n\nfunction compiler_core_esm_bundler_hoistStatic(root, context) {\r\n    walk(root, context, \r\n    // Root node is unfortunately non-hoistable due to potential parent\r\n    // fallthrough attributes.\r\n    isSingleElementRoot(root, root.children[0]));\r\n}\r\nfunction isSingleElementRoot(root, child) {\r\n    const { children } = root;\r\n    return (children.length === 1 &&\r\n        child.type === 1 /* ELEMENT */ &&\r\n        !isSlotOutlet(child));\r\n}\r\nfunction walk(node, context, doNotHoistNode = false) {\r\n    let hasHoistedNode = false;\r\n    // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces\r\n    // static bindings with expressions. These expressions are guaranteed to be\r\n    // constant so they are still eligible for hoisting, but they are only\r\n    // available at runtime and therefore cannot be evaluated ahead of time.\r\n    // This is only a concern for pre-stringification (via transformHoist by\r\n    // @vue/compiler-dom), but doing it here allows us to perform only one full\r\n    // walk of the AST and allow `stringifyStatic` to stop walking as soon as its\r\n    // stringficiation threshold is met.\r\n    let canStringify = true;\r\n    const { children } = node;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // only plain elements & text calls are eligible for hoisting.\r\n        if (child.type === 1 /* ELEMENT */ &&\r\n            child.tagType === 0 /* ELEMENT */) {\r\n            const constantType = doNotHoistNode\r\n                ? 0 /* NOT_CONSTANT */\r\n                : getConstantType(child, context);\r\n            if (constantType > 0 /* NOT_CONSTANT */) {\r\n                if (constantType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (constantType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode.patchFlag =\r\n                        -1 /* HOISTED */ + (( false) ? undefined : ``);\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                // node may contain dynamic children, but its props may be eligible for\r\n                // hoisting.\r\n                const codegenNode = child.codegenNode;\r\n                if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                    const flag = getPatchFlag(codegenNode);\r\n                    if ((!flag ||\r\n                        flag === 512 /* NEED_PATCH */ ||\r\n                        flag === 1 /* TEXT */) &&\r\n                        getGeneratedPropsConstantType(child, context) >=\r\n                            2 /* CAN_HOIST */) {\r\n                        const props = getNodeProps(child);\r\n                        if (props) {\r\n                            codegenNode.props = context.hoist(props);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (child.type === 12 /* TEXT_CALL */) {\r\n            const contentType = getConstantType(child.content, context);\r\n            if (contentType > 0) {\r\n                if (contentType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (contentType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                }\r\n            }\r\n        }\r\n        // walk further\r\n        if (child.type === 1 /* ELEMENT */) {\r\n            walk(child, context);\r\n        }\r\n        else if (child.type === 11 /* FOR */) {\r\n            // Do not hoist v-for single child because it has to be a block\r\n            walk(child, context, child.children.length === 1);\r\n        }\r\n        else if (child.type === 9 /* IF */) {\r\n            for (let i = 0; i < child.branches.length; i++) {\r\n                // Do not hoist v-if single child because it has to be a block\r\n                walk(child.branches[i], context, child.branches[i].children.length === 1);\r\n            }\r\n        }\r\n    }\r\n    if (canStringify && hasHoistedNode && context.transformHoist) {\r\n        context.transformHoist(children, context, node);\r\n    }\r\n}\r\nfunction getConstantType(node, context) {\r\n    const { constantCache } = context;\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            if (node.tagType !== 0 /* ELEMENT */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const cached = constantCache.get(node);\r\n            if (cached !== undefined) {\r\n                return cached;\r\n            }\r\n            const codegenNode = node.codegenNode;\r\n            if (codegenNode.type !== 13 /* VNODE_CALL */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const flag = getPatchFlag(codegenNode);\r\n            if (!flag) {\r\n                let returnType = 3 /* CAN_STRINGIFY */;\r\n                // Element itself has no patch flag. However we still need to check:\r\n                // 1. Even for a node with no patch flag, it is possible for it to contain\r\n                // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n                // injected keys or cached event handlers. Therefore we need to always\r\n                // check the codegenNode\'s props to be sure.\r\n                const generatedPropsType = getGeneratedPropsConstantType(node, context);\r\n                if (generatedPropsType === 0 /* NOT_CONSTANT */) {\r\n                    constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                if (generatedPropsType < returnType) {\r\n                    returnType = generatedPropsType;\r\n                }\r\n                // 2. its children.\r\n                for (let i = 0; i < node.children.length; i++) {\r\n                    const childType = getConstantType(node.children[i], context);\r\n                    if (childType === 0 /* NOT_CONSTANT */) {\r\n                        constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                        return 0 /* NOT_CONSTANT */;\r\n                    }\r\n                    if (childType < returnType) {\r\n                        returnType = childType;\r\n                    }\r\n                }\r\n                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n                // type, check if any of the props can cause the type to be lowered\r\n                // we can skip can_patch because it\'s guaranteed by the absence of a\r\n                // patchFlag.\r\n                if (returnType > 1 /* CAN_SKIP_PATCH */) {\r\n                    for (let i = 0; i < node.props.length; i++) {\r\n                        const p = node.props[i];\r\n                        if (p.type === 7 /* DIRECTIVE */ && p.name === \'bind\' && p.exp) {\r\n                            const expType = getConstantType(p.exp, context);\r\n                            if (expType === 0 /* NOT_CONSTANT */) {\r\n                                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                                return 0 /* NOT_CONSTANT */;\r\n                            }\r\n                            if (expType < returnType) {\r\n                                returnType = expType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // only svg/foreignObject could be block here, however if they are\r\n                // static then they don\'t need to be blocks since there will be no\r\n                // nested updates.\r\n                if (codegenNode.isBlock) {\r\n                    codegenNode.isBlock = false;\r\n                    context.helper(CREATE_VNODE);\r\n                }\r\n                constantCache.set(node, returnType);\r\n                return returnType;\r\n            }\r\n            else {\r\n                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return 3 /* CAN_STRINGIFY */;\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n        case 10 /* IF_BRANCH */:\r\n            return 0 /* NOT_CONSTANT */;\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return getConstantType(node.content, context);\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return node.constType;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            let returnType = 3 /* CAN_STRINGIFY */;\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                const child = node.children[i];\r\n                if (Object(shared_esm_bundler["C" /* isString */])(child) || Object(shared_esm_bundler["D" /* isSymbol */])(child)) {\r\n                    continue;\r\n                }\r\n                const childType = getConstantType(child, context);\r\n                if (childType === 0 /* NOT_CONSTANT */) {\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                else if (childType < returnType) {\r\n                    returnType = childType;\r\n                }\r\n            }\r\n            return returnType;\r\n        default:\r\n            if ((false)) {}\r\n            return 0 /* NOT_CONSTANT */;\r\n    }\r\n}\r\nfunction getGeneratedPropsConstantType(node, context) {\r\n    let returnType = 3 /* CAN_STRINGIFY */;\r\n    const props = getNodeProps(node);\r\n    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        const { properties } = props;\r\n        for (let i = 0; i < properties.length; i++) {\r\n            const { key, value } = properties[i];\r\n            const keyType = getConstantType(key, context);\r\n            if (keyType === 0 /* NOT_CONSTANT */) {\r\n                return keyType;\r\n            }\r\n            if (keyType < returnType) {\r\n                returnType = keyType;\r\n            }\r\n            if (value.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const valueType = getConstantType(value, context);\r\n            if (valueType === 0 /* NOT_CONSTANT */) {\r\n                return valueType;\r\n            }\r\n            if (valueType < returnType) {\r\n                returnType = valueType;\r\n            }\r\n        }\r\n    }\r\n    return returnType;\r\n}\r\nfunction getNodeProps(node) {\r\n    const codegenNode = node.codegenNode;\r\n    if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n        return codegenNode.props;\r\n    }\r\n}\r\nfunction getPatchFlag(node) {\r\n    const flag = node.patchFlag;\r\n    return flag ? parseInt(flag, 10) : undefined;\r\n}\n\nfunction createTransformContext(root, { filename = \'\', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = shared_esm_bundler["d" /* NOOP */], isCustomElement = shared_esm_bundler["d" /* NOOP */], expressionPlugins = [], scopeId = null, ssr = false, ssrCssVars = ``, bindingMetadata = shared_esm_bundler["b" /* EMPTY_OBJ */], inline = false, isTS = false, onError = defaultOnError }) {\r\n    const nameMatch = filename.replace(/\\?.*$/, \'\').match(/([^/\\\\]+)\\.\\w+$/);\r\n    const context = {\r\n        // options\r\n        selfName: nameMatch && Object(shared_esm_bundler["g" /* capitalize */])(Object(shared_esm_bundler["f" /* camelize */])(nameMatch[1])),\r\n        prefixIdentifiers,\r\n        hoistStatic,\r\n        cacheHandlers,\r\n        nodeTransforms,\r\n        directiveTransforms,\r\n        transformHoist,\r\n        isBuiltInComponent,\r\n        isCustomElement,\r\n        expressionPlugins,\r\n        scopeId,\r\n        ssr,\r\n        ssrCssVars,\r\n        bindingMetadata,\r\n        inline,\r\n        isTS,\r\n        onError,\r\n        // state\r\n        root,\r\n        helpers: new Set(),\r\n        components: new Set(),\r\n        directives: new Set(),\r\n        hoists: [],\r\n        imports: [],\r\n        constantCache: new Map(),\r\n        temps: 0,\r\n        cached: 0,\r\n        identifiers: Object.create(null),\r\n        scopes: {\r\n            vFor: 0,\r\n            vSlot: 0,\r\n            vPre: 0,\r\n            vOnce: 0\r\n        },\r\n        parent: null,\r\n        currentNode: root,\r\n        childIndex: 0,\r\n        // methods\r\n        helper(name) {\r\n            context.helpers.add(name);\r\n            return name;\r\n        },\r\n        helperString(name) {\r\n            return `_${helperNameMap[context.helper(name)]}`;\r\n        },\r\n        replaceNode(node) {\r\n            /* istanbul ignore if */\r\n            if ((false)) {}\r\n            context.parent.children[context.childIndex] = context.currentNode = node;\r\n        },\r\n        removeNode(node) {\r\n            if (false) {}\r\n            const list = context.parent.children;\r\n            const removalIndex = node\r\n                ? list.indexOf(node)\r\n                : context.currentNode\r\n                    ? context.childIndex\r\n                    : -1;\r\n            /* istanbul ignore if */\r\n            if (false) {}\r\n            if (!node || node === context.currentNode) {\r\n                // current node removed\r\n                context.currentNode = null;\r\n                context.onNodeRemoved();\r\n            }\r\n            else {\r\n                // sibling node removed\r\n                if (context.childIndex > removalIndex) {\r\n                    context.childIndex--;\r\n                    context.onNodeRemoved();\r\n                }\r\n            }\r\n            context.parent.children.splice(removalIndex, 1);\r\n        },\r\n        onNodeRemoved: () => { },\r\n        addIdentifiers(exp) {\r\n        },\r\n        removeIdentifiers(exp) {\r\n        },\r\n        hoist(exp) {\r\n            context.hoists.push(exp);\r\n            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);\r\n            identifier.hoisted = exp;\r\n            return identifier;\r\n        },\r\n        cache(exp, isVNode = false) {\r\n            return createCacheExpression(++context.cached, exp, isVNode);\r\n        }\r\n    };\r\n    return context;\r\n}\r\nfunction transform(root, options) {\r\n    const context = createTransformContext(root, options);\r\n    traverseNode(root, context);\r\n    if (options.hoistStatic) {\r\n        compiler_core_esm_bundler_hoistStatic(root, context);\r\n    }\r\n    if (!options.ssr) {\r\n        createRootCodegen(root, context);\r\n    }\r\n    // finalize meta information\r\n    root.helpers = [...context.helpers];\r\n    root.components = [...context.components];\r\n    root.directives = [...context.directives];\r\n    root.imports = context.imports;\r\n    root.hoists = context.hoists;\r\n    root.temps = context.temps;\r\n    root.cached = context.cached;\r\n}\r\nfunction createRootCodegen(root, context) {\r\n    const { helper } = context;\r\n    const { children } = root;\r\n    if (children.length === 1) {\r\n        const child = children[0];\r\n        // if the single child is an element, turn it into a block.\r\n        if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n            // single element root is never hoisted so codegenNode will never be\r\n            // SimpleExpressionNode\r\n            const codegenNode = child.codegenNode;\r\n            if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                codegenNode.isBlock = true;\r\n                helper(OPEN_BLOCK);\r\n                helper(CREATE_BLOCK);\r\n            }\r\n            root.codegenNode = codegenNode;\r\n        }\r\n        else {\r\n            // - single <slot/>, IfNode, ForNode: already blocks.\r\n            // - single text node: always patched.\r\n            // root codegen falls through via genNode()\r\n            root.codegenNode = child;\r\n        }\r\n    }\r\n    else if (children.length > 1) {\r\n        // root has multiple nodes - return a fragment block.\r\n        let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n        let patchFlagText = shared_esm_bundler["e" /* PatchFlagNames */][64 /* STABLE_FRAGMENT */];\r\n        // check if the fragment actually contains a single valid child with\r\n        // the rest being comments\r\n        if (false) {}\r\n        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( false) ? undefined : ``), undefined, undefined, true);\r\n    }\r\n    else ;\r\n}\r\nfunction traverseChildren(parent, context) {\r\n    let i = 0;\r\n    const nodeRemoved = () => {\r\n        i--;\r\n    };\r\n    for (; i < parent.children.length; i++) {\r\n        const child = parent.children[i];\r\n        if (Object(shared_esm_bundler["C" /* isString */])(child))\r\n            continue;\r\n        context.parent = parent;\r\n        context.childIndex = i;\r\n        context.onNodeRemoved = nodeRemoved;\r\n        traverseNode(child, context);\r\n    }\r\n}\r\nfunction traverseNode(node, context) {\r\n    context.currentNode = node;\r\n    // apply transform plugins\r\n    const { nodeTransforms } = context;\r\n    const exitFns = [];\r\n    for (let i = 0; i < nodeTransforms.length; i++) {\r\n        const onExit = nodeTransforms[i](node, context);\r\n        if (onExit) {\r\n            if (Object(shared_esm_bundler["o" /* isArray */])(onExit)) {\r\n                exitFns.push(...onExit);\r\n            }\r\n            else {\r\n                exitFns.push(onExit);\r\n            }\r\n        }\r\n        if (!context.currentNode) {\r\n            // node was removed\r\n            return;\r\n        }\r\n        else {\r\n            // node may have been replaced\r\n            node = context.currentNode;\r\n        }\r\n    }\r\n    switch (node.type) {\r\n        case 3 /* COMMENT */:\r\n            if (!context.ssr) {\r\n                // inject import for the Comment symbol, which is needed for creating\r\n                // comment nodes with `createVNode`\r\n                context.helper(CREATE_COMMENT);\r\n            }\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            // no need to traverse, but we need to inject toString helper\r\n            if (!context.ssr) {\r\n                context.helper(TO_DISPLAY_STRING);\r\n            }\r\n            break;\r\n        // for container types, further traverse downwards\r\n        case 9 /* IF */:\r\n            for (let i = 0; i < node.branches.length; i++) {\r\n                traverseNode(node.branches[i], context);\r\n            }\r\n            break;\r\n        case 10 /* IF_BRANCH */:\r\n        case 11 /* FOR */:\r\n        case 1 /* ELEMENT */:\r\n        case 0 /* ROOT */:\r\n            traverseChildren(node, context);\r\n            break;\r\n    }\r\n    // exit transforms\r\n    context.currentNode = node;\r\n    let i = exitFns.length;\r\n    while (i--) {\r\n        exitFns[i]();\r\n    }\r\n}\r\nfunction createStructuralDirectiveTransform(name, fn) {\r\n    const matches = Object(shared_esm_bundler["C" /* isString */])(name)\r\n        ? (n) => n === name\r\n        : (n) => name.test(n);\r\n    return (node, context) => {\r\n        if (node.type === 1 /* ELEMENT */) {\r\n            const { props } = node;\r\n            // structural directive transforms are not concerned with slots\r\n            // as they are handled separately in vSlot.ts\r\n            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {\r\n                return;\r\n            }\r\n            const exitFns = [];\r\n            for (let i = 0; i < props.length; i++) {\r\n                const prop = props[i];\r\n                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {\r\n                    // structural directives are removed to avoid infinite recursion\r\n                    // also we remove them *before* applying so that it can further\r\n                    // traverse itself in case it moves the node around\r\n                    props.splice(i, 1);\r\n                    i--;\r\n                    const onExit = fn(node, prop, context);\r\n                    if (onExit)\r\n                        exitFns.push(onExit);\r\n                }\r\n            }\r\n            return exitFns;\r\n        }\r\n    };\r\n}\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`;\r\nfunction createCodegenContext(ast, { mode = \'function\', prefixIdentifiers = mode === \'module\', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {\r\n    const context = {\r\n        mode,\r\n        prefixIdentifiers,\r\n        sourceMap,\r\n        filename,\r\n        scopeId,\r\n        optimizeImports,\r\n        runtimeGlobalName,\r\n        runtimeModuleName,\r\n        ssr,\r\n        source: ast.loc.source,\r\n        code: ``,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        indentLevel: 0,\r\n        pure: false,\r\n        map: undefined,\r\n        helper(key) {\r\n            return `_${helperNameMap[key]}`;\r\n        },\r\n        push(code, node) {\r\n            context.code += code;\r\n        },\r\n        indent() {\r\n            newline(++context.indentLevel);\r\n        },\r\n        deindent(withoutNewLine = false) {\r\n            if (withoutNewLine) {\r\n                --context.indentLevel;\r\n            }\r\n            else {\r\n                newline(--context.indentLevel);\r\n            }\r\n        },\r\n        newline() {\r\n            newline(context.indentLevel);\r\n        }\r\n    };\r\n    function newline(n) {\r\n        context.push(\'\\n\' + `  `.repeat(n));\r\n    }\r\n    return context;\r\n}\r\nfunction generate(ast, options = {}) {\r\n    const context = createCodegenContext(ast, options);\r\n    if (options.onContextCreated)\r\n        options.onContextCreated(context);\r\n    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;\r\n    const hasHelpers = ast.helpers.length > 0;\r\n    const useWithBlock = !prefixIdentifiers && mode !== \'module\';\r\n    // preambles\r\n    // in setup() inline mode, the preamble is generated in a sub context\r\n    // and returned separately.\r\n    const preambleContext = context;\r\n    {\r\n        genFunctionPreamble(ast, preambleContext);\r\n    }\r\n    // enter render function\r\n    const functionName = ssr ? `ssrRender` : `render`;\r\n    const args = ssr ? [\'_ctx\', \'_push\', \'_parent\', \'_attrs\'] : [\'_ctx\', \'_cache\'];\r\n    const signature = args.join(\', \');\r\n    {\r\n        push(`function ${functionName}(${signature}) {`);\r\n    }\r\n    indent();\r\n    if (useWithBlock) {\r\n        push(`with (_ctx) {`);\r\n        indent();\r\n        // function mode const declarations should be inside with block\r\n        // also they should be renamed to avoid collision with user properties\r\n        if (hasHelpers) {\r\n            push(`const { ${ast.helpers\r\n                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\r\n                .join(\', \')} } = _Vue`);\r\n            push(`\\n`);\r\n            newline();\r\n        }\r\n    }\r\n    // generate asset resolution statements\r\n    if (ast.components.length) {\r\n        genAssets(ast.components, \'component\', context);\r\n        if (ast.directives.length || ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.directives.length) {\r\n        genAssets(ast.directives, \'directive\', context);\r\n        if (ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.temps > 0) {\r\n        push(`let `);\r\n        for (let i = 0; i < ast.temps; i++) {\r\n            push(`${i > 0 ? `, ` : ``}_temp${i}`);\r\n        }\r\n    }\r\n    if (ast.components.length || ast.directives.length || ast.temps) {\r\n        push(`\\n`);\r\n        newline();\r\n    }\r\n    // generate the VNode tree expression\r\n    if (!ssr) {\r\n        push(`return `);\r\n    }\r\n    if (ast.codegenNode) {\r\n        genNode(ast.codegenNode, context);\r\n    }\r\n    else {\r\n        push(`null`);\r\n    }\r\n    if (useWithBlock) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    deindent();\r\n    push(`}`);\r\n    return {\r\n        ast,\r\n        code: context.code,\r\n        preamble: ``,\r\n        // SourceMapGenerator does have toJSON() method but it\'s not in the types\r\n        map: context.map ? context.map.toJSON() : undefined\r\n    };\r\n}\r\nfunction genFunctionPreamble(ast, context) {\r\n    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;\r\n    const VueBinding = runtimeGlobalName;\r\n    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\r\n    // Generate const declaration for helpers\r\n    // In prefix mode, we place the const declaration at top so it\'s done\r\n    // only once; But if we not prefixing, we place the declaration inside the\r\n    // with block so it doesn\'t incur the `in` check cost for every helper access.\r\n    if (ast.helpers.length > 0) {\r\n        {\r\n            // "with" mode.\r\n            // save Vue in a separate variable to avoid collision\r\n            push(`const _Vue = ${VueBinding}\\n`);\r\n            // in "with" mode, helpers are declared inside the with block to avoid\r\n            // has check cost, but hoists are lifted out of the function - we need\r\n            // to provide the helper here.\r\n            if (ast.hoists.length) {\r\n                const staticHelpers = [\r\n                    CREATE_VNODE,\r\n                    CREATE_COMMENT,\r\n                    CREATE_TEXT,\r\n                    CREATE_STATIC\r\n                ]\r\n                    .filter(helper => ast.helpers.includes(helper))\r\n                    .map(aliasHelper)\r\n                    .join(\', \');\r\n                push(`const { ${staticHelpers} } = _Vue\\n`);\r\n            }\r\n        }\r\n    }\r\n    genHoists(ast.hoists, context);\r\n    newline();\r\n    push(`return `);\r\n}\r\nfunction genAssets(assets, type, { helper, push, newline }) {\r\n    const resolver = helper(type === \'component\' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);\r\n    for (let i = 0; i < assets.length; i++) {\r\n        const id = assets[i];\r\n        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);\r\n        if (i < assets.length - 1) {\r\n            newline();\r\n        }\r\n    }\r\n}\r\nfunction genHoists(hoists, context) {\r\n    if (!hoists.length) {\r\n        return;\r\n    }\r\n    context.pure = true;\r\n    const { push, newline, helper, scopeId, mode } = context;\r\n    newline();\r\n    hoists.forEach((exp, i) => {\r\n        if (exp) {\r\n            push(`const _hoisted_${i + 1} = `);\r\n            genNode(exp, context);\r\n            newline();\r\n        }\r\n    });\r\n    context.pure = false;\r\n}\r\nfunction isText$1(n) {\r\n    return (Object(shared_esm_bundler["C" /* isString */])(n) ||\r\n        n.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n        n.type === 2 /* TEXT */ ||\r\n        n.type === 5 /* INTERPOLATION */ ||\r\n        n.type === 8 /* COMPOUND_EXPRESSION */);\r\n}\r\nfunction genNodeListAsArray(nodes, context) {\r\n    const multilines = nodes.length > 3 ||\r\n        ((( false)) && false);\r\n    context.push(`[`);\r\n    multilines && context.indent();\r\n    genNodeList(nodes, context, multilines);\r\n    multilines && context.deindent();\r\n    context.push(`]`);\r\n}\r\nfunction genNodeList(nodes, context, multilines = false, comma = true) {\r\n    const { push, newline } = context;\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        if (Object(shared_esm_bundler["C" /* isString */])(node)) {\r\n            push(node);\r\n        }\r\n        else if (Object(shared_esm_bundler["o" /* isArray */])(node)) {\r\n            genNodeListAsArray(node, context);\r\n        }\r\n        else {\r\n            genNode(node, context);\r\n        }\r\n        if (i < nodes.length - 1) {\r\n            if (multilines) {\r\n                comma && push(\',\');\r\n                newline();\r\n            }\r\n            else {\r\n                comma && push(\', \');\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction genNode(node, context) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(node)) {\r\n        context.push(node);\r\n        return;\r\n    }\r\n    if (Object(shared_esm_bundler["D" /* isSymbol */])(node)) {\r\n        context.push(context.helper(node));\r\n        return;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n            ( false) &&\r\n                false;\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 2 /* TEXT */:\r\n            genText(node, context);\r\n            break;\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            genExpression(node, context);\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            genInterpolation(node, context);\r\n            break;\r\n        case 12 /* TEXT_CALL */:\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            genCompoundExpression(node, context);\r\n            break;\r\n        case 3 /* COMMENT */:\r\n            genComment(node, context);\r\n            break;\r\n        case 13 /* VNODE_CALL */:\r\n            genVNodeCall(node, context);\r\n            break;\r\n        case 14 /* JS_CALL_EXPRESSION */:\r\n            genCallExpression(node, context);\r\n            break;\r\n        case 15 /* JS_OBJECT_EXPRESSION */:\r\n            genObjectExpression(node, context);\r\n            break;\r\n        case 17 /* JS_ARRAY_EXPRESSION */:\r\n            genArrayExpression(node, context);\r\n            break;\r\n        case 18 /* JS_FUNCTION_EXPRESSION */:\r\n            genFunctionExpression(node, context);\r\n            break;\r\n        case 19 /* JS_CONDITIONAL_EXPRESSION */:\r\n            genConditionalExpression(node, context);\r\n            break;\r\n        case 20 /* JS_CACHE_EXPRESSION */:\r\n            genCacheExpression(node, context);\r\n            break;\r\n        // SSR only types\r\n        case 21 /* JS_BLOCK_STATEMENT */:\r\n            break;\r\n        case 22 /* JS_TEMPLATE_LITERAL */:\r\n            break;\r\n        case 23 /* JS_IF_STATEMENT */:\r\n            break;\r\n        case 24 /* JS_ASSIGNMENT_EXPRESSION */:\r\n            break;\r\n        case 25 /* JS_SEQUENCE_EXPRESSION */:\r\n            break;\r\n        case 26 /* JS_RETURN_STATEMENT */:\r\n            break;\r\n        /* istanbul ignore next */\r\n        case 10 /* IF_BRANCH */:\r\n            // noop\r\n            break;\r\n        default:\r\n            if ((false)) {}\r\n    }\r\n}\r\nfunction genText(node, context) {\r\n    context.push(JSON.stringify(node.content), node);\r\n}\r\nfunction genExpression(node, context) {\r\n    const { content, isStatic } = node;\r\n    context.push(isStatic ? JSON.stringify(content) : content, node);\r\n}\r\nfunction genInterpolation(node, context) {\r\n    const { push, helper, pure } = context;\r\n    if (pure)\r\n        push(PURE_ANNOTATION);\r\n    push(`${helper(TO_DISPLAY_STRING)}(`);\r\n    genNode(node.content, context);\r\n    push(`)`);\r\n}\r\nfunction genCompoundExpression(node, context) {\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (Object(shared_esm_bundler["C" /* isString */])(child)) {\r\n            context.push(child);\r\n        }\r\n        else {\r\n            genNode(child, context);\r\n        }\r\n    }\r\n}\r\nfunction genExpressionAsPropertyKey(node, context) {\r\n    const { push } = context;\r\n    if (node.type === 8 /* COMPOUND_EXPRESSION */) {\r\n        push(`[`);\r\n        genCompoundExpression(node, context);\r\n        push(`]`);\r\n    }\r\n    else if (node.isStatic) {\r\n        // only quote keys if necessary\r\n        const text = isSimpleIdentifier(node.content)\r\n            ? node.content\r\n            : JSON.stringify(node.content);\r\n        push(text, node);\r\n    }\r\n    else {\r\n        push(`[${node.content}]`, node);\r\n    }\r\n}\r\nfunction genComment(node, context) {\r\n    if ((false)) {}\r\n}\r\nfunction genVNodeCall(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node;\r\n    if (directives) {\r\n        push(helper(WITH_DIRECTIVES) + `(`);\r\n    }\r\n    if (isBlock) {\r\n        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\r\n    }\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);\r\n    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\r\n    push(`)`);\r\n    if (isBlock) {\r\n        push(`)`);\r\n    }\r\n    if (directives) {\r\n        push(`, `);\r\n        genNode(directives, context);\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genNullableArgs(args) {\r\n    let i = args.length;\r\n    while (i--) {\r\n        if (args[i] != null)\r\n            break;\r\n    }\r\n    return args.slice(0, i + 1).map(arg => arg || `null`);\r\n}\r\n// JavaScript\r\nfunction genCallExpression(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const callee = Object(shared_esm_bundler["C" /* isString */])(node.callee) ? node.callee : helper(node.callee);\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(callee + `(`, node);\r\n    genNodeList(node.arguments, context);\r\n    push(`)`);\r\n}\r\nfunction genObjectExpression(node, context) {\r\n    const { push, indent, deindent, newline } = context;\r\n    const { properties } = node;\r\n    if (!properties.length) {\r\n        push(`{}`, node);\r\n        return;\r\n    }\r\n    const multilines = properties.length > 1 ||\r\n        ((( false)) &&\r\n            false);\r\n    push(multilines ? `{` : `{ `);\r\n    multilines && indent();\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const { key, value } = properties[i];\r\n        // key\r\n        genExpressionAsPropertyKey(key, context);\r\n        push(`: `);\r\n        // value\r\n        genNode(value, context);\r\n        if (i < properties.length - 1) {\r\n            // will only reach this if it\'s multilines\r\n            push(`,`);\r\n            newline();\r\n        }\r\n    }\r\n    multilines && deindent();\r\n    push(multilines ? `}` : ` }`);\r\n}\r\nfunction genArrayExpression(node, context) {\r\n    genNodeListAsArray(node.elements, context);\r\n}\r\nfunction genFunctionExpression(node, context) {\r\n    const { push, indent, deindent, scopeId, mode } = context;\r\n    const { params, returns, body, newline, isSlot } = node;\r\n    if (isSlot) {\r\n        push(`_${helperNameMap[WITH_CTX]}(`);\r\n    }\r\n    push(`(`, node);\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(params)) {\r\n        genNodeList(params, context);\r\n    }\r\n    else if (params) {\r\n        genNode(params, context);\r\n    }\r\n    push(`) => `);\r\n    if (newline || body) {\r\n        push(`{`);\r\n        indent();\r\n    }\r\n    if (returns) {\r\n        if (newline) {\r\n            push(`return `);\r\n        }\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(returns)) {\r\n            genNodeListAsArray(returns, context);\r\n        }\r\n        else {\r\n            genNode(returns, context);\r\n        }\r\n    }\r\n    else if (body) {\r\n        genNode(body, context);\r\n    }\r\n    if (newline || body) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    if (isSlot) {\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genConditionalExpression(node, context) {\r\n    const { test, consequent, alternate, newline: needNewline } = node;\r\n    const { push, indent, deindent, newline } = context;\r\n    if (test.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        const needsParens = !isSimpleIdentifier(test.content);\r\n        needsParens && push(`(`);\r\n        genExpression(test, context);\r\n        needsParens && push(`)`);\r\n    }\r\n    else {\r\n        push(`(`);\r\n        genNode(test, context);\r\n        push(`)`);\r\n    }\r\n    needNewline && indent();\r\n    context.indentLevel++;\r\n    needNewline || push(` `);\r\n    push(`? `);\r\n    genNode(consequent, context);\r\n    context.indentLevel--;\r\n    needNewline && newline();\r\n    needNewline || push(` `);\r\n    push(`: `);\r\n    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;\r\n    if (!isNested) {\r\n        context.indentLevel++;\r\n    }\r\n    genNode(alternate, context);\r\n    if (!isNested) {\r\n        context.indentLevel--;\r\n    }\r\n    needNewline && deindent(true /* without newline */);\r\n}\r\nfunction genCacheExpression(node, context) {\r\n    const { push, helper, indent, deindent, newline } = context;\r\n    push(`_cache[${node.index}] || (`);\r\n    if (node.isVNode) {\r\n        indent();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\r\n        newline();\r\n    }\r\n    push(`_cache[${node.index}] = `);\r\n    genNode(node.value, context);\r\n    if (node.isVNode) {\r\n        push(`,`);\r\n        newline();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(1),`);\r\n        newline();\r\n        push(`_cache[${node.index}]`);\r\n        deindent();\r\n    }\r\n    push(`)`);\r\n}\n\n// these keywords should not appear inside expressions, but operators like\r\n// typeof, instanceof and in are allowed\r\nconst prohibitedKeywordRE = new RegExp(\'\\\\b\' +\r\n    (\'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,\' +\r\n        \'super,throw,while,yield,delete,export,import,return,switch,default,\' +\r\n        \'extends,finally,continue,debugger,function,arguments,typeof,void\')\r\n        .split(\',\')\r\n        .join(\'\\\\b|\\\\b\') +\r\n    \'\\\\b\');\r\n// strip strings in expressions\r\nconst stripStringRE = /\'(?:[^\'\\\\]|\\\\.)*\'|"(?:[^"\\\\]|\\\\.)*"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\r\n/**\r\n * Validate a non-prefixed expression.\r\n * This is only called when using the in-browser runtime compiler since it\r\n * doesn\'t prefix expressions.\r\n */\r\nfunction validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {\r\n    const exp = node.content;\r\n    // empty expressions are validated per-directive since some directives\r\n    // do allow empty expressions.\r\n    if (!exp.trim()) {\r\n        return;\r\n    }\r\n    try {\r\n        new Function(asRawStatements\r\n            ? ` ${exp} `\r\n            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);\r\n    }\r\n    catch (e) {\r\n        let message = e.message;\r\n        const keywordMatch = exp\r\n            .replace(stripStringRE, \'\')\r\n            .match(prohibitedKeywordRE);\r\n        if (keywordMatch) {\r\n            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;\r\n        }\r\n        context.onError(createCompilerError(43 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));\r\n    }\r\n}\n\nconst transformExpression = (node, context) => {\r\n    if (node.type === 5 /* INTERPOLATION */) {\r\n        node.content = processExpression(node.content, context);\r\n    }\r\n    else if (node.type === 1 /* ELEMENT */) {\r\n        // handle directives on element\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const dir = node.props[i];\r\n            // do not process for v-on & v-for since they are special handled\r\n            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== \'for\') {\r\n                const exp = dir.exp;\r\n                const arg = dir.arg;\r\n                // do not process exp if this is v-on:arg - we need special handling\r\n                // for wrapping inline statements.\r\n                if (exp &&\r\n                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                    !(dir.name === \'on\' && arg)) {\r\n                    dir.exp = processExpression(exp, context, \r\n                    // slot args must be processed as function params\r\n                    dir.name === \'slot\');\r\n                }\r\n                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {\r\n                    dir.arg = processExpression(arg, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !true check so that it can be\r\n// tree-shaken from the browser build.\r\nfunction processExpression(node, context, \r\n// some expressions like v-slot props & v-for aliases should be parsed as\r\n// function params\r\nasParams = false, \r\n// v-on handler values may contain multiple statements\r\nasRawStatements = false) {\r\n    {\r\n        if ((false)) {}\r\n        return node;\r\n    }\r\n}\n\nconst transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\r\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n        // #1587: We need to dynamically increment the key based on the current\r\n        // node\'s sibling nodes, since chained v-if/else branches are\r\n        // rendered at the same depth\r\n        const siblings = context.parent.children;\r\n        let i = siblings.indexOf(ifNode);\r\n        let key = 0;\r\n        while (i-- >= 0) {\r\n            const sibling = siblings[i];\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                key += sibling.branches.length;\r\n            }\r\n        }\r\n        // Exit callback. Complete the codegenNode when all children have been\r\n        // transformed.\r\n        return () => {\r\n            if (isRoot) {\r\n                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\r\n            }\r\n            else {\r\n                // attach this branch\'s codegen node to the v-if root.\r\n                const parentCondition = getParentCondition(ifNode.codegenNode);\r\n                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\r\n            }\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processIf(node, dir, context, processCodegen) {\r\n    if (dir.name !== \'else\' &&\r\n        (!dir.exp || !dir.exp.content.trim())) {\r\n        const loc = dir.exp ? dir.exp.loc : node.loc;\r\n        context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));\r\n        dir.exp = createSimpleExpression(`true`, false, loc);\r\n    }\r\n    if (false) {}\r\n    if (dir.name === \'if\') {\r\n        const branch = createIfBranch(node, dir);\r\n        const ifNode = {\r\n            type: 9 /* IF */,\r\n            loc: node.loc,\r\n            branches: [branch]\r\n        };\r\n        context.replaceNode(ifNode);\r\n        if (processCodegen) {\r\n            return processCodegen(ifNode, branch, true);\r\n        }\r\n    }\r\n    else {\r\n        // locate the adjacent v-if\r\n        const siblings = context.parent.children;\r\n        const comments = [];\r\n        let i = siblings.indexOf(node);\r\n        while (i-- >= -1) {\r\n            const sibling = siblings[i];\r\n            if (false /* COMMENT */) {}\r\n            if (sibling &&\r\n                sibling.type === 2 /* TEXT */ &&\r\n                !sibling.content.trim().length) {\r\n                context.removeNode(sibling);\r\n                continue;\r\n            }\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                // move the node to the if node\'s branches\r\n                context.removeNode();\r\n                const branch = createIfBranch(node, dir);\r\n                if (false) {}\r\n                // check if user is forcing same key on different branches\r\n                if (false) {}\r\n                sibling.branches.push(branch);\r\n                const onExit = processCodegen && processCodegen(sibling, branch, false);\r\n                // since the branch was removed, it will not be traversed.\r\n                // make sure to traverse here.\r\n                traverseNode(branch, context);\r\n                // call on exit\r\n                if (onExit)\r\n                    onExit();\r\n                // make sure to reset currentNode after traversal to indicate this\r\n                // node has been removed.\r\n                context.currentNode = null;\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction createIfBranch(node, dir) {\r\n    return {\r\n        type: 10 /* IF_BRANCH */,\r\n        loc: node.loc,\r\n        condition: dir.name === \'else\' ? undefined : dir.exp,\r\n        children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, \'for\')\r\n            ? node.children\r\n            : [node],\r\n        userKey: findProp(node, `key`)\r\n    };\r\n}\r\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\r\n    if (branch.condition) {\r\n        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), \r\n        // make sure to pass in asBlock: true so that the comment node call\r\n        // closes the current block.\r\n        createCallExpression(context.helper(CREATE_COMMENT), [\r\n            ( false) ? undefined : \'""\',\r\n            \'true\'\r\n        ]));\r\n    }\r\n    else {\r\n        return createChildrenCodegenNode(branch, keyIndex, context);\r\n    }\r\n}\r\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\r\n    const { helper } = context;\r\n    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));\r\n    const { children } = branch;\r\n    const firstChild = children[0];\r\n    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;\r\n    if (needFragmentWrapper) {\r\n        if (children.length === 1 && firstChild.type === 11 /* FOR */) {\r\n            // optimize away nested fragments when child is a ForNode\r\n            const vnodeCall = firstChild.codegenNode;\r\n            injectProp(vnodeCall, keyProperty, context);\r\n            return vnodeCall;\r\n        }\r\n        else {\r\n            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, 64 /* STABLE_FRAGMENT */ +\r\n                (( false)\r\n                    ? undefined\r\n                    : ``), undefined, undefined, true, false, branch.loc);\r\n        }\r\n    }\r\n    else {\r\n        const vnodeCall = firstChild\r\n            .codegenNode;\r\n        // Change createVNode to createBlock.\r\n        if (vnodeCall.type === 13 /* VNODE_CALL */) {\r\n            vnodeCall.isBlock = true;\r\n            helper(OPEN_BLOCK);\r\n            helper(CREATE_BLOCK);\r\n        }\r\n        // inject branch key\r\n        injectProp(vnodeCall, keyProperty, context);\r\n        return vnodeCall;\r\n    }\r\n}\r\nfunction isSameKey(a, b) {\r\n    if (!a || a.type !== b.type) {\r\n        return false;\r\n    }\r\n    if (a.type === 6 /* ATTRIBUTE */) {\r\n        if (a.value.content !== b.value.content) {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        // directive\r\n        const exp = a.exp;\r\n        const branchExp = b.exp;\r\n        if (exp.type !== branchExp.type) {\r\n            return false;\r\n        }\r\n        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||\r\n            (exp.isStatic !== branchExp.isStatic ||\r\n                exp.content !== branchExp.content)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getParentCondition(node) {\r\n    while (true) {\r\n        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                node = node.alternate;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        }\r\n        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {\r\n            node = node.value;\r\n        }\r\n    }\r\n}\n\nconst transformFor = createStructuralDirectiveTransform(\'for\', (node, dir, context) => {\r\n    const { helper } = context;\r\n    return processFor(node, dir, context, forNode => {\r\n        // create the loop render function expression now, and add the\r\n        // iterator on exit after all children have been traversed\r\n        const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n            forNode.source\r\n        ]);\r\n        const keyProp = findProp(node, `key`);\r\n        const keyProperty = keyProp\r\n            ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */\r\n                ? createSimpleExpression(keyProp.value.content, true)\r\n                : keyProp.exp)\r\n            : null;\r\n        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n            forNode.source.constType > 0 /* NOT_CONSTANT */;\r\n        const fragmentFlag = isStableFragment\r\n            ? 64 /* STABLE_FRAGMENT */\r\n            : keyProp\r\n                ? 128 /* KEYED_FRAGMENT */\r\n                : 256 /* UNKEYED_FRAGMENT */;\r\n        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +\r\n            (( false) ? undefined : ``), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, node.loc);\r\n        return () => {\r\n            // finish the codegen now that all children have been traversed\r\n            let childBlock;\r\n            const isTemplate = isTemplateNode(node);\r\n            const { children } = forNode;\r\n            // check <template v-for> key placement\r\n            if (false) {}\r\n            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;\r\n            const slotOutlet = isSlotOutlet(node)\r\n                ? node\r\n                : isTemplate &&\r\n                    node.children.length === 1 &&\r\n                    isSlotOutlet(node.children[0])\r\n                    ? node.children[0] // api-extractor somehow fails to infer this\r\n                    : null;\r\n            if (slotOutlet) {\r\n                // <slot v-for="..."> or <template v-for="..."><slot/></template>\r\n                childBlock = slotOutlet.codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    // <template v-for="..." :key="..."><slot/></template>\r\n                    // we need to inject the key to the renderSlot() call.\r\n                    // the props for renderSlot is passed as the 3rd argument.\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n            }\r\n            else if (needFragmentWrapper) {\r\n                // <template v-for="..."> with text or multi-elements\r\n                // should generate a fragment block for each loop\r\n                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +\r\n                    (( false)\r\n                        ? undefined\r\n                        : ``), undefined, undefined, true);\r\n            }\r\n            else {\r\n                // Normal element v-for. Directly use the child\'s codegenNode\r\n                // but mark it as a block.\r\n                childBlock = children[0]\r\n                    .codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n                childBlock.isBlock = !isStableFragment;\r\n                if (childBlock.isBlock) {\r\n                    helper(OPEN_BLOCK);\r\n                    helper(CREATE_BLOCK);\r\n                }\r\n                else {\r\n                    helper(CREATE_VNODE);\r\n                }\r\n            }\r\n            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processFor(node, dir, context, processCodegen) {\r\n    if (!dir.exp) {\r\n        context.onError(createCompilerError(30 /* X_V_FOR_NO_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const parseResult = parseForExpression(\r\n    // can only be simple expression because vFor transform is applied\r\n    // before expression transform.\r\n    dir.exp, context);\r\n    if (!parseResult) {\r\n        context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const { addIdentifiers, removeIdentifiers, scopes } = context;\r\n    const { source, value, key, index } = parseResult;\r\n    const forNode = {\r\n        type: 11 /* FOR */,\r\n        loc: dir.loc,\r\n        source,\r\n        valueAlias: value,\r\n        keyAlias: key,\r\n        objectIndexAlias: index,\r\n        parseResult,\r\n        children: isTemplateNode(node) ? node.children : [node]\r\n    };\r\n    context.replaceNode(forNode);\r\n    // bookkeeping\r\n    scopes.vFor++;\r\n    const onExit = processCodegen && processCodegen(forNode);\r\n    return () => {\r\n        scopes.vFor--;\r\n        if (onExit)\r\n            onExit();\r\n    };\r\n}\r\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\n// This regex doesn\'t cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\nconst stripParensRE = /^\\(|\\)$/g;\r\nfunction parseForExpression(input, context) {\r\n    const loc = input.loc;\r\n    const exp = input.content;\r\n    const inMatch = exp.match(forAliasRE);\r\n    if (!inMatch)\r\n        return;\r\n    const [, LHS, RHS] = inMatch;\r\n    const result = {\r\n        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\r\n        value: undefined,\r\n        key: undefined,\r\n        index: undefined\r\n    };\r\n    if (false) {}\r\n    let valueContent = LHS.trim()\r\n        .replace(stripParensRE, \'\')\r\n        .trim();\r\n    const trimmedOffset = LHS.indexOf(valueContent);\r\n    const iteratorMatch = valueContent.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n        valueContent = valueContent.replace(forIteratorRE, \'\').trim();\r\n        const keyContent = iteratorMatch[1].trim();\r\n        let keyOffset;\r\n        if (keyContent) {\r\n            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\r\n            result.key = createAliasExpression(loc, keyContent, keyOffset);\r\n            if (false) {}\r\n        }\r\n        if (iteratorMatch[2]) {\r\n            const indexContent = iteratorMatch[2].trim();\r\n            if (indexContent) {\r\n                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\r\n                    ? keyOffset + keyContent.length\r\n                    : trimmedOffset + valueContent.length));\r\n                if (false) {}\r\n            }\r\n        }\r\n    }\r\n    if (valueContent) {\r\n        result.value = createAliasExpression(loc, valueContent, trimmedOffset);\r\n        if (false) {}\r\n    }\r\n    return result;\r\n}\r\nfunction createAliasExpression(range, content, offset) {\r\n    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\r\n}\r\nfunction createForLoopParams({ value, key, index }) {\r\n    const params = [];\r\n    if (value) {\r\n        params.push(value);\r\n    }\r\n    if (key) {\r\n        if (!value) {\r\n            params.push(createSimpleExpression(`_`, false));\r\n        }\r\n        params.push(key);\r\n    }\r\n    if (index) {\r\n        if (!key) {\r\n            if (!value) {\r\n                params.push(createSimpleExpression(`_`, false));\r\n            }\r\n            params.push(createSimpleExpression(`__`, false));\r\n        }\r\n        params.push(index);\r\n    }\r\n    return params;\r\n}\n\nconst defaultFallback = createSimpleExpression(`undefined`, false);\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don\'t get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nconst trackSlotScopes = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 1 /* COMPONENT */ ||\r\n            node.tagType === 3 /* TEMPLATE */)) {\r\n        // We are only checking non-empty v-slot here\r\n        // since we only care about slots that introduce scope variables.\r\n        const vSlot = findDir(node, \'slot\');\r\n        if (vSlot) {\r\n            vSlot.exp;\r\n            context.scopes.vSlot++;\r\n            return () => {\r\n                context.scopes.vSlot--;\r\n            };\r\n        }\r\n    }\r\n};\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nconst trackVForSlotScopes = (node, context) => {\r\n    let vFor;\r\n    if (isTemplateNode(node) &&\r\n        node.props.some(isVSlot) &&\r\n        (vFor = findDir(node, \'for\'))) {\r\n        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));\r\n        if (result) {\r\n            const { value, key, index } = result;\r\n            const { addIdentifiers, removeIdentifiers } = context;\r\n            value && addIdentifiers(value);\r\n            key && addIdentifiers(key);\r\n            index && addIdentifiers(index);\r\n            return () => {\r\n                value && removeIdentifiers(value);\r\n                key && removeIdentifiers(key);\r\n                index && removeIdentifiers(index);\r\n            };\r\n        }\r\n    }\r\n};\r\nconst buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nfunction buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\r\n    context.helper(WITH_CTX);\r\n    const { children, loc } = node;\r\n    const slotsProperties = [];\r\n    const dynamicSlots = [];\r\n    const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));\r\n    // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n    // since it likely uses a scope variable.\r\n    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\r\n    // 1. Check for slot with slotProps on component itself.\r\n    //    <Comp v-slot="{ prop }"/>\r\n    const onComponentSlot = findDir(node, \'slot\', true);\r\n    if (onComponentSlot) {\r\n        const { arg, exp } = onComponentSlot;\r\n        if (arg && !isStaticExp(arg)) {\r\n            hasDynamicSlots = true;\r\n        }\r\n        slotsProperties.push(createObjectProperty(arg || createSimpleExpression(\'default\', true), buildSlotFn(exp, children, loc)));\r\n    }\r\n    // 2. Iterate through children and check for template slots\r\n    //    <template v-slot:foo="{ prop }">\r\n    let hasTemplateSlots = false;\r\n    let hasNamedDefaultSlot = false;\r\n    const implicitDefaultChildren = [];\r\n    const seenSlotNames = new Set();\r\n    for (let i = 0; i < children.length; i++) {\r\n        const slotElement = children[i];\r\n        let slotDir;\r\n        if (!isTemplateNode(slotElement) ||\r\n            !(slotDir = findDir(slotElement, \'slot\', true))) {\r\n            // not a <template v-slot>, skip.\r\n            if (slotElement.type !== 3 /* COMMENT */) {\r\n                implicitDefaultChildren.push(slotElement);\r\n            }\r\n            continue;\r\n        }\r\n        if (onComponentSlot) {\r\n            // already has on-component slot - this is incorrect usage.\r\n            context.onError(createCompilerError(36 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\r\n            break;\r\n        }\r\n        hasTemplateSlots = true;\r\n        const { children: slotChildren, loc: slotLoc } = slotElement;\r\n        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\r\n        // check if name is dynamic.\r\n        let staticSlotName;\r\n        if (isStaticExp(slotName)) {\r\n            staticSlotName = slotName ? slotName.content : `default`;\r\n        }\r\n        else {\r\n            hasDynamicSlots = true;\r\n        }\r\n        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\r\n        // check if this slot is conditional (v-if/v-for)\r\n        let vIf;\r\n        let vElse;\r\n        let vFor;\r\n        if ((vIf = findDir(slotElement, \'if\'))) {\r\n            hasDynamicSlots = true;\r\n            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\r\n        }\r\n        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\r\n            // find adjacent v-if\r\n            let j = i;\r\n            let prev;\r\n            while (j--) {\r\n                prev = children[j];\r\n                if (prev.type !== 3 /* COMMENT */) {\r\n                    break;\r\n                }\r\n            }\r\n            if (prev && isTemplateNode(prev) && findDir(prev, \'if\')) {\r\n                // remove node\r\n                children.splice(i, 1);\r\n                i--;\r\n                // attach this slot to previous conditional\r\n                let conditional = dynamicSlots[dynamicSlots.length - 1];\r\n                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                    conditional = conditional.alternate;\r\n                }\r\n                conditional.alternate = vElse.exp\r\n                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\r\n                    : buildDynamicSlot(slotName, slotFunction);\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\r\n            }\r\n        }\r\n        else if ((vFor = findDir(slotElement, \'for\'))) {\r\n            hasDynamicSlots = true;\r\n            const parseResult = vFor.parseResult ||\r\n                parseForExpression(vFor.exp, context);\r\n            if (parseResult) {\r\n                // Render the dynamic slots as an array and add it to the createSlot()\r\n                // args. The runtime knows how to handle it appropriately.\r\n                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\r\n                    parseResult.source,\r\n                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\r\n                ]));\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\r\n            }\r\n        }\r\n        else {\r\n            // check duplicate static names\r\n            if (staticSlotName) {\r\n                if (seenSlotNames.has(staticSlotName)) {\r\n                    context.onError(createCompilerError(37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\r\n                    continue;\r\n                }\r\n                seenSlotNames.add(staticSlotName);\r\n                if (staticSlotName === \'default\') {\r\n                    hasNamedDefaultSlot = true;\r\n                }\r\n            }\r\n            slotsProperties.push(createObjectProperty(slotName, slotFunction));\r\n        }\r\n    }\r\n    if (!onComponentSlot) {\r\n        if (!hasTemplateSlots) {\r\n            // implicit default slot (on component)\r\n            slotsProperties.push(buildDefaultSlotProperty(undefined, children));\r\n        }\r\n        else if (implicitDefaultChildren.length) {\r\n            // implicit default slot (mixed with named slots)\r\n            if (hasNamedDefaultSlot) {\r\n                context.onError(createCompilerError(38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\r\n            }\r\n            else {\r\n                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\r\n            }\r\n        }\r\n    }\r\n    const slotFlag = hasDynamicSlots\r\n        ? 2 /* DYNAMIC */\r\n        : hasForwardedSlots(node.children)\r\n            ? 3 /* FORWARDED */\r\n            : 1 /* STABLE */;\r\n    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \r\n    // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n    // 1 = compiled and static = can skip normalization AND diff as optimized\r\n    createSimpleExpression(slotFlag + (( false) ? undefined : ``), false))), loc);\r\n    if (dynamicSlots.length) {\r\n        slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n            slots,\r\n            createArrayExpression(dynamicSlots)\r\n        ]);\r\n    }\r\n    return {\r\n        slots,\r\n        hasDynamicSlots\r\n    };\r\n}\r\nfunction buildDynamicSlot(name, fn) {\r\n    return createObjectExpression([\r\n        createObjectProperty(`name`, name),\r\n        createObjectProperty(`fn`, fn)\r\n    ]);\r\n}\r\nfunction hasForwardedSlots(children) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (child.type === 1 /* ELEMENT */) {\r\n            if (child.tagType === 2 /* SLOT */ ||\r\n                (child.tagType === 0 /* ELEMENT */ &&\r\n                    hasForwardedSlots(child.children))) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\r\n// import, which should be used instead of a resolveDirective call.\r\nconst directiveImportMap = new WeakMap();\r\n// generate a JavaScript AST for this element\'s codegen\r\nconst transformElement = (node, context) => {\r\n    if (!(node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 0 /* ELEMENT */ ||\r\n            node.tagType === 1 /* COMPONENT */))) {\r\n        return;\r\n    }\r\n    // perform the work on exit, after all child expressions have been\r\n    // processed and merged.\r\n    return function postTransformElement() {\r\n        const { tag, props } = node;\r\n        const isComponent = node.tagType === 1 /* COMPONENT */;\r\n        // The goal of the transform is to create a codegenNode implementing the\r\n        // VNodeCall interface.\r\n        const vnodeTag = isComponent\r\n            ? resolveComponentType(node, context)\r\n            : `"${tag}"`;\r\n        const isDynamicComponent = Object(shared_esm_bundler["v" /* isObject */])(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\r\n        let vnodeProps;\r\n        let vnodeChildren;\r\n        let vnodePatchFlag;\r\n        let patchFlag = 0;\r\n        let vnodeDynamicProps;\r\n        let dynamicPropNames;\r\n        let vnodeDirectives;\r\n        let shouldUseBlock = \r\n        // dynamic component may resolve to plain elements\r\n        isDynamicComponent ||\r\n            vnodeTag === TELEPORT ||\r\n            vnodeTag === SUSPENSE ||\r\n            (!isComponent &&\r\n                // <svg> and <foreignObject> must be forced into blocks so that block\r\n                // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n                // This is technically web-specific, but splitting the logic out of core\r\n                // leads to too much unnecessary complexity.\r\n                (tag === \'svg\' ||\r\n                    tag === \'foreignObject\' ||\r\n                    // #938: elements with dynamic keys should be forced into blocks\r\n                    findProp(node, \'key\', true)));\r\n        // props\r\n        if (props.length > 0) {\r\n            const propsBuildResult = buildProps(node, context);\r\n            vnodeProps = propsBuildResult.props;\r\n            patchFlag = propsBuildResult.patchFlag;\r\n            dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n            const directives = propsBuildResult.directives;\r\n            vnodeDirectives =\r\n                directives && directives.length\r\n                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))\r\n                    : undefined;\r\n        }\r\n        // children\r\n        if (node.children.length > 0) {\r\n            if (vnodeTag === KEEP_ALIVE) {\r\n                // Although a built-in component, we compile KeepAlive with raw children\r\n                // instead of slot functions so that it can be used inside Transition\r\n                // or other Transition-wrapping HOCs.\r\n                // To ensure correct updates with block optimizations, we need to:\r\n                // 1. Force keep-alive into a block. This avoids its children being\r\n                //    collected by a parent block.\r\n                shouldUseBlock = true;\r\n                // 2. Force keep-alive to always be updated, since it uses raw children.\r\n                patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                if (false) {}\r\n            }\r\n            const shouldBuildAsSlots = isComponent &&\r\n                // Teleport is not a real component and has dedicated runtime handling\r\n                vnodeTag !== TELEPORT &&\r\n                // explained above.\r\n                vnodeTag !== KEEP_ALIVE;\r\n            if (shouldBuildAsSlots) {\r\n                const { slots, hasDynamicSlots } = buildSlots(node, context);\r\n                vnodeChildren = slots;\r\n                if (hasDynamicSlots) {\r\n                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n            }\r\n            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n                const child = node.children[0];\r\n                const type = child.type;\r\n                // check for dynamic text children\r\n                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||\r\n                    type === 8 /* COMPOUND_EXPRESSION */;\r\n                if (hasDynamicTextChild &&\r\n                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                    patchFlag |= 1 /* TEXT */;\r\n                }\r\n                // pass directly if the only child is a text node\r\n                // (plain / interpolation / expression)\r\n                if (hasDynamicTextChild || type === 2 /* TEXT */) {\r\n                    vnodeChildren = child;\r\n                }\r\n                else {\r\n                    vnodeChildren = node.children;\r\n                }\r\n            }\r\n            else {\r\n                vnodeChildren = node.children;\r\n            }\r\n        }\r\n        // patchFlag & dynamicPropNames\r\n        if (patchFlag !== 0) {\r\n            if ((false)) {}\r\n            else {\r\n                vnodePatchFlag = String(patchFlag);\r\n            }\r\n            if (dynamicPropNames && dynamicPropNames.length) {\r\n                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\r\n            }\r\n        }\r\n        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc);\r\n    };\r\n};\r\nfunction resolveComponentType(node, context, ssr = false) {\r\n    const { tag } = node;\r\n    // 1. dynamic component\r\n    const isProp = node.tag === \'component\' ? findProp(node, \'is\') : findDir(node, \'is\');\r\n    if (isProp) {\r\n        const exp = isProp.type === 6 /* ATTRIBUTE */\r\n            ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n            : isProp.exp;\r\n        if (exp) {\r\n            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n                exp\r\n            ]);\r\n        }\r\n    }\r\n    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\r\n    if (builtIn) {\r\n        // built-ins are simply fallthroughs / have special handling during ssr\r\n        // so we don\'t need to import their runtime equivalents\r\n        if (!ssr)\r\n            context.helper(builtIn);\r\n        return builtIn;\r\n    }\r\n    // 5. user component (resolve)\r\n    context.helper(RESOLVE_COMPONENT);\r\n    context.components.add(tag);\r\n    return toValidAssetId(tag, `component`);\r\n}\r\nfunction buildProps(node, context, props = node.props, ssr = false) {\r\n    const { tag, loc: elementLoc } = node;\r\n    const isComponent = node.tagType === 1 /* COMPONENT */;\r\n    let properties = [];\r\n    const mergeArgs = [];\r\n    const runtimeDirectives = [];\r\n    // patchFlag analysis\r\n    let patchFlag = 0;\r\n    let hasRef = false;\r\n    let hasClassBinding = false;\r\n    let hasStyleBinding = false;\r\n    let hasHydrationEventBinding = false;\r\n    let hasDynamicKeys = false;\r\n    let hasVnodeHook = false;\r\n    const dynamicPropNames = [];\r\n    const analyzePatchFlag = ({ key, value }) => {\r\n        if (isStaticExp(key)) {\r\n            const name = key.content;\r\n            const isEventHandler = Object(shared_esm_bundler["w" /* isOn */])(name);\r\n            if (!isComponent &&\r\n                isEventHandler &&\r\n                // omit the flag for click handlers because hydration gives click\r\n                // dedicated fast path.\r\n                name.toLowerCase() !== \'onclick\' &&\r\n                // omit v-model handlers\r\n                name !== \'onUpdate:modelValue\' &&\r\n                // omit onVnodeXXX hooks\r\n                !Object(shared_esm_bundler["y" /* isReservedProp */])(name)) {\r\n                hasHydrationEventBinding = true;\r\n            }\r\n            if (isEventHandler && Object(shared_esm_bundler["y" /* isReservedProp */])(name)) {\r\n                hasVnodeHook = true;\r\n            }\r\n            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||\r\n                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n                    value.type === 8 /* COMPOUND_EXPRESSION */) &&\r\n                    getConstantType(value, context) > 0)) {\r\n                // skip if the prop is a cached handler or has constant value\r\n                return;\r\n            }\r\n            if (name === \'ref\') {\r\n                hasRef = true;\r\n            }\r\n            else if (name === \'class\' && !isComponent) {\r\n                hasClassBinding = true;\r\n            }\r\n            else if (name === \'style\' && !isComponent) {\r\n                hasStyleBinding = true;\r\n            }\r\n            else if (name !== \'key\' && !dynamicPropNames.includes(name)) {\r\n                dynamicPropNames.push(name);\r\n            }\r\n        }\r\n        else {\r\n            hasDynamicKeys = true;\r\n        }\r\n    };\r\n    for (let i = 0; i < props.length; i++) {\r\n        // static attribute\r\n        const prop = props[i];\r\n        if (prop.type === 6 /* ATTRIBUTE */) {\r\n            const { loc, name, value } = prop;\r\n            let isStatic = true;\r\n            if (name === \'ref\') {\r\n                hasRef = true;\r\n            }\r\n            // skip :is on <component>\r\n            if (name === \'is\' && tag === \'component\') {\r\n                continue;\r\n            }\r\n            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : \'\', isStatic, value ? value.loc : loc)));\r\n        }\r\n        else {\r\n            // directives\r\n            const { name, arg, exp, loc } = prop;\r\n            const isBind = name === \'bind\';\r\n            const isOn = name === \'on\';\r\n            // skip v-slot - it is handled by its dedicated transform.\r\n            if (name === \'slot\') {\r\n                if (!isComponent) {\r\n                    context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            // skip v-once - it is handled by its dedicated transform.\r\n            if (name === \'once\') {\r\n                continue;\r\n            }\r\n            // skip v-is and :is on <component>\r\n            if (name === \'is\' ||\r\n                (isBind && tag === \'component\' && isBindKey(arg, \'is\'))) {\r\n                continue;\r\n            }\r\n            // skip v-on in SSR compilation\r\n            if (isOn && ssr) {\r\n                continue;\r\n            }\r\n            // special case for v-bind and v-on with no argument\r\n            if (!arg && (isBind || isOn)) {\r\n                hasDynamicKeys = true;\r\n                if (exp) {\r\n                    if (properties.length) {\r\n                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n                        properties = [];\r\n                    }\r\n                    if (isBind) {\r\n                        mergeArgs.push(exp);\r\n                    }\r\n                    else {\r\n                        // v-on="obj" -> toHandlers(obj)\r\n                        mergeArgs.push({\r\n                            type: 14 /* JS_CALL_EXPRESSION */,\r\n                            loc,\r\n                            callee: context.helper(TO_HANDLERS),\r\n                            arguments: [exp]\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    context.onError(createCompilerError(isBind\r\n                        ? 33 /* X_V_BIND_NO_EXPRESSION */\r\n                        : 34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            const directiveTransform = context.directiveTransforms[name];\r\n            if (directiveTransform) {\r\n                // has built-in directive transform.\r\n                const { props, needRuntime } = directiveTransform(prop, node, context);\r\n                !ssr && props.forEach(analyzePatchFlag);\r\n                properties.push(...props);\r\n                if (needRuntime) {\r\n                    runtimeDirectives.push(prop);\r\n                    if (Object(shared_esm_bundler["D" /* isSymbol */])(needRuntime)) {\r\n                        directiveImportMap.set(prop, needRuntime);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // no built-in transform, this is a user custom directive.\r\n                runtimeDirectives.push(prop);\r\n            }\r\n        }\r\n    }\r\n    let propsExpression = undefined;\r\n    // has v-bind="object" or v-on="object", wrap with mergeProps\r\n    if (mergeArgs.length) {\r\n        if (properties.length) {\r\n            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n        }\r\n        if (mergeArgs.length > 1) {\r\n            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\r\n        }\r\n        else {\r\n            // single v-bind with nothing else - no need for a mergeProps call\r\n            propsExpression = mergeArgs[0];\r\n        }\r\n    }\r\n    else if (properties.length) {\r\n        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\r\n    }\r\n    // patchFlag analysis\r\n    if (hasDynamicKeys) {\r\n        patchFlag |= 16 /* FULL_PROPS */;\r\n    }\r\n    else {\r\n        if (hasClassBinding) {\r\n            patchFlag |= 2 /* CLASS */;\r\n        }\r\n        if (hasStyleBinding) {\r\n            patchFlag |= 4 /* STYLE */;\r\n        }\r\n        if (dynamicPropNames.length) {\r\n            patchFlag |= 8 /* PROPS */;\r\n        }\r\n        if (hasHydrationEventBinding) {\r\n            patchFlag |= 32 /* HYDRATE_EVENTS */;\r\n        }\r\n    }\r\n    if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&\r\n        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\r\n        patchFlag |= 512 /* NEED_PATCH */;\r\n    }\r\n    return {\r\n        props: propsExpression,\r\n        directives: runtimeDirectives,\r\n        patchFlag,\r\n        dynamicPropNames\r\n    };\r\n}\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it\'s possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties) {\r\n    const knownProps = new Map();\r\n    const deduped = [];\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const prop = properties[i];\r\n        // dynamic keys are always allowed\r\n        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\r\n            deduped.push(prop);\r\n            continue;\r\n        }\r\n        const name = prop.key.content;\r\n        const existing = knownProps.get(name);\r\n        if (existing) {\r\n            if (name === \'style\' || name === \'class\' || name.startsWith(\'on\')) {\r\n                mergeAsArray(existing, prop);\r\n            }\r\n            // unexpected duplicate, should have emitted error during parse\r\n        }\r\n        else {\r\n            knownProps.set(name, prop);\r\n            deduped.push(prop);\r\n        }\r\n    }\r\n    return deduped;\r\n}\r\nfunction mergeAsArray(existing, incoming) {\r\n    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {\r\n        existing.value.elements.push(incoming.value);\r\n    }\r\n    else {\r\n        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\r\n    }\r\n}\r\nfunction buildDirectiveArgs(dir, context) {\r\n    const dirArgs = [];\r\n    const runtime = directiveImportMap.get(dir);\r\n    if (runtime) {\r\n        // built-in directive with runtime\r\n        dirArgs.push(context.helperString(runtime));\r\n    }\r\n    else {\r\n        {\r\n            // inject statement for resolving directive\r\n            context.helper(RESOLVE_DIRECTIVE);\r\n            context.directives.add(dir.name);\r\n            dirArgs.push(toValidAssetId(dir.name, `directive`));\r\n        }\r\n    }\r\n    const { loc } = dir;\r\n    if (dir.exp)\r\n        dirArgs.push(dir.exp);\r\n    if (dir.arg) {\r\n        if (!dir.exp) {\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        dirArgs.push(dir.arg);\r\n    }\r\n    if (Object.keys(dir.modifiers).length) {\r\n        if (!dir.arg) {\r\n            if (!dir.exp) {\r\n                dirArgs.push(`void 0`);\r\n            }\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        const trueExpression = createSimpleExpression(`true`, false, loc);\r\n        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\r\n    }\r\n    return createArrayExpression(dirArgs, dir.loc);\r\n}\r\nfunction stringifyDynamicPropNames(props) {\r\n    let propsNamesString = `[`;\r\n    for (let i = 0, l = props.length; i < l; i++) {\r\n        propsNamesString += JSON.stringify(props[i]);\r\n        if (i < l - 1)\r\n            propsNamesString += \', \';\r\n    }\r\n    return propsNamesString + `]`;\r\n}\n\n( false)\r\n    ? undefined\r\n    : {};\r\n( false) ? undefined : [];\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \'\'));\r\n});\n\nconst transformSlotOutlet = (node, context) => {\r\n    if (isSlotOutlet(node)) {\r\n        const { children, loc } = node;\r\n        const { slotName, slotProps } = processSlotOutlet(node, context);\r\n        const slotArgs = [\r\n            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n            slotName\r\n        ];\r\n        if (slotProps) {\r\n            slotArgs.push(slotProps);\r\n        }\r\n        if (children.length) {\r\n            if (!slotProps) {\r\n                slotArgs.push(`{}`);\r\n            }\r\n            slotArgs.push(createFunctionExpression([], children, false, false, loc));\r\n        }\r\n        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\r\n    }\r\n};\r\nfunction processSlotOutlet(node, context) {\r\n    let slotName = `"default"`;\r\n    let slotProps = undefined;\r\n    const nonNameProps = [];\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (p.value) {\r\n                if (p.name === \'name\') {\r\n                    slotName = JSON.stringify(p.value.content);\r\n                }\r\n                else {\r\n                    p.name = camelize(p.name);\r\n                    nonNameProps.push(p);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (p.name === \'bind\' && isBindKey(p.arg, \'name\')) {\r\n                if (p.exp)\r\n                    slotName = p.exp;\r\n            }\r\n            else {\r\n                if (p.name === \'bind\' && p.arg && isStaticExp(p.arg)) {\r\n                    p.arg.content = camelize(p.arg.content);\r\n                }\r\n                nonNameProps.push(p);\r\n            }\r\n        }\r\n    }\r\n    if (nonNameProps.length > 0) {\r\n        const { props, directives } = buildProps(node, context, nonNameProps);\r\n        slotProps = props;\r\n        if (directives.length) {\r\n            context.onError(createCompilerError(35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\r\n        }\r\n    }\r\n    return {\r\n        slotName,\r\n        slotProps\r\n    };\r\n}\n\nconst fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^\\s*function(?:\\s+[\\w$]+)?\\s*\\(/;\r\nconst transformOn = (dir, node, context, augmentor) => {\r\n    const { loc, modifiers, arg } = dir;\r\n    if (!dir.exp && !modifiers.length) {\r\n        context.onError(createCompilerError(34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n    }\r\n    let eventName;\r\n    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        if (arg.isStatic) {\r\n            const rawName = arg.content;\r\n            // for all event listeners, auto convert it to camelCase. See issue #2249\r\n            eventName = createSimpleExpression(Object(shared_esm_bundler["N" /* toHandlerKey */])(Object(shared_esm_bundler["f" /* camelize */])(rawName)), true, arg.loc);\r\n        }\r\n        else {\r\n            // #2388\r\n            eventName = createCompoundExpression([\r\n                `${context.helperString(TO_HANDLER_KEY)}(`,\r\n                arg,\r\n                `)`\r\n            ]);\r\n        }\r\n    }\r\n    else {\r\n        // already a compound expression.\r\n        eventName = arg;\r\n        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\r\n        eventName.children.push(`)`);\r\n    }\r\n    // handler processing\r\n    let exp = dir.exp;\r\n    if (exp && !exp.content.trim()) {\r\n        exp = undefined;\r\n    }\r\n    let shouldCache = context.cacheHandlers && !exp;\r\n    if (exp) {\r\n        const isMemberExp = isMemberExpression(exp.content);\r\n        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\r\n        const hasMultipleStatements = exp.content.includes(`;`);\r\n        if (false) {}\r\n        if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n            // wrap inline statement in a function expression\r\n            exp = createCompoundExpression([\r\n                `${isInlineStatement\r\n                    ? `$event`\r\n                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\r\n                exp,\r\n                hasMultipleStatements ? `}` : `)`\r\n            ]);\r\n        }\r\n    }\r\n    let ret = {\r\n        props: [\r\n            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))\r\n        ]\r\n    };\r\n    // apply extended compiler augmentor\r\n    if (augmentor) {\r\n        ret = augmentor(ret);\r\n    }\r\n    if (shouldCache) {\r\n        // cache handlers so that it\'s always the same handler being passed down.\r\n        // this avoids unnecessary re-renders when users use inline handlers on\r\n        // components.\r\n        ret.props[0].value = context.cache(ret.props[0].value);\r\n    }\r\n    return ret;\r\n};\n\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n// codegen for the entire props object. This transform here is only for v-bind\r\n// *with* args.\r\nconst transformBind = (dir, node, context) => {\r\n    const { exp, modifiers, loc } = dir;\r\n    const arg = dir.arg;\r\n    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n        arg.children.unshift(`(`);\r\n        arg.children.push(`) || ""`);\r\n    }\r\n    else if (!arg.isStatic) {\r\n        arg.content = `${arg.content} || ""`;\r\n    }\r\n    // .prop is no longer necessary due to new patch behavior\r\n    // .sync is replaced by v-model:arg\r\n    if (modifiers.includes(\'camel\')) {\r\n        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            if (arg.isStatic) {\r\n                arg.content = Object(shared_esm_bundler["f" /* camelize */])(arg.content);\r\n            }\r\n            else {\r\n                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\r\n            }\r\n        }\r\n        else {\r\n            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\r\n            arg.children.push(`)`);\r\n        }\r\n    }\r\n    if (!exp ||\r\n        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {\r\n        context.onError(createCompilerError(33 /* X_V_BIND_NO_EXPRESSION */, loc));\r\n        return {\r\n            props: [createObjectProperty(arg, createSimpleExpression(\'\', true, loc))]\r\n        };\r\n    }\r\n    return {\r\n        props: [createObjectProperty(arg, exp)]\r\n    };\r\n};\n\n// Merge adjacent text nodes and expressions into a single expression\r\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\nconst transformText = (node, context) => {\r\n    if (node.type === 0 /* ROOT */ ||\r\n        node.type === 1 /* ELEMENT */ ||\r\n        node.type === 11 /* FOR */ ||\r\n        node.type === 10 /* IF_BRANCH */) {\r\n        // perform the transform on node exit so that all expressions have already\r\n        // been processed.\r\n        return () => {\r\n            const children = node.children;\r\n            let currentContainer = undefined;\r\n            let hasText = false;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child)) {\r\n                    hasText = true;\r\n                    for (let j = i + 1; j < children.length; j++) {\r\n                        const next = children[j];\r\n                        if (isText(next)) {\r\n                            if (!currentContainer) {\r\n                                currentContainer = children[i] = {\r\n                                    type: 8 /* COMPOUND_EXPRESSION */,\r\n                                    loc: child.loc,\r\n                                    children: [child]\r\n                                };\r\n                            }\r\n                            // merge adjacent text node into current\r\n                            currentContainer.children.push(` + `, next);\r\n                            children.splice(j, 1);\r\n                            j--;\r\n                        }\r\n                        else {\r\n                            currentContainer = undefined;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!hasText ||\r\n                // if this is a plain element with a single text child, leave it\r\n                // as-is since the runtime has dedicated fast path for this by directly\r\n                // setting textContent of the element.\r\n                // for component root it\'s always normalized anyway.\r\n                (children.length === 1 &&\r\n                    (node.type === 0 /* ROOT */ ||\r\n                        (node.type === 1 /* ELEMENT */ &&\r\n                            node.tagType === 0 /* ELEMENT */)))) {\r\n                return;\r\n            }\r\n            // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n            // runtime normalization.\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {\r\n                    const callArgs = [];\r\n                    // createTextVNode defaults to single whitespace, so if it is a\r\n                    // single space the code could be an empty call to save bytes.\r\n                    if (child.type !== 2 /* TEXT */ || child.content !== \' \') {\r\n                        callArgs.push(child);\r\n                    }\r\n                    // mark dynamic text with flag so it gets patched inside a block\r\n                    if (!context.ssr &&\r\n                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                        callArgs.push(1 /* TEXT */ +\r\n                            (( false) ? undefined : ``));\r\n                    }\r\n                    children[i] = {\r\n                        type: 12 /* TEXT_CALL */,\r\n                        content: child,\r\n                        loc: child.loc,\r\n                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\r\n                    };\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\n\nconst compiler_core_esm_bundler_seen = new WeakSet();\r\nconst transformOnce = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ && findDir(node, \'once\', true)) {\r\n        if (compiler_core_esm_bundler_seen.has(node)) {\r\n            return;\r\n        }\r\n        compiler_core_esm_bundler_seen.add(node);\r\n        context.helper(SET_BLOCK_TRACKING);\r\n        return () => {\r\n            const cur = context.currentNode;\r\n            if (cur.codegenNode) {\r\n                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\r\n            }\r\n        };\r\n    }\r\n};\n\nconst transformModel = (dir, node, context) => {\r\n    const { exp, arg } = dir;\r\n    if (!exp) {\r\n        context.onError(createCompilerError(40 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));\r\n        return createTransformProps();\r\n    }\r\n    const rawExp = exp.loc.source;\r\n    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;\r\n    // im SFC <script setup> inline mode, the exp may have been transformed into\r\n    // _unref(exp)\r\n    context.bindingMetadata[rawExp];\r\n    const maybeRef = !true    /* SETUP_CONST */;\r\n    if (!isMemberExpression(expString) && !maybeRef) {\r\n        context.onError(createCompilerError(41 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\r\n        return createTransformProps();\r\n    }\r\n    const propName = arg ? arg : createSimpleExpression(\'modelValue\', true);\r\n    const eventName = arg\r\n        ? isStaticExp(arg)\r\n            ? `onUpdate:${arg.content}`\r\n            : createCompoundExpression([\'"onUpdate:" + \', arg])\r\n        : `onUpdate:modelValue`;\r\n    let assignmentExp;\r\n    const eventArg = context.isTS ? `($event: any)` : `$event`;\r\n    {\r\n        assignmentExp = createCompoundExpression([\r\n            `${eventArg} => (`,\r\n            exp,\r\n            ` = $event)`\r\n        ]);\r\n    }\r\n    const props = [\r\n        // modelValue: foo\r\n        createObjectProperty(propName, dir.exp),\r\n        // "onUpdate:modelValue": $event => (foo = $event)\r\n        createObjectProperty(eventName, assignmentExp)\r\n    ];\r\n    // modelModifiers: { foo: true, "bar-baz": true }\r\n    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {\r\n        const modifiers = dir.modifiers\r\n            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n            .join(`, `);\r\n        const modifiersKey = arg\r\n            ? isStaticExp(arg)\r\n                ? `${arg.content}Modifiers`\r\n                : createCompoundExpression([arg, \' + "Modifiers"\'])\r\n            : `modelModifiers`;\r\n        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));\r\n    }\r\n    return createTransformProps(props);\r\n};\r\nfunction createTransformProps(props = []) {\r\n    return { props };\r\n}\n\nfunction getBaseTransformPreset(prefixIdentifiers) {\r\n    return [\r\n        [\r\n            transformOnce,\r\n            transformIf,\r\n            transformFor,\r\n            ...(( false)\r\n                    ? undefined\r\n                    : []),\r\n            transformSlotOutlet,\r\n            transformElement,\r\n            trackSlotScopes,\r\n            transformText\r\n        ],\r\n        {\r\n            on: transformOn,\r\n            bind: transformBind,\r\n            model: transformModel\r\n        }\r\n    ];\r\n}\r\n// we name it `baseCompile` so that higher order compilers like\r\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\r\nfunction baseCompile(template, options = {}) {\r\n    const onError = options.onError || defaultOnError;\r\n    const isModuleMode = options.mode === \'module\';\r\n    /* istanbul ignore if */\r\n    {\r\n        if (options.prefixIdentifiers === true) {\r\n            onError(createCompilerError(45 /* X_PREFIX_ID_NOT_SUPPORTED */));\r\n        }\r\n        else if (isModuleMode) {\r\n            onError(createCompilerError(46 /* X_MODULE_MODE_NOT_SUPPORTED */));\r\n        }\r\n    }\r\n    const prefixIdentifiers = !true ;\r\n    if (options.cacheHandlers) {\r\n        onError(createCompilerError(47 /* X_CACHE_HANDLER_NOT_SUPPORTED */));\r\n    }\r\n    if (options.scopeId && !isModuleMode) {\r\n        onError(createCompilerError(48 /* X_SCOPE_ID_NOT_SUPPORTED */));\r\n    }\r\n    const ast = Object(shared_esm_bundler["C" /* isString */])(template) ? baseParse(template, options) : template;\r\n    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\r\n    transform(ast, Object(shared_esm_bundler["i" /* extend */])({}, options, {\r\n        prefixIdentifiers,\r\n        nodeTransforms: [\r\n            ...nodeTransforms,\r\n            ...(options.nodeTransforms || []) // user transforms\r\n        ],\r\n        directiveTransforms: Object(shared_esm_bundler["i" /* extend */])({}, directiveTransforms, options.directiveTransforms || {} // user transforms\r\n        )\r\n    }));\r\n    return generate(ast, Object(shared_esm_bundler["i" /* extend */])({}, options, {\r\n        prefixIdentifiers\r\n    }));\r\n}\n\nconst noopDirectiveTransform = () => ({ props: [] });\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js\n\n\n\n\nconst V_MODEL_RADIO = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_CHECKBOX = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_TEXT = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_SELECT = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_DYNAMIC = Symbol(( false) ? undefined : ``);\r\nconst V_ON_WITH_MODIFIERS = Symbol(( false) ? undefined : ``);\r\nconst V_ON_WITH_KEYS = Symbol(( false) ? undefined : ``);\r\nconst V_SHOW = Symbol(( false) ? undefined : ``);\r\nconst compiler_dom_esm_bundler_TRANSITION = Symbol(( false) ? undefined : ``);\r\nconst TRANSITION_GROUP = Symbol(( false) ? undefined : ``);\r\nregisterRuntimeHelpers({\r\n    [V_MODEL_RADIO]: `vModelRadio`,\r\n    [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n    [V_MODEL_TEXT]: `vModelText`,\r\n    [V_MODEL_SELECT]: `vModelSelect`,\r\n    [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n    [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n    [V_ON_WITH_KEYS]: `withKeys`,\r\n    [V_SHOW]: `vShow`,\r\n    [compiler_dom_esm_bundler_TRANSITION]: `Transition`,\r\n    [TRANSITION_GROUP]: `TransitionGroup`\r\n});\n\n/* eslint-disable no-restricted-globals */\r\nlet decoder;\r\nfunction decodeHtmlBrowser(raw) {\r\n    (decoder || (decoder = document.createElement(\'div\'))).innerHTML = raw;\r\n    return decoder.textContent;\r\n}\n\nconst isRawTextContainer = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'style,iframe,script,noscript\', true);\r\nconst parserOptions = {\r\n    isVoidTag: shared_esm_bundler["E" /* isVoidTag */],\r\n    isNativeTag: tag => Object(shared_esm_bundler["r" /* isHTMLTag */])(tag) || Object(shared_esm_bundler["z" /* isSVGTag */])(tag),\r\n    isPreTag: tag => tag === \'pre\',\r\n    decodeEntities: decodeHtmlBrowser ,\r\n    isBuiltInComponent: (tag) => {\r\n        if (isBuiltInType(tag, `Transition`)) {\r\n            return compiler_dom_esm_bundler_TRANSITION;\r\n        }\r\n        else if (isBuiltInType(tag, `TransitionGroup`)) {\r\n            return TRANSITION_GROUP;\r\n        }\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n    getNamespace(tag, parent) {\r\n        let ns = parent ? parent.ns : 0 /* HTML */;\r\n        if (parent && ns === 2 /* MATH_ML */) {\r\n            if (parent.tag === \'annotation-xml\') {\r\n                if (tag === \'svg\') {\r\n                    return 1 /* SVG */;\r\n                }\r\n                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&\r\n                    a.name === \'encoding\' &&\r\n                    a.value != null &&\r\n                    (a.value.content === \'text/html\' ||\r\n                        a.value.content === \'application/xhtml+xml\'))) {\r\n                    ns = 0 /* HTML */;\r\n                }\r\n            }\r\n            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&\r\n                tag !== \'mglyph\' &&\r\n                tag !== \'malignmark\') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        else if (parent && ns === 1 /* SVG */) {\r\n            if (parent.tag === \'foreignObject\' ||\r\n                parent.tag === \'desc\' ||\r\n                parent.tag === \'title\') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === \'svg\') {\r\n                return 1 /* SVG */;\r\n            }\r\n            if (tag === \'math\') {\r\n                return 2 /* MATH_ML */;\r\n            }\r\n        }\r\n        return ns;\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\r\n    getTextMode({ tag, ns }) {\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === \'textarea\' || tag === \'title\') {\r\n                return 1 /* RCDATA */;\r\n            }\r\n            if (isRawTextContainer(tag)) {\r\n                return 2 /* RAWTEXT */;\r\n            }\r\n        }\r\n        return 0 /* DATA */;\r\n    }\r\n};\n\n// Parse inline CSS strings for static style attributes into an object.\r\n// This is a NodeTransform since it works on the static `style` attribute and\r\n// converts it into a dynamic equivalent:\r\n// style="color: red" -> :style=\'{ "color": "red" }\'\r\n// It is then processed by `transformElement` and included in the generated\r\n// props.\r\nconst transformStyle = node => {\r\n    if (node.type === 1 /* ELEMENT */) {\r\n        node.props.forEach((p, i) => {\r\n            if (p.type === 6 /* ATTRIBUTE */ && p.name === \'style\' && p.value) {\r\n                // replace p with an expression node\r\n                node.props[i] = {\r\n                    type: 7 /* DIRECTIVE */,\r\n                    name: `bind`,\r\n                    arg: createSimpleExpression(`style`, true, p.loc),\r\n                    exp: parseInlineCSS(p.value.content, p.loc),\r\n                    modifiers: [],\r\n                    loc: p.loc\r\n                };\r\n            }\r\n        });\r\n    }\r\n};\r\nconst parseInlineCSS = (cssText, loc) => {\r\n    const normalized = Object(shared_esm_bundler["K" /* parseStringStyle */])(cssText);\r\n    return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);\r\n};\n\nfunction createDOMCompilerError(code, loc) {\r\n    return createCompilerError(code, loc,  false ? undefined : undefined);\r\n}\r\nconst DOMErrorMessages = {\r\n    [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\r\n    [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\r\n    [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\r\n    [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\r\n    [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n    [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\r\n    [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n    [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model\'s behavior.`,\r\n    [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\r\n    [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\r\n    [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\r\n};\n\nconst transformVHtml = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression(\'\', true))\r\n        ]\r\n    };\r\n};\n\nconst transformVText = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            createObjectProperty(createSimpleExpression(`textContent`, true), exp\r\n                ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)\r\n                : createSimpleExpression(\'\', true))\r\n        ]\r\n    };\r\n};\n\nconst compiler_dom_esm_bundler_transformModel = (dir, node, context) => {\r\n    const baseResult = transformModel(dir, node, context);\r\n    // base transform has errors OR component v-model (only need props)\r\n    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {\r\n        return baseResult;\r\n    }\r\n    if (dir.arg) {\r\n        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\r\n    }\r\n    function checkDuplicatedValue() {\r\n        const value = findProp(node, \'value\');\r\n        if (value) {\r\n            context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\r\n        }\r\n    }\r\n    const { tag } = node;\r\n    const isCustomElement = context.isCustomElement(tag);\r\n    if (tag === \'input\' ||\r\n        tag === \'textarea\' ||\r\n        tag === \'select\' ||\r\n        isCustomElement) {\r\n        let directiveToUse = V_MODEL_TEXT;\r\n        let isInvalidType = false;\r\n        if (tag === \'input\' || isCustomElement) {\r\n            const type = findProp(node, `type`);\r\n            if (type) {\r\n                if (type.type === 7 /* DIRECTIVE */) {\r\n                    // :type="foo"\r\n                    directiveToUse = V_MODEL_DYNAMIC;\r\n                }\r\n                else if (type.value) {\r\n                    switch (type.value.content) {\r\n                        case \'radio\':\r\n                            directiveToUse = V_MODEL_RADIO;\r\n                            break;\r\n                        case \'checkbox\':\r\n                            directiveToUse = V_MODEL_CHECKBOX;\r\n                            break;\r\n                        case \'file\':\r\n                            isInvalidType = true;\r\n                            context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\r\n                            break;\r\n                        default:\r\n                            // text type\r\n                            ( false) && false;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            else if (hasDynamicKeyVBind(node)) {\r\n                // element has bindings with dynamic keys, which can possibly contain\r\n                // "type".\r\n                directiveToUse = V_MODEL_DYNAMIC;\r\n            }\r\n            else {\r\n                // text type\r\n                ( false) && false;\r\n            }\r\n        }\r\n        else if (tag === \'select\') {\r\n            directiveToUse = V_MODEL_SELECT;\r\n        }\r\n        else {\r\n            // textarea\r\n            ( false) && false;\r\n        }\r\n        // inject runtime directive\r\n        // by returning the helper symbol via needRuntime\r\n        // the import will replaced a resolveDirective call.\r\n        if (!isInvalidType) {\r\n            baseResult.needRuntime = context.helper(directiveToUse);\r\n        }\r\n    }\r\n    else {\r\n        context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\r\n    }\r\n    // native vmodel doesn\'t need the `modelValue` props since they are also\r\n    // passed to the runtime as `binding.value`. removing it reduces code size.\r\n    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n        p.key.content === \'modelValue\'));\r\n    return baseResult;\r\n};\n\nconst isEventOptionModifier = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`passive,once,capture`);\r\nconst isNonKeyModifier = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\r\n// event propagation management\r\n`stop,prevent,self,` +\r\n    // system modifiers + exact\r\n    `ctrl,shift,alt,meta,exact,` +\r\n    // mouse\r\n    `middle`);\r\n// left & right could be mouse or key modifiers based on event type\r\nconst maybeKeyModifier = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'left,right\');\r\nconst isKeyboardEvent = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`onkeyup,onkeydown,onkeypress`, true);\r\nconst resolveModifiers = (key, modifiers) => {\r\n    const keyModifiers = [];\r\n    const nonKeyModifiers = [];\r\n    const eventOptionModifiers = [];\r\n    for (let i = 0; i < modifiers.length; i++) {\r\n        const modifier = modifiers[i];\r\n        if (isEventOptionModifier(modifier)) {\r\n            // eventOptionModifiers: modifiers for addEventListener() options,\r\n            // e.g. .passive & .capture\r\n            eventOptionModifiers.push(modifier);\r\n        }\r\n        else {\r\n            // runtimeModifiers: modifiers that needs runtime guards\r\n            if (maybeKeyModifier(modifier)) {\r\n                if (isStaticExp(key)) {\r\n                    if (isKeyboardEvent(key.content)) {\r\n                        keyModifiers.push(modifier);\r\n                    }\r\n                    else {\r\n                        nonKeyModifiers.push(modifier);\r\n                    }\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n            }\r\n            else {\r\n                if (isNonKeyModifier(modifier)) {\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        keyModifiers,\r\n        nonKeyModifiers,\r\n        eventOptionModifiers\r\n    };\r\n};\r\nconst transformClick = (key, event) => {\r\n    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === \'onclick\';\r\n    return isStaticClick\r\n        ? createSimpleExpression(event, true)\r\n        : key.type !== 4 /* SIMPLE_EXPRESSION */\r\n            ? createCompoundExpression([\r\n                `(`,\r\n                key,\r\n                `) === "onClick" ? "${event}" : (`,\r\n                key,\r\n                `)`\r\n            ])\r\n            : key;\r\n};\r\nconst compiler_dom_esm_bundler_transformOn = (dir, node, context) => {\r\n    return transformOn(dir, node, context, baseResult => {\r\n        const { modifiers } = dir;\r\n        if (!modifiers.length)\r\n            return baseResult;\r\n        let { key, value: handlerExp } = baseResult.props[0];\r\n        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);\r\n        // normalize click.right and click.middle since they don\'t actually fire\r\n        if (nonKeyModifiers.includes(\'right\')) {\r\n            key = transformClick(key, `onContextmenu`);\r\n        }\r\n        if (nonKeyModifiers.includes(\'middle\')) {\r\n            key = transformClick(key, `onMouseup`);\r\n        }\r\n        if (nonKeyModifiers.length) {\r\n            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n                handlerExp,\r\n                JSON.stringify(nonKeyModifiers)\r\n            ]);\r\n        }\r\n        if (keyModifiers.length &&\r\n            // if event name is dynamic, always wrap with keys guard\r\n            (!isStaticExp(key) || isKeyboardEvent(key.content))) {\r\n            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n                handlerExp,\r\n                JSON.stringify(keyModifiers)\r\n            ]);\r\n        }\r\n        if (eventOptionModifiers.length) {\r\n            const modifierPostfix = eventOptionModifiers.map(shared_esm_bundler["g" /* capitalize */]).join(\'\');\r\n            key = isStaticExp(key)\r\n                ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n                : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);\r\n        }\r\n        return {\r\n            props: [createObjectProperty(key, handlerExp)]\r\n        };\r\n    });\r\n};\n\nconst transformShow = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));\r\n    }\r\n    return {\r\n        props: [],\r\n        needRuntime: context.helper(V_SHOW)\r\n    };\r\n};\n\nconst warnTransitionChildren = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 1 /* COMPONENT */) {\r\n        const component = context.isBuiltInComponent(node.tag);\r\n        if (component === compiler_dom_esm_bundler_TRANSITION) {\r\n            return () => {\r\n                if (node.children.length && hasMultipleChildren(node)) {\r\n                    context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {\r\n                        start: node.children[0].loc.start,\r\n                        end: node.children[node.children.length - 1].loc.end,\r\n                        source: \'\'\r\n                    }));\r\n                }\r\n            };\r\n        }\r\n    }\r\n};\r\nfunction hasMultipleChildren(node) {\r\n    // #1352 filter out potential comment nodes.\r\n    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));\r\n    const child = children[0];\r\n    return (children.length !== 1 ||\r\n        child.type === 11 /* FOR */ ||\r\n        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));\r\n}\n\nconst ignoreSideEffectTags = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 0 /* ELEMENT */ &&\r\n        (node.tag === \'script\' || node.tag === \'style\')) {\r\n        context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\r\n        context.removeNode();\r\n    }\r\n};\n\nconst DOMNodeTransforms = [\r\n    transformStyle,\r\n    ...(( false) ? undefined : [])\r\n];\r\nconst DOMDirectiveTransforms = {\r\n    cloak: noopDirectiveTransform,\r\n    html: transformVHtml,\r\n    text: transformVText,\r\n    model: compiler_dom_esm_bundler_transformModel,\r\n    on: compiler_dom_esm_bundler_transformOn,\r\n    show: transformShow\r\n};\r\nfunction compiler_dom_esm_bundler_compile(template, options = {}) {\r\n    return baseCompile(template, Object(shared_esm_bundler["i" /* extend */])({}, parserOptions, options, {\r\n        nodeTransforms: [\r\n            // ignore <script> and <tag>\r\n            // this is not put inside DOMNodeTransforms because that list is used\r\n            // by compiler-ssr to generate vnode fallback branches\r\n            ignoreSideEffectTags,\r\n            ...DOMNodeTransforms,\r\n            ...(options.nodeTransforms || [])\r\n        ],\r\n        directiveTransforms: Object(shared_esm_bundler["i" /* extend */])({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\r\n        transformHoist: null \r\n    }));\r\n}\r\nfunction parse(template, options = {}) {\r\n    return baseParse(template, Object(shared_esm_bundler["i" /* extend */])({}, parserOptions, options));\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/vue/dist/vue.esm-bundler.js\n\n\n\n\n\n\nfunction initDev() {\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry is the "full-build" that includes both the runtime\r\nif ((false)) {}\r\nconst compileCache = Object.create(null);\r\nfunction compileToFunction(template, options) {\r\n    if (!Object(shared_esm_bundler["C" /* isString */])(template)) {\r\n        if (template.nodeType) {\r\n            template = template.innerHTML;\r\n        }\r\n        else {\r\n            ( false) && false;\r\n            return shared_esm_bundler["d" /* NOOP */];\r\n        }\r\n    }\r\n    const key = template;\r\n    const cached = compileCache[key];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    if (template[0] === \'#\') {\r\n        const el = document.querySelector(template);\r\n        if (false) {}\r\n        // __UNSAFE__\r\n        // Reason: potential execution of JS expressions in in-DOM template.\r\n        // The user must make sure the in-DOM template is trusted. If it\'s rendered\r\n        // by the server, the template should not contain any user data.\r\n        template = el ? el.innerHTML : ``;\r\n    }\r\n    const { code } = compiler_dom_esm_bundler_compile(template, Object(shared_esm_bundler["i" /* extend */])({\r\n        hoistStatic: true,\r\n        onError(err) {\r\n            if ((false)) {}\r\n            else {\r\n                /* istanbul ignore next */\r\n                throw err;\r\n            }\r\n        }\r\n    }, options));\r\n    // The wildcard import results in a huge object with every export\r\n    // with keys that cannot be mangled, and can be quite heavy size-wise.\r\n    // In the global build we know `Vue` is available globally so we can avoid\r\n    // the wildcard object.\r\n    const render = (new Function(\'Vue\', code)(runtime_dom_esm_bundler_namespaceObject));\r\n    render._rc = true;\r\n    return (compileCache[key] = render);\r\n}\r\nregisterRuntimeCompiler(compileToFunction);\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcz9hMWU5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcz81YzQwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanM/ODMwZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcz8yYmVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWRvbS9kaXN0L2NvbXBpbGVyLWRvbS5lc20tYnVuZGxlci5qcz9lZTUxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanM/ZjJiZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZLOztBQUU3SztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBcUMsSUFBSSxTQUFTO0FBQzlFLG9DQUFvQyxNQUFxQyxJQUFJLFNBQWlCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQU0sZUFBZSx1Q0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4QkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhNQUE4TTtBQUN6TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLCtDQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQU87QUFDbkIsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNkNBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxQ0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBcUMsSUFBSSxTQUFnQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBLG9CQUFvQiw4Q0FBUSxXQUFXLDhDQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFxQyxHQUFHLEVBQUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsdUJBQXVCLHVCQUF1QjtBQUM5QyxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsb0lBQW9JLDhDQUE4QyxrQ0FBSSxvQkFBb0Isa0NBQUksMEZBQTBGLHVDQUFTLDBEQUEwRDtBQUNsWjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0RBQVUsQ0FBQyw4Q0FBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCLG9DQUFvQztBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixLQUFxQyxHQUFHLEVBTzVDO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0IsS0FBMEQsRUFBRSxFQUUvRDtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQTJELEVBQUUsRUFFaEU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4QkFBOEIsRUFBRTtBQUNoQztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0VBQWtFLHNCQUFzQjtBQUN4RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQ0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQWM7QUFDMUM7QUFDQTtBQUNBLFlBQVksS0FDNkQsRUFBRSxFQUdsRTtBQUNULDhHQUE4RyxNQUFxQyxJQUFJLFNBQXlCO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBLFlBQVksOENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQywwTkFBME47QUFDOVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUVBQXlFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYSxHQUFHLFVBQVUsR0FBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsR0FBRztBQUM1Qiw2QkFBNkIsaUJBQWlCLEtBQUssaUJBQWlCO0FBQ3BFLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsb0JBQW9CLGtCQUFrQixPQUFPLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4RUFBOEU7QUFDekY7QUFDQSxrQ0FBa0MsaUJBQWlCLEtBQUssaUJBQWlCO0FBQ3pFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEdBQUcsY0FBYyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSxzQkFBc0IseUJBQXlCLEtBQUssU0FBUyxHQUFHLG1CQUFtQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxNQUFNLEtBQTJDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLFlBQVksOENBQVE7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFxQztBQUNsRCxnQkFBZ0IsS0FDMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFxQyxHQUFHLEVBSzVDO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBLFlBQVksOENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUMsR0FBRyxFQU01QztBQUNMO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHNGQUFzRjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsR0FBRyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLG1CQUFtQiw4Q0FBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUM7QUFDaEQsWUFBWSxLQUFnRTtBQUM1RSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUMsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdDQUF3QztBQUNuRCxXQUFXLHlDQUF5QztBQUNwRDtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBLFFBQVEsNkNBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0QsV0FBVyxrQ0FBa0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUEwQztBQUNyRCxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsR0FBRztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEIsd0JBQXdCLGVBQWUsSUFBSSxPQUFPLFFBQVEsSUFBSSxHQUFHO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQyxHQUFHLEVBRzVDO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQTBELEVBQUUsRUFFL0Q7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUF3RSxnQkFBZ0IsRUFJM0Y7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUEwRCxFQUFFLEVBRS9EO0FBQ2pCO0FBQ0Esb0JBQW9CLEtBQWdELEVBQUUsRUFTckQ7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFxQyxJQUFJLFNBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQiw4RUFBOEUsU0FBUztBQUN2RixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFxQztBQUN2RCxzQkFBc0IsU0FBb0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFxQyxJQUFJLFNBQXdDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQSxnQkFBZ0IsS0FBZ0UsRUFBRSxFQVVyRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDO0FBQzNELDBCQUEwQixTQUFvRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0QztBQUN2RCxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBK0MsRUFBRSxFQUVwRDtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUErQyxFQUFFLEVBRXBEO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBK0MsRUFBRSxFQUVwRDtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUErQyxFQUFFLEVBRXBEO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBCQUEwQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QyxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3RELGVBQWUsdUZBQXVGO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBcUMsSUFBSSxTQUFtQztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCLG1DQUFtQyw4Q0FBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBbUUsRUFBRSxFQU14RTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDLEdBQUcsRUFjNUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQywwQ0FBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFjO0FBQy9CO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNq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Q0EscUNBQXFDO0FBQ3JDLFdBQVcsU0FBUyxXQUFXLDRDQUFNLEdBQUc7QUFDeEM7O0FBRXVSOzs7QUMvYnhPO0FBQ3VDO0FBQ3JEO0FBQ1c7QUFDNEI7O0FBRXhFO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0EsS0FBSyxLQUFxQyxHQUFHLEVBRTVDO0FBQ0Q7QUFDQTtBQUNBLFNBQVMsOENBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQXFDLEtBQUssS0FBMkM7QUFDbEcsbUJBQW1CLGtDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBOEMsRUFBRSxFQUVuRDtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxHQUFHLGdDQUFPLFdBQVcsNENBQU07QUFDN0M7QUFDQTtBQUNBLGlCQUFpQixLQUFxQyxHQUFHLEVBSzVDO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRWlCIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTVBUWV9PQkosIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBleHRlbmQsIGhhc093biwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBlZmZlY3RTdGFjayA9IFtdO1xyXG5sZXQgYWN0aXZlRWZmZWN0O1xyXG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnaXRlcmF0ZScgOiAnJyk7XHJcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ01hcCBrZXkgaXRlcmF0ZScgOiAnJyk7XHJcbmZ1bmN0aW9uIGlzRWZmZWN0KGZuKSB7XHJcbiAgICByZXR1cm4gZm4gJiYgZm4uX2lzRWZmZWN0ID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xyXG4gICAgaWYgKGlzRWZmZWN0KGZuKSkge1xyXG4gICAgICAgIGZuID0gZm4ucmF3O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0ID0gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpO1xyXG4gICAgaWYgKCFvcHRpb25zLmxhenkpIHtcclxuICAgICAgICBlZmZlY3QoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlZmZlY3Q7XHJcbn1cclxuZnVuY3Rpb24gc3RvcChlZmZlY3QpIHtcclxuICAgIGlmIChlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgY2xlYW51cChlZmZlY3QpO1xyXG4gICAgICAgIGlmIChlZmZlY3Qub3B0aW9ucy5vblN0b3ApIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMub25TdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVmZmVjdC5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGVmZmVjdCA9IGZ1bmN0aW9uIHJlYWN0aXZlRWZmZWN0KCkge1xyXG4gICAgICAgIGlmICghZWZmZWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zY2hlZHVsZXIgPyB1bmRlZmluZWQgOiBmbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVmZmVjdFN0YWNrLmluY2x1ZGVzKGVmZmVjdCkpIHtcclxuICAgICAgICAgICAgY2xlYW51cChlZmZlY3QpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIGVmZmVjdFN0YWNrLnB1c2goZWZmZWN0KTtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3RTdGFja1tlZmZlY3RTdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBlZmZlY3QuaWQgPSB1aWQrKztcclxuICAgIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSAhIW9wdGlvbnMuYWxsb3dSZWN1cnNlO1xyXG4gICAgZWZmZWN0Ll9pc0VmZmVjdCA9IHRydWU7XHJcbiAgICBlZmZlY3QuYWN0aXZlID0gdHJ1ZTtcclxuICAgIGVmZmVjdC5yYXcgPSBmbjtcclxuICAgIGVmZmVjdC5kZXBzID0gW107XHJcbiAgICBlZmZlY3Qub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICByZXR1cm4gZWZmZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFudXAoZWZmZWN0KSB7XHJcbiAgICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcclxuICAgIGlmIChkZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXBzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcclxuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcclxuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGxhc3Q7XHJcbn1cclxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcclxuICAgIGlmICghc2hvdWxkVHJhY2sgfHwgYWN0aXZlRWZmZWN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCAoZGVwc01hcCA9IG5ldyBNYXAoKSkpO1xyXG4gICAgfVxyXG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XHJcbiAgICBpZiAoIWRlcCkge1xyXG4gICAgICAgIGRlcHNNYXAuc2V0KGtleSwgKGRlcCA9IG5ldyBTZXQoKSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkZXAuaGFzKGFjdGl2ZUVmZmVjdCkpIHtcclxuICAgICAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjaykge1xyXG4gICAgICAgICAgICBhY3RpdmVFZmZlY3Qub3B0aW9ucy5vblRyYWNrKHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlRWZmZWN0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIGtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcclxuICAgIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICAvLyBuZXZlciBiZWVuIHRyYWNrZWRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBlZmZlY3RzID0gbmV3IFNldCgpO1xyXG4gICAgY29uc3QgYWRkID0gKGVmZmVjdHNUb0FkZCkgPT4ge1xyXG4gICAgICAgIGlmIChlZmZlY3RzVG9BZGQpIHtcclxuICAgICAgICAgICAgZWZmZWN0c1RvQWRkLmZvckVhY2goZWZmZWN0ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3QuYWxsb3dSZWN1cnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0cy5hZGQoZWZmZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIgLyogQ0xFQVIgKi8pIHtcclxuICAgICAgICAvLyBjb2xsZWN0aW9uIGJlaW5nIGNsZWFyZWRcclxuICAgICAgICAvLyB0cmlnZ2VyIGFsbCBlZmZlY3RzIGZvciB0YXJnZXRcclxuICAgICAgICBkZXBzTWFwLmZvckVhY2goYWRkKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ2xlbmd0aCcgJiYgaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbGVuZ3RoJyB8fCBrZXkgPj0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZChkZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzY2hlZHVsZSBydW5zIGZvciBTRVQgfCBBREQgfCBERUxFVEVcclxuICAgICAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbHNvIHJ1biBmb3IgaXRlcmF0aW9uIGtleSBvbiBBREQgfCBERUxFVEUgfCBNYXAuU0VUXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhZGRcIiAvKiBBREQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlZ2VyS2V5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgaW5kZXggYWRkZWQgdG8gYXJyYXkgLT4gbGVuZ3RoIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoJ2xlbmd0aCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCIgLyogREVMRVRFICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic2V0XCIgLyogU0VUICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJ1biA9IChlZmZlY3QpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGVmZmVjdC5vcHRpb25zLm9uVHJpZ2dlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5vblRyaWdnZXIoe1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvbGRUYXJnZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlZmZlY3Qub3B0aW9ucy5zY2hlZHVsZXIpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMuc2NoZWR1bGVyKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlZmZlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZWZmZWN0cy5mb3JFYWNoKHJ1bik7XHJcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcclxuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbClcclxuICAgIC5tYXAoa2V5ID0+IFN5bWJvbFtrZXldKVxyXG4gICAgLmZpbHRlcihpc1N5bWJvbCkpO1xyXG5jb25zdCBnZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcigpO1xyXG5jb25zdCBzaGFsbG93R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xyXG5jb25zdCByZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcclxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0ge307XHJcblsnaW5jbHVkZXMnLCAnaW5kZXhPZicsICdsYXN0SW5kZXhPZiddLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGNvbnN0IG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZVtrZXldO1xyXG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdHJhY2soYXJyLCBcImdldFwiIC8qIEdFVCAqLywgaSArICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2UgcnVuIHRoZSBtZXRob2QgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MgZmlyc3QgKHdoaWNoIG1heSBiZSByZWFjdGl2ZSlcclxuICAgICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkoYXJyLCBhcmdzKTtcclxuICAgICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoYXQgZGlkbid0IHdvcmssIHJ1biBpdCBhZ2FpbiB1c2luZyByYXcgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KGFyciwgYXJncy5tYXAodG9SYXcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSk7XHJcblsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBjb25zdCBtZXRob2QgPSBBcnJheS5wcm90b3R5cGVba2V5XTtcclxuICAgIGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5ID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSQVcgKi8gJiZcclxuICAgICAgICAgICAgcmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5ID8gcmVhZG9ubHlNYXAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkgJiYgdGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIGlmIChpc1N5bWJvbChrZXkpXHJcbiAgICAgICAgICAgID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSlcclxuICAgICAgICAgICAgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcclxuICAgICAgICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVmKHJlcykpIHtcclxuICAgICAgICAgICAgLy8gcmVmIHVud3JhcHBpbmcgLSBkb2VzIG5vdCBhcHBseSBmb3IgQXJyYXkgKyBpbnRlZ2VyIGtleS5cclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVW53cmFwID0gIXRhcmdldElzQXJyYXkgfHwgIWlzSW50ZWdlcktleShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkVW53cmFwID8gcmVzLnZhbHVlIDogcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJldHVybmVkIHZhbHVlIGludG8gYSBwcm94eSBhcyB3ZWxsLiB3ZSBkbyB0aGUgaXNPYmplY3QgY2hlY2tcclxuICAgICAgICAgICAgLy8gaGVyZSB0byBhdm9pZCBpbnZhbGlkIHZhbHVlIHdhcm5pbmcuIEFsc28gbmVlZCB0byBsYXp5IGFjY2VzcyByZWFkb25seVxyXG4gICAgICAgICAgICAvLyBhbmQgcmVhY3RpdmUgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LlxyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seSA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBzZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcigpO1xyXG5jb25zdCBzaGFsbG93U2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKCFzaGFsbG93KSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KVxyXG4gICAgICAgICAgICA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aFxyXG4gICAgICAgICAgICA6IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHVwIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb2Ygb3JpZ2luYWxcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcclxuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcclxuICAgICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0FycmF5KHRhcmdldCkgPyAnbGVuZ3RoJyA6IElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxufVxyXG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQsXHJcbiAgICBzZXQsXHJcbiAgICBkZWxldGVQcm9wZXJ0eSxcclxuICAgIGhhcyxcclxuICAgIG93bktleXNcclxufTtcclxuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcclxuICAgIGdldDogcmVhZG9ubHlHZXQsXHJcbiAgICBzZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSBleHRlbmQoe30sIG11dGFibGVIYW5kbGVycywge1xyXG4gICAgZ2V0OiBzaGFsbG93R2V0LFxyXG4gICAgc2V0OiBzaGFsbG93U2V0XHJcbn0pO1xyXG4vLyBQcm9wcyBoYW5kbGVycyBhcmUgc3BlY2lhbCBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBzaG91bGQgbm90IHVud3JhcCB0b3AtbGV2ZWxcclxuLy8gcmVmcyAoaW4gb3JkZXIgdG8gYWxsb3cgcmVmcyB0byBiZSBleHBsaWNpdGx5IHBhc3NlZCBkb3duKSwgYnV0IHNob3VsZFxyXG4vLyByZXRhaW4gdGhlIHJlYWN0aXZpdHkgb2YgdGhlIG5vcm1hbCByZWFkb25seSBvYmplY3QuXHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxyXG59KTtcblxuY29uc3QgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUodmFsdWUpIDogdmFsdWU7XHJcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xyXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xyXG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xyXG5mdW5jdGlvbiBnZXQkMSh0YXJnZXQsIGtleSwgaXNSZWFkb25seSA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgLy8gIzE3NzI6IHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpIHNob3VsZCByZXR1cm4gcmVhZG9ubHkgKyByZWFjdGl2ZSB2ZXJzaW9uXHJcbiAgICAvLyBvZiB0aGUgdmFsdWVcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywgcmF3S2V5KTtcclxuICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xyXG4gICAgY29uc3Qgd3JhcCA9IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogaXNTaGFsbG93ID8gdG9TaGFsbG93IDogdG9SZWFjdGl2ZTtcclxuICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywgcmF3S2V5KTtcclxuICAgIHJldHVybiBrZXkgPT09IHJhd0tleVxyXG4gICAgICAgID8gdGFyZ2V0LmhhcyhrZXkpXHJcbiAgICAgICAgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgJ3NpemUnLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcclxuICAgIGlmIChoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xyXG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBpc01hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgID8gbmV3IE1hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgIDogbmV3IFNldCh0YXJnZXQpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XHJcbiAgICBpZiAoaGFkSXRlbXMpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiIC8qIENMRUFSICovLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IG1ha2Ugc3VyZSB0aGUgY2FsbGJhY2sgaXNcclxuICAgICAgICAgICAgLy8gMS4gaW52b2tlZCB3aXRoIHRoZSByZWFjdGl2ZSBtYXAgYXMgYHRoaXNgIGFuZCAzcmQgYXJnXHJcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2YWx1ZSByZWNlaXZlZCBzaG91bGQgYmUgYSBjb3JyZXNwb25kaW5nIHJlYWN0aXZlL3JlYWRvbmx5LlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XHJcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcclxuICAgICAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09ICdrZXlzJyAmJiB0YXJnZXRJc01hcDtcclxuICAgICAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogaXNTaGFsbG93ID8gdG9TaGFsbG93IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJlxyXG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgd3JhcHBlZCBpdGVyYXRvciB3aGljaCByZXR1cm5zIG9ic2VydmVkIHZlcnNpb25zIG9mIHRoZVxyXG4gICAgICAgIC8vIHZhbHVlcyBlbWl0dGVkIGZyb20gdGhlIHJlYWwgaXRlcmF0b3JcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZSwgZG9uZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcclxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRvUmF3KHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgLyogREVMRVRFICovID8gZmFsc2UgOiB0aGlzO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5KTtcclxuICAgIH0sXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBoYXM6IGhhcyQxLFxyXG4gICAgYWRkLFxyXG4gICAgc2V0OiBzZXQkMSxcclxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICBjbGVhcixcclxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgaGFzOiBoYXMkMSxcclxuICAgIGFkZCxcclxuICAgIHNldDogc2V0JDEsXHJcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgY2xlYXIsXHJcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxyXG59O1xyXG5jb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgaGFzKGtleSkge1xyXG4gICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIEFERCAqLyksXHJcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBERUxFVEUgKi8pLFxyXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBDTEVBUiAqLyksXHJcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnLCBTeW1ib2wuaXRlcmF0b3JdO1xyXG5pdGVyYXRvck1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xyXG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcclxuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XHJcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XHJcbn0pO1xyXG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xyXG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3dcclxuICAgICAgICA/IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgOiBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XHJcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiB0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXHJcbn07XHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIGAgK1xyXG4gICAgICAgICAgICBgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIGAgK1xyXG4gICAgICAgICAgICBgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBgICtcclxuICAgICAgICAgICAgYEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIGAgK1xyXG4gICAgICAgICAgICBgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcclxuICAgICAgICBjYXNlICdPYmplY3QnOlxyXG4gICAgICAgIGNhc2UgJ0FycmF5JzpcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xyXG4gICAgICAgIGNhc2UgJ01hcCc6XHJcbiAgICAgICAgY2FzZSAnU2V0JzpcclxuICAgICAgICBjYXNlICdXZWFrTWFwJzpcclxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcclxuICAgICAgICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpXHJcbiAgICAgICAgPyAwIC8qIElOVkFMSUQgKi9cclxuICAgICAgICA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXHJcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldFtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XHJcbiAqIGxldmVsIHByb3BlcnRpZXMgYXJlIHJlYWN0aXZlLiBJdCBhbHNvIGRvZXMgbm90IGF1dG8tdW53cmFwIHJlZnMgKGV2ZW4gYXQgdGhlXHJcbiAqIHJvb3QgbGV2ZWwpLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJlYWRvbmx5IGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdC4gTm90ZSB0aGUgcmV0dXJuZWQgY29weSBpcyBub3RcclxuICogbWFkZSByZWFjdGl2ZSwgYnV0IGByZWFkb25seWAgY2FuIGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHJlYWN0aXZlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVhY3RpdmUtY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290IGxldmVsXHJcbiAqIHByb3BlcnRpZXMgYXJlIHJlYWRvbmx5LCBhbmQgZG9lcyBOT1QgdW53cmFwIHJlZnMgbm9yIHJlY3Vyc2l2ZWx5IGNvbnZlcnRcclxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cclxuICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGluZyB0aGUgcHJvcHMgcHJveHkgb2JqZWN0IGZvciBzdGF0ZWZ1bCBjb21wb25lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgaXMgYWxyZWFkeSBhIFByb3h5LCByZXR1cm4gaXQuXHJcbiAgICAvLyBleGNlcHRpb246IGNhbGxpbmcgcmVhZG9ubHkoKSBvbiBhIHJlYWN0aXZlIG9iamVjdFxyXG4gICAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dICYmXHJcbiAgICAgICAgIShpc1JlYWRvbmx5ICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgYWxyZWFkeSBoYXMgY29ycmVzcG9uZGluZyBQcm94eVxyXG4gICAgY29uc3QgcHJveHlNYXAgPSBpc1JlYWRvbmx5ID8gcmVhZG9ubHlNYXAgOiByZWFjdGl2ZU1hcDtcclxuICAgIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGEgd2hpdGVsaXN0IG9mIHZhbHVlIHR5cGVzIGNhbiBiZSBvYnNlcnZlZC5cclxuICAgIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XHJcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcclxuICAgIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcclxuICAgIHJldHVybiBwcm94eTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dKTtcclxuICAgIH1cclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XHJcbiAgICByZXR1cm4gKChvYnNlcnZlZCAmJiB0b1JhdyhvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dKSkgfHwgb2JzZXJ2ZWQpO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcclxuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmNvbnN0IGNvbnZlcnQgPSAodmFsKSA9PiBpc09iamVjdCh2YWwpID8gcmVhY3RpdmUodmFsKSA6IHZhbDtcclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4ociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcclxufVxyXG5jbGFzcyBSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKF9yYXdWYWx1ZSwgX3NoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gX3Jhd1ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3NoYWxsb3cgPSBfc2hhbGxvdztcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfc2hhbGxvdyA/IF9yYXdWYWx1ZSA6IGNvbnZlcnQoX3Jhd1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICB0cmFjayh0b1Jhdyh0aGlzKSwgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICBpZiAoaGFzQ2hhbmdlZCh0b1JhdyhuZXdWYWwpLCB0aGlzLl9yYXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fc2hhbGxvdyA/IG5ld1ZhbCA6IGNvbnZlcnQobmV3VmFsKTtcclxuICAgICAgICAgICAgdHJpZ2dlcih0b1Jhdyh0aGlzKSwgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScsIG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xyXG4gICAgdHJpZ2dlcih0b1JhdyhyZWYpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gcmVmLnZhbHVlIDogdm9pZCAwKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcclxuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xyXG59XHJcbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcclxuICAgIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXHJcbiAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKVxyXG4gICAgICAgID8gb2JqZWN0V2l0aFJlZnNcclxuICAgICAgICA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcclxufVxyXG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeSgoKSA9PiB0cmFjayh0aGlzLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyksICgpID0+IHRyaWdnZXIodGhpcywgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScpKTtcclxuICAgICAgICB0aGlzLl9nZXQgPSBnZXQ7XHJcbiAgICAgICAgdGhpcy5fc2V0ID0gc2V0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQoKTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLl9zZXQobmV3VmFsKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzUHJveHkob2JqZWN0KSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXkpIHtcclxuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSkge1xyXG4gICAgcmV0dXJuIGlzUmVmKG9iamVjdFtrZXldKVxyXG4gICAgICAgID8gb2JqZWN0W2tleV1cclxuICAgICAgICA6IG5ldyBPYmplY3RSZWZJbXBsKG9iamVjdCwga2V5KTtcclxufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5KSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gX3NldHRlcjtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0ID0gZWZmZWN0KGdldHRlciwge1xyXG4gICAgICAgICAgICBsYXp5OiB0cnVlLFxyXG4gICAgICAgICAgICBzY2hlZHVsZXI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcih0b1Jhdyh0aGlzKSwgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dID0gaXNSZWFkb25seTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmVmZmVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjayh0b1Jhdyh0aGlzKSwgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IHNldHRlcjtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XHJcbiAgICAgICAgc2V0dGVyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogTk9PUDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XHJcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykgfHwgIWdldHRlck9yT3B0aW9ucy5zZXQpO1xyXG59XG5cbmV4cG9ydCB7IElURVJBVEVfS0VZLCBjb21wdXRlZCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVuYWJsZVRyYWNraW5nLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgbWFya1JhdywgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiIsImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1Jhdywgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBpc1JlYWN0aXZlLCBlZmZlY3QsIHN0b3AsIHJlZiwgaXNQcm94eSwgcHJveHlSZWZzLCB0b1JlZiwgcmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgY3VzdG9tUmVmLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgbWFya1JhdywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBleHRlbmQsIEVNUFRZX09CSiwgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgaHlwaGVuYXRlLCBjYW1lbGl6ZSwgaXNPbiwgaGFzT3duLCBpc01vZGVsTGlzdGVuZXIsIGRlZiwgaXNSZXNlcnZlZFByb3AsIEVNUFRZX0FSUiwgaXNPYmplY3QsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgbWFrZU1hcCwgcmVtb3ZlLCBOT09QLCBoYXNDaGFuZ2VkLCBpc1NldCwgaXNNYXAsIGludm9rZUFycmF5Rm5zLCBOTywgZ2V0R2xvYmFsVGhpcywgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XHJcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xyXG4gICAgc3RhY2sucHVzaCh2bm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XHJcbiAgICBzdGFjay5wb3AoKTtcclxufVxyXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xyXG4gICAgLy8gYXZvaWQgcHJvcHMgZm9ybWF0dGluZyBvciB3YXJuIGhhbmRsZXIgdHJhY2tpbmcgZGVwcyB0aGF0IG1pZ2h0IGJlIG11dGF0ZWRcclxuICAgIC8vIGR1cmluZyBwYXRjaCwgbGVhZGluZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXHJcbiAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XHJcbiAgICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xyXG4gICAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xyXG4gICAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcFdhcm5IYW5kbGVyLCBpbnN0YW5jZSwgMTEgLyogQVBQX1dBUk5fSEFORExFUiAqLywgW1xyXG4gICAgICAgICAgICBtc2cgKyBhcmdzLmpvaW4oJycpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcclxuICAgICAgICAgICAgdHJhY2VcclxuICAgICAgICAgICAgICAgIC5tYXAoKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0cmFjZS5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcclxuICAgICAgICAgICAgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIHdhcm5BcmdzLnB1c2goYFxcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYWNraW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XHJcbiAgICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoIWN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIC8vIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBzdGFjayBiZWNhdXNlIGl0IHdpbGwgYmUgaW5jb21wbGV0ZSBkdXJpbmcgdXBkYXRlc1xyXG4gICAgLy8gdGhhdCBkaWQgbm90IHN0YXJ0IGZyb20gdGhlIHJvb3QuIFJlLWNvbnN0cnVjdCB0aGUgcGFyZW50IGNoYWluIHVzaW5nXHJcbiAgICAvLyBpbnN0YW5jZSBwYXJlbnQgcG9pbnRlcnMuXHJcbiAgICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcclxuICAgIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xyXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2VDb3VudDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xyXG4gICAgICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xyXG4gICAgY29uc3QgbG9ncyA9IFtdO1xyXG4gICAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcclxuICAgICAgICBsb2dzLnB1c2goLi4uKGkgPT09IDAgPyBbXSA6IFtgXFxuYF0pLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBsb2dzO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcclxuICAgIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XHJcbiAgICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcclxuICAgIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUodm5vZGUuY29tcG9uZW50LCB2bm9kZS50eXBlLCBpc1Jvb3QpfWA7XHJcbiAgICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XHJcbiAgICByZXR1cm4gdm5vZGUucHJvcHNcclxuICAgICAgICA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXVxyXG4gICAgICAgIDogW29wZW4gKyBjbG9zZV07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcclxuICAgIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XHJcbiAgICB9KTtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICByZXMucHVzaChgIC4uLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcclxuICAgICAgICB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSB7XHJcbiAgICBbXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi9dOiAnYmVmb3JlQ3JlYXRlIGhvb2snLFxyXG4gICAgW1wiY1wiIC8qIENSRUFURUQgKi9dOiAnY3JlYXRlZCBob29rJyxcclxuICAgIFtcImJtXCIgLyogQkVGT1JFX01PVU5UICovXTogJ2JlZm9yZU1vdW50IGhvb2snLFxyXG4gICAgW1wibVwiIC8qIE1PVU5URUQgKi9dOiAnbW91bnRlZCBob29rJyxcclxuICAgIFtcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqL106ICdiZWZvcmVVcGRhdGUgaG9vaycsXHJcbiAgICBbXCJ1XCIgLyogVVBEQVRFRCAqL106ICd1cGRhdGVkJyxcclxuICAgIFtcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovXTogJ2JlZm9yZVVubW91bnQgaG9vaycsXHJcbiAgICBbXCJ1bVwiIC8qIFVOTU9VTlRFRCAqL106ICd1bm1vdW50ZWQgaG9vaycsXHJcbiAgICBbXCJhXCIgLyogQUNUSVZBVEVEICovXTogJ2FjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImRhXCIgLyogREVBQ1RJVkFURUQgKi9dOiAnZGVhY3RpdmF0ZWQgaG9vaycsXHJcbiAgICBbXCJlY1wiIC8qIEVSUk9SX0NBUFRVUkVEICovXTogJ2Vycm9yQ2FwdHVyZWQgaG9vaycsXHJcbiAgICBbXCJydGNcIiAvKiBSRU5ERVJfVFJBQ0tFRCAqL106ICdyZW5kZXJUcmFja2VkIGhvb2snLFxyXG4gICAgW1wicnRnXCIgLyogUkVOREVSX1RSSUdHRVJFRCAqL106ICdyZW5kZXJUcmlnZ2VyZWQgaG9vaycsXHJcbiAgICBbMCAvKiBTRVRVUF9GVU5DVElPTiAqL106ICdzZXR1cCBmdW5jdGlvbicsXHJcbiAgICBbMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi9dOiAncmVuZGVyIGZ1bmN0aW9uJyxcclxuICAgIFsyIC8qIFdBVENIX0dFVFRFUiAqL106ICd3YXRjaGVyIGdldHRlcicsXHJcbiAgICBbMyAvKiBXQVRDSF9DQUxMQkFDSyAqL106ICd3YXRjaGVyIGNhbGxiYWNrJyxcclxuICAgIFs0IC8qIFdBVENIX0NMRUFOVVAgKi9dOiAnd2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uJyxcclxuICAgIFs1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovXTogJ25hdGl2ZSBldmVudCBoYW5kbGVyJyxcclxuICAgIFs2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovXTogJ2NvbXBvbmVudCBldmVudCBoYW5kbGVyJyxcclxuICAgIFs3IC8qIFZOT0RFX0hPT0sgKi9dOiAndm5vZGUgaG9vaycsXHJcbiAgICBbOCAvKiBESVJFQ1RJVkVfSE9PSyAqL106ICdkaXJlY3RpdmUgaG9vaycsXHJcbiAgICBbOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi9dOiAndHJhbnNpdGlvbiBob29rJyxcclxuICAgIFsxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqL106ICdhcHAgZXJyb3JIYW5kbGVyJyxcclxuICAgIFsxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovXTogJ2FwcCB3YXJuSGFuZGxlcicsXHJcbiAgICBbMTIgLyogRlVOQ1RJT05fUkVGICovXTogJ3JlZiBmdW5jdGlvbicsXHJcbiAgICBbMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqL106ICdhc3luYyBjb21wb25lbnQgbG9hZGVyJyxcclxuICAgIFsxNCAvKiBTQ0hFRFVMRVIgKi9dOiAnc2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiAnICtcclxuICAgICAgICAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9uZXctaXNzdWUudnVlanMub3JnLz9yZXBvPXZ1ZWpzL3Z1ZS1uZXh0J1xyXG59O1xyXG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXMgPSBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcclxuICAgICAgICAgICAgcmVzLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcclxuICAgIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcclxuICAgICAgICAvLyB0aGUgZXhwb3NlZCBpbnN0YW5jZSBpcyB0aGUgcmVuZGVyIHByb3h5IHRvIGtlZXAgaXQgY29uc2lzdGVudCB3aXRoIDIueFxyXG4gICAgICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xyXG4gICAgICAgIC8vIGluIHByb2R1Y3Rpb24gdGhlIGhvb2sgcmVjZWl2ZXMgb25seSB0aGUgZXJyb3IgY29kZVxyXG4gICAgICAgIGNvbnN0IGVycm9ySW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IEVycm9yVHlwZVN0cmluZ3NbdHlwZV0gOiB0eXBlO1xyXG4gICAgICAgIHdoaWxlIChjdXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwLWxldmVsIGhhbmRsaW5nXHJcbiAgICAgICAgY29uc3QgYXBwRXJyb3JIYW5kbGVyID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZXJyb3JIYW5kbGVyO1xyXG4gICAgICAgIGlmIChhcHBFcnJvckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcEVycm9ySGFuZGxlciwgbnVsbCwgMTAgLyogQVBQX0VSUk9SX0hBTkRMRVIgKi8sIFtlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldik7XHJcbn1cclxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3NbdHlwZV07XHJcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XHJcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmFzaCBpbiBkZXYgYnkgZGVmYXVsdCBzbyBpdCdzIG1vcmUgbm90aWNlYWJsZVxyXG4gICAgICAgIGlmICh0aHJvd0luRGV2KSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZWNvdmVyIGluIHByb2QgdG8gcmVkdWNlIHRoZSBpbXBhY3Qgb24gZW5kLXVzZXJcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICB9XHJcbn1cblxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcclxubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbmNvbnN0IHF1ZXVlID0gW107XHJcbmxldCBmbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1ByZUZsdXNoQ2JzID0gW107XHJcbmxldCBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbmxldCBwcmVGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxubGV0IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IG51bGw7XHJcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcclxuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcclxuICAgIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcclxuICAgIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XHJcbn1cclxuLy8gIzI3NjhcclxuLy8gVXNlIGJpbmFyeS1zZWFyY2ggdG8gZmluZCBhIHN1aXRhYmxlIHBvc2l0aW9uIGluIHRoZSBxdWV1ZSxcclxuLy8gc28gdGhhdCB0aGUgcXVldWUgbWFpbnRhaW5zIHRoZSBpbmNyZWFzaW5nIG9yZGVyIG9mIGpvYidzIGlkLFxyXG4vLyB3aGljaCBjYW4gcHJldmVudCB0aGUgam9iIGZyb20gYmVpbmcgc2tpcHBlZCBhbmQgYWxzbyBjYW4gYXZvaWQgcmVwZWF0ZWQgcGF0Y2hpbmcuXHJcbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChqb2IpIHtcclxuICAgIC8vIHRoZSBzdGFydCBpbmRleCBzaG91bGQgYmUgYGZsdXNoSW5kZXggKyAxYFxyXG4gICAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XHJcbiAgICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xyXG4gICAgY29uc3Qgam9iSWQgPSBnZXRJZChqb2IpO1xyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuICAgICAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKHF1ZXVlW21pZGRsZV0pO1xyXG4gICAgICAgIG1pZGRsZUpvYklkIDwgam9iSWQgPyAoc3RhcnQgPSBtaWRkbGUgKyAxKSA6IChlbmQgPSBtaWRkbGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXJ0O1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xyXG4gICAgLy8gdGhlIGRlZHVwZSBzZWFyY2ggdXNlcyB0aGUgc3RhcnRJbmRleCBhcmd1bWVudCBvZiBBcnJheS5pbmNsdWRlcygpXHJcbiAgICAvLyBieSBkZWZhdWx0IHRoZSBzZWFyY2ggaW5kZXggaW5jbHVkZXMgdGhlIGN1cnJlbnQgam9iIHRoYXQgaXMgYmVpbmcgcnVuXHJcbiAgICAvLyBzbyBpdCBjYW5ub3QgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgYWdhaW4uXHJcbiAgICAvLyBpZiB0aGUgam9iIGlzIGEgd2F0Y2goKSBjYWxsYmFjaywgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IHdpdGggYSArMSBpbmRleCB0b1xyXG4gICAgLy8gYWxsb3cgaXQgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgLSBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvXHJcbiAgICAvLyBlbnN1cmUgaXQgZG9lc24ndCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcC5cclxuICAgIGlmICgoIXF1ZXVlLmxlbmd0aCB8fFxyXG4gICAgICAgICFxdWV1ZS5pbmNsdWRlcyhqb2IsIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleCkpICYmXHJcbiAgICAgICAgam9iICE9PSBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IpIHtcclxuICAgICAgICBjb25zdCBwb3MgPSBmaW5kSW5zZXJ0aW9uSW5kZXgoam9iKTtcclxuICAgICAgICBpZiAocG9zID4gLTEpIHtcclxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKHBvcywgMCwgam9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goam9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVGbHVzaCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XHJcbiAgICBpZiAoIWlzRmx1c2hpbmcgJiYgIWlzRmx1c2hQZW5kaW5nKSB7XHJcbiAgICAgICAgaXNGbHVzaFBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGludmFsaWRhdGVKb2Ioam9iKSB7XHJcbiAgICBjb25zdCBpID0gcXVldWUuaW5kZXhPZihqb2IpO1xyXG4gICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUNiKGNiLCBhY3RpdmVRdWV1ZSwgcGVuZGluZ1F1ZXVlLCBpbmRleCkge1xyXG4gICAgaWYgKCFpc0FycmF5KGNiKSkge1xyXG4gICAgICAgIGlmICghYWN0aXZlUXVldWUgfHxcclxuICAgICAgICAgICAgIWFjdGl2ZVF1ZXVlLmluY2x1ZGVzKGNiLCBjYi5hbGxvd1JlY3Vyc2UgPyBpbmRleCArIDEgOiBpbmRleCkpIHtcclxuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goY2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGNiIGlzIGFuIGFycmF5LCBpdCBpcyBhIGNvbXBvbmVudCBsaWZlY3ljbGUgaG9vayB3aGljaCBjYW4gb25seSBiZVxyXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xyXG4gICAgICAgIC8vIHdlIGNhbiBza2lwIGR1cGxpY2F0ZSBjaGVjayBoZXJlIHRvIGltcHJvdmUgcGVyZlxyXG4gICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKC4uLmNiKTtcclxuICAgIH1cclxuICAgIHF1ZXVlRmx1c2goKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVByZUZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVByZUZsdXNoQ2JzLCBwZW5kaW5nUHJlRmx1c2hDYnMsIHByZUZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVBvc3RGbHVzaENicywgcGVuZGluZ1Bvc3RGbHVzaENicywgcG9zdEZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iID0gbnVsbCkge1xyXG4gICAgaWYgKHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBwYXJlbnRKb2I7XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBbLi4ubmV3IFNldChwZW5kaW5nUHJlRmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChwcmVGbHVzaEluZGV4ID0gMDsgcHJlRmx1c2hJbmRleCA8IGFjdGl2ZVByZUZsdXNoQ2JzLmxlbmd0aDsgcHJlRmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnNbcHJlRmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG4gICAgICAgIHByZUZsdXNoSW5kZXggPSAwO1xyXG4gICAgICAgIGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IG51bGw7XHJcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmx1c2ggdW50aWwgaXQgZHJhaW5zXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyhzZWVuLCBwYXJlbnRKb2IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcclxuICAgIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV07XHJcbiAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vICMxOTQ3IGFscmVhZHkgaGFzIGFjdGl2ZSBxdWV1ZSwgbmVzdGVkIGZsdXNoUG9zdEZsdXNoQ2JzIGNhbGxcclxuICAgICAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgICAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbiAgICAgICAgcG9zdEZsdXNoSW5kZXggPSAwO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBJbmZpbml0eSA6IGpvYi5pZDtcclxuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcclxuICAgIGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbiAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBmbHVzaFByZUZsdXNoQ2JzKHNlZW4pO1xyXG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXHJcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcclxuICAgIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcclxuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZCBzbyBpdHMgcmVuZGVyIGVmZmVjdCB3aWxsIGhhdmUgc21hbGxlclxyXG4gICAgLy8gICAgcHJpb3JpdHkgbnVtYmVyKVxyXG4gICAgLy8gMi4gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB1cGRhdGUsXHJcbiAgICAvLyAgICBpdHMgdXBkYXRlIGNhbiBiZSBza2lwcGVkLlxyXG4gICAgcXVldWUuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGpvYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGpvYiwgbnVsbCwgMTQgLyogU0NIRURVTEVSICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGZsdXNoSW5kZXggPSAwO1xyXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XHJcbiAgICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIC8vIHNvbWUgcG9zdEZsdXNoQ2IgcXVldWVkIGpvYnMhXHJcbiAgICAgICAgLy8ga2VlcCBmbHVzaGluZyB1bnRpbCBpdCBkcmFpbnMuXHJcbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCB8fCBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmbHVzaEpvYnMoc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xyXG4gICAgaWYgKCFzZWVuLmhhcyhmbikpIHtcclxuICAgICAgICBzZWVuLnNldChmbiwgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcclxuICAgICAgICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXhpbXVtIHJlY3Vyc2l2ZSB1cGRhdGVzIGV4Y2VlZGVkLiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcclxuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSBuZXcgU2V0KCk7XHJcbi8vIEV4cG9zZSB0aGUgSE1SIHJ1bnRpbWUgb24gdGhlIGdsb2JhbCBvYmplY3RcclxuLy8gVGhpcyBtYWtlcyBpdCBlbnRpcmVseSB0cmVlLXNoYWthYmxlIHdpdGhvdXQgcG9sbHV0aW5nIHRoZSBleHBvcnRzIGFuZCBtYWtlc1xyXG4vLyBpdCBlYXNpZXIgdG8gYmUgdXNlZCBpbiB0b29saW5ncyBsaWtlIHZ1ZS1sb2FkZXJcclxuLy8gTm90ZTogZm9yIGEgY29tcG9uZW50IHRvIGJlIGVsaWdpYmxlIGZvciBITVIgaXQgYWxzbyBuZWVkcyB0aGUgX19obXJJZCBvcHRpb25cclxuLy8gdG8gYmUgc2V0IHNvIHRoYXQgaXRzIGluc3RhbmNlcyBjYW4gYmUgcmVnaXN0ZXJlZCAvIHJlbW92ZWQuXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGNvbnN0IGdsb2JhbE9iamVjdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICA/IHNlbGZcclxuICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgIDoge307XHJcbiAgICBnbG9iYWxPYmplY3QuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcclxuICAgICAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXHJcbiAgICAgICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcclxuICAgIH07XHJcbn1cclxuY29uc3QgbWFwID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XHJcbiAgICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICB9XHJcbiAgICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgY29tcG9uZW50KSB7XHJcbiAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgIHdhcm4oYEhNUiBBUEkgdXNhZ2UgaXMgb3V0IG9mIGRhdGUuXFxuYCArXHJcbiAgICAgICAgICAgIGBQbGVhc2UgdXBncmFkZSB2dWUtbG9hZGVyL3ZpdGUvcm9sbHVwLXBsdWdpbi12dWUgb3Igb3RoZXIgcmVsZXZhbnQgYCArXHJcbiAgICAgICAgICAgIGBkZXBlbmRlbmN5IHRoYXQgaGFuZGxlcyBWdWUgU0ZDIGNvbXBpbGF0aW9uLmApO1xyXG4gICAgICAgIGNvbXBvbmVudCA9IHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKG1hcC5oYXMoaWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWFwLnNldChpZCwge1xyXG4gICAgICAgIGNvbXBvbmVudDogaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudCxcclxuICAgICAgICBpbnN0YW5jZXM6IG5ldyBTZXQoKVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGlmIChuZXdSZW5kZXIpXHJcbiAgICAgICAgcmVjb3JkLmNvbXBvbmVudC5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAvLyBBcnJheS5mcm9tIGNyZWF0ZXMgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZ1xyXG4gICAgLy8gdXBkYXRlc1xyXG4gICAgQXJyYXkuZnJvbShyZWNvcmQuaW5zdGFuY2VzKS5mb3JFYWNoKGluc3RhbmNlID0+IHtcclxuICAgICAgICBpZiAobmV3UmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcclxuICAgICAgICAvLyB0aGlzIGZsYWcgZm9yY2VzIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBzbG90IGNvbnRlbnQgdG8gdXBkYXRlXHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIC8vIEFycmF5LmZyb20gY3JlYXRlcyBhIHNuYXBzaG90IHdoaWNoIGF2b2lkcyB0aGUgc2V0IGJlaW5nIG11dGF0ZWQgZHVyaW5nXHJcbiAgICAvLyB1cGRhdGVzXHJcbiAgICBjb25zdCB7IGNvbXBvbmVudCwgaW5zdGFuY2VzIH0gPSByZWNvcmQ7XHJcbiAgICBpZiAoIWhtckRpcnR5Q29tcG9uZW50cy5oYXMoY29tcG9uZW50KSkge1xyXG4gICAgICAgIC8vIDEuIFVwZGF0ZSBleGlzdGluZyBjb21wIGRlZmluaXRpb24gdG8gbWF0Y2ggbmV3IG9uZVxyXG4gICAgICAgIG5ld0NvbXAgPSBpc0NsYXNzQ29tcG9uZW50KG5ld0NvbXApID8gbmV3Q29tcC5fX3ZjY09wdHMgOiBuZXdDb21wO1xyXG4gICAgICAgIGV4dGVuZChjb21wb25lbnQsIG5ld0NvbXApO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3Q29tcCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBNYXJrIGNvbXBvbmVudCBkaXJ0eS4gVGhpcyBmb3JjZXMgdGhlIHJlbmRlcmVyIHRvIHJlcGxhY2UgdGhlIGNvbXBvbmVudFxyXG4gICAgICAgIC8vIG9uIHBhdGNoLlxyXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQoY29tcG9uZW50KTtcclxuICAgICAgICAvLyAzLiBNYWtlIHN1cmUgdG8gdW5tYXJrIHRoZSBjb21wb25lbnQgYWZ0ZXIgdGhlIHJlbG9hZC5cclxuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgQXJyYXkuZnJvbShpbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgLy8gNC4gRm9yY2UgdGhlIHBhcmVudCBpbnN0YW5jZSB0byByZS1yZW5kZXIuIFRoaXMgd2lsbCBjYXVzZSBhbGwgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnRzIHRvIGJlIHVubW91bnRlZCBhbmQgcmUtbW91bnRlZC4gUXVldWUgdGhlIHVwZGF0ZSBzbyB0aGF0IHdlXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGVuZCB1cCBmb3JjaW5nIHRoZSBzYW1lIHBhcmVudCB0byByZS1yZW5kZXIgbXVsdGlwbGUgdGltZXMuXHJcbiAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIG1vdW50ZWQgdmlhIGNyZWF0ZUFwcCgpIGhhcyBhIHJlbG9hZCBtZXRob2RcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBpbnNpZGUgdHJlZSBjcmVhdGVkIHZpYSByYXcgcmVuZGVyKCkuIEZvcmNlIHJlbG9hZC5cclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcclxuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcclxuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmxldCBkZXZ0b29scztcclxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2spIHtcclxuICAgIGRldnRvb2xzID0gaG9vaztcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XHJcbiAgICAvLyBUT0RPIHF1ZXVlIGlmIGRldnRvb2xzIGlzIHVuZGVmaW5lZFxyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XHJcbiAgICAgICAgRnJhZ21lbnQsXHJcbiAgICAgICAgVGV4dCxcclxuICAgICAgICBDb21tZW50LFxyXG4gICAgICAgIFN0YXRpY1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgYXBwKTtcclxufVxyXG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBDT01QT05FTlRfQURERUQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcclxuICAgICAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZGV2dG9vbHMuZW1pdChob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHVuZGVmaW5lZCwgY29tcG9uZW50KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpO1xyXG59XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCB7IGVtaXRzT3B0aW9ucywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGVtaXRzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShldmVudCkgaW4gcHJvcHNPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoZXZlbnQpfVwiIHByb3AuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBlbWl0c09wdGlvbnNbZXZlbnRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBhcmdzID0gcmF3QXJncztcclxuICAgIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoJ3VwZGF0ZTonKTtcclxuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhcHBseSBtb2RpZmllcnMgb24gYXJnc1xyXG4gICAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XHJcbiAgICBpZiAobW9kZWxBcmcgJiYgbW9kZWxBcmcgaW4gcHJvcHMpIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBgJHttb2RlbEFyZyA9PT0gJ21vZGVsVmFsdWUnID8gJ21vZGVsJyA6IG1vZGVsQXJnfU1vZGlmaWVyc2A7XHJcbiAgICAgICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChhID0+IGEudHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCh0b051bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xyXG4gICAgICAgICAgICB3YXJuKGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgYCArXHJcbiAgICAgICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXHJcbiAgICAgICAgICAgICAgICBgdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGNvbnZlcnQgaGFuZGxlciBuYW1lIHRvIGNhbWVsQ2FzZS4gU2VlIGlzc3VlICMyMjQ5XHJcbiAgICBsZXQgaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKTtcclxuICAgIGxldCBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWVdO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFsc28gdHJpZ2dlciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRcclxuICAgIC8vIGZvciBwcm9wcyBwYXNzZWQgdmlhIGtlYmFiLWNhc2VcclxuICAgIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcclxuICAgICAgICBoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKTtcclxuICAgICAgICBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWVdO1xyXG4gICAgfVxyXG4gICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhoYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcclxuICAgIGlmIChvbmNlSGFuZGxlcikge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xyXG4gICAgICAgICAgICAoaW5zdGFuY2UuZW1pdHRlZCA9IHt9KVtoYW5kbGVyTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKG9uY2VIYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgaWYgKCFhcHBDb250ZXh0LmRlb3B0ICYmIGNvbXAuX19lbWl0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXAuX19lbWl0cztcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XHJcbiAgICBsZXQgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xyXG4gICAgICAgICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcclxuICAgICAgICByZXR1cm4gKGNvbXAuX19lbWl0cyA9IG51bGwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIHJhdy5mb3JFYWNoKGtleSA9PiAobm9ybWFsaXplZFtrZXldID0gbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGNvbXAuX19lbWl0cyA9IG5vcm1hbGl6ZWQpO1xyXG59XHJcbi8vIENoZWNrIGlmIGFuIGluY29taW5nIHByb3Aga2V5IGlzIGEgZGVjbGFyZWQgZW1pdCBldmVudCBsaXN0ZW5lci5cclxuLy8gZS5nLiBXaXRoIGBlbWl0czogeyBjbGljazogbnVsbCB9YCwgcHJvcHMgbmFtZWQgYG9uQ2xpY2tgIGFuZCBgb25jbGlja2AgYXJlXHJcbi8vIGJvdGggY29uc2lkZXJlZCBtYXRjaGVkIGxpc3RlbmVycy5cclxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XHJcbiAgICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sICcnKTtcclxuICAgIHJldHVybiAoaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHxcclxuICAgICAgICBoYXNPd24ob3B0aW9ucywga2V5KSk7XHJcbn1cblxuLyoqXHJcbiAqIG1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlIGZvciBhc3NldCByZXNvbHV0aW9uIChlLmcuXHJcbiAqIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUpIGR1cmluZyByZW5kZXJcclxuICovXHJcbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xyXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIuXHJcbiAqIElmICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyIHRoZW4gdGhlIHdhcm5pbmcgZm9yIGZhaWxlZCBhdHRyc1xyXG4gKiBmYWxsdGhyb3VnaCBjYW4gYmUgc3VwcHJlc3NlZC5cclxuICovXHJcbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xyXG4gICAgYWNjZXNzZWRBdHRycyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyB0eXBlOiBDb21wb25lbnQsIHZub2RlLCBwcm94eSwgd2l0aFByb3h5LCBwcm9wcywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSwgc2xvdHMsIGF0dHJzLCBlbWl0LCByZW5kZXIsIHJlbmRlckNhY2hlLCBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIC8vIHdpdGhQcm94eSBpcyBhIHByb3h5IHdpdGggYSBkaWZmZXJlbnQgYGhhc2AgdHJhcCBvbmx5IGZvclxyXG4gICAgICAgICAgICAvLyBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrLlxyXG4gICAgICAgICAgICBjb25zdCBwcm94eVRvVXNlID0gd2l0aFByb3h5IHx8IHByb3h5O1xyXG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIuY2FsbChwcm94eVRvVXNlLCBwcm94eVRvVXNlLCByZW5kZXJDYWNoZSwgcHJvcHMsIHNldHVwU3RhdGUsIGRhdGEsIGN0eCkpO1xyXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlciA9IENvbXBvbmVudDtcclxuICAgICAgICAgICAgLy8gaW4gZGV2LCBtYXJrIGF0dHJzIGFjY2Vzc2VkIGlmIG9wdGlvbmFsIHByb3BzIChhdHRycyA9PT0gcHJvcHMpXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYXR0cnMgPT09IHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5sZW5ndGggPiAxXHJcbiAgICAgICAgICAgICAgICA/IHJlbmRlcihwcm9wcywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogeyBhdHRycywgc2xvdHMsIGVtaXQgfSlcclxuICAgICAgICAgICAgICAgIDogcmVuZGVyKHByb3BzLCBudWxsIC8qIHdlIGtub3cgaXQgZG9lc24ndCBuZWVkIGl0ICovKSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHNcclxuICAgICAgICAgICAgICAgID8gYXR0cnNcclxuICAgICAgICAgICAgICAgIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXR0ciBtZXJnaW5nXHJcbiAgICAgICAgLy8gaW4gZGV2IG1vZGUsIGNvbW1lbnRzIGFyZSBwcmVzZXJ2ZWQsIGFuZCBpdCdzIHBvc3NpYmxlIGZvciBhIHRlbXBsYXRlXHJcbiAgICAgICAgLy8gdG8gaGF2ZSBjb21tZW50cyBhbG9uZyBzaWRlIHRoZSByb290IGVsZW1lbnQgd2hpY2ggbWFrZXMgaXQgYSBmcmFnbWVudFxyXG4gICAgICAgIGxldCByb290ID0gcmVzdWx0O1xyXG4gICAgICAgIGxldCBzZXRSb290ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiZcclxuICAgICAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5pbmhlcml0QXR0cnMgIT09IGZhbHNlICYmIGZhbGx0aHJvdWdoQXR0cnMpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcclxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgdi1tb2RlbCBsaXN0ZW5lciAob25VcGRhdGU6eHh4KSBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY2xhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3AsIGl0IGluZGljYXRlcyB0aGlzIGNvbXBvbmVudCBleHBlY3RzIHRvIGhhbmRsZSB2LW1vZGVsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgbm90IGZhbGx0aHJvdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGVkOiAjMTU0MywgIzE2NDMsICMxOTg5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhmYWxsdGhyb3VnaEF0dHJzLCBwcm9wc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBoYW5kbGVycyB3aGVuIHRoZXkgZmFpbCB0byBmYWxsdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBgb25gLCBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIHRvIHJlZmxlY3QgZXZlbnQgY2FzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjdXJhdGVseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtleHRyYUF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtldmVudEF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmhlcml0IGRpcmVjdGl2ZXNcclxuICAgICAgICBpZiAodm5vZGUuZGlycykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmhlcml0IHRyYW5zaXRpb24gZGF0YVxyXG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldFJvb3QpIHtcclxuICAgICAgICAgICAgc2V0Um9vdChyb290KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEgLyogUkVOREVSX0ZVTkNUSU9OICovKTtcclxuICAgICAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcclxuICAgIH1cclxuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKiBJbiBkZXYgbW9kZSwgdGVtcGxhdGUgcm9vdCBsZXZlbCBjb21tZW50cyBhcmUgcmVuZGVyZWQsIHdoaWNoIHR1cm5zIHRoZVxyXG4gKiB0ZW1wbGF0ZSBpbnRvIGEgZnJhZ21lbnQgcm9vdCwgYnV0IHdlIG5lZWQgdG8gbG9jYXRlIHRoZSBzaW5nbGUgZWxlbWVudFxyXG4gKiByb290IGZvciBhdHRycyBhbmQgc2NvcGUgaWQgcHJvY2Vzc2luZy5cclxuICovXHJcbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xyXG4gICAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4pO1xyXG4gICAgaWYgKCFjaGlsZFJvb3QpIHtcclxuICAgICAgICByZXR1cm4gW3Zub2RlLCB1bmRlZmluZWRdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XHJcbiAgICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XHJcbiAgICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XHJcbiAgICAgICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XHJcbn07XHJcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4pIHtcclxuICAgIGxldCBzaW5nbGVSb290O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSB1c2VyIGNvbW1lbnRcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09ICd2LWlmJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9yZSB0aGFuIDEgbm9uLWNvbW1lbnQgY2hpbGQsIHJldHVybiBub3dcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2luZ2xlUm9vdDtcclxufVxyXG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcclxuICAgIGxldCByZXM7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICByZXR1cm4gKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgdm5vZGUudHlwZSA9PT0gQ29tbWVudCAvLyBwb3RlbnRpYWwgdi1pZiBicmFuY2ggc3dpdGNoXHJcbiAgICApO1xyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcclxuICAgIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XHJcbiAgICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XHJcbiAgICAvLyBQYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIHdhcyBob3QtdXBkYXRlZC4gU2luY2UgdGhpcyBtYXkgaGF2ZVxyXG4gICAgLy8gY2F1c2VkIHRoZSBjaGlsZCBjb21wb25lbnQncyBzbG90cyBjb250ZW50IHRvIGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0b1xyXG4gICAgLy8gZm9yY2UgdGhlIGNoaWxkIHRvIHVwZGF0ZSBhcyB3ZWxsLlxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yY2UgY2hpbGQgdXBkYXRlIGZvciBydW50aW1lIGRpcmVjdGl2ZSBvciB0cmFuc2l0aW9uIG9uIGNvbXBvbmVudCB2bm9kZS5cclxuICAgIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi8pIHtcclxuICAgICAgICAgICAgLy8gc2xvdCBjb250ZW50IHRoYXQgcmVmZXJlbmNlcyB2YWx1ZXMgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQsXHJcbiAgICAgICAgICAgIC8vIGUuZy4gaW4gYSB2LWZvclxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiB0aGlzIGZsYWcgaW5kaWNhdGVzIHByb3BzIGFyZSBhbHdheXMgbm9uLW51bGxcclxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB0aGlzIHBhdGggaXMgb25seSB0YWtlbiBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbnNcclxuICAgICAgICAvLyBzbyBwcmVzZW5jZSBvZiBhbnkgY2hpbGRyZW4gbGVhZHMgdG8gYSBmb3JjZWQgdXBkYXRlXHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmV4dFByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcclxuICAgIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcclxuICAgIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XHJcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxyXG4gICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsIC8vIEhvc3ROb2RlXHJcbikge1xyXG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xyXG4vLyBTdXNwZW5zZSBleHBvc2VzIGEgY29tcG9uZW50LWxpa2UgQVBJLCBhbmQgaXMgdHJlYXRlZCBsaWtlIGEgY29tcG9uZW50XHJcbi8vIGluIHRoZSBjb21waWxlciwgYnV0IGludGVybmFsbHkgaXQncyBhIHNwZWNpYWwgYnVpbHQtaW4gdHlwZSB0aGF0IGhvb2tzXHJcbi8vIGRpcmVjdGx5IGludG8gdGhlIHJlbmRlcmVyLlxyXG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XHJcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XHJcbiAgICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xyXG4gICAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXHJcbiAgICAvLyBpbnRlcm5hbHMuXHJcbiAgICBfX2lzU3VzcGVuc2U6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQsIFxyXG4gICAgLy8gcGxhdGZvcm0tc3BlY2lmaWMgaW1wbCBwYXNzZWQgZnJvbSByZW5kZXJlclxyXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudFN1c3BlbnNlKG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcclxuICAgIGNyZWF0ZTogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeVxyXG59O1xyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBTdXNwZW5zZSA9IChTdXNwZW5zZUltcGxcclxuICAgICk7XHJcbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSk7XHJcbiAgICAvLyBzdGFydCBtb3VudGluZyB0aGUgY29udGVudCBzdWJ0cmVlIGluIGFuIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICBwYXRjaChudWxsLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIGhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgLy8gbm93IGNoZWNrIGlmIHdlIGhhdmUgZW5jb3VudGVyZWQgYW55IGFzeW5jIGRlcHNcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xyXG4gICAgICAgIC8vIGhhcyBhc3luY1xyXG4gICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUuc3NGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICBpc1NWRyk7XHJcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFN1c3BlbnNlIGhhcyBubyBhc3luYyBkZXBzLiBKdXN0IHJlc29sdmUuXHJcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2UpO1xyXG4gICAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcclxuICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XHJcbiAgICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XHJcbiAgICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XHJcbiAgICBpZiAocGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgcm9vdCB0eXBlIGJ1dCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgIHBhdGNoKHBlbmRpbmdCcmFuY2gsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9nZ2xlZCBiZWZvcmUgcGVuZGluZyB0cmVlIGlzIHJlc29sdmVkXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xyXG4gICAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRvZ2dsZWQgYmVmb3JlIGh5ZHJhdGlvbiBpcyBmaW5pc2hlZCwgdGhlIGN1cnJlbnQgRE9NIHRyZWUgaXNcclxuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciB2YWxpZC4gc2V0IGl0IGFzIHRoZSBhY3RpdmUgYnJhbmNoIHNvIGl0IHdpbGwgYmUgdW5tb3VudGVkXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBlbmRpbmcgSUQuIHRoaXMgaXMgdXNlZCB0byBpbnZhbGlkYXRlIGFzeW5jIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAvLyByZXNldCBzdXNwZW5zZSBzdGF0ZVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5kZXBzID0gMDtcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCBlZmZlY3RzIGZyb20gcGVuZGluZyBicmFuY2hcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBpbiBmYWxsYmFjayBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlZCBcImJhY2tcIiB0byBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgcmVzb2x2ZVxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGVkIHRvIGEgM3JkIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBkaWQgbm90IGNoYW5nZSwganVzdCBub3JtYWwgcGF0Y2hcclxuICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSB0b2dnbGVkXHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcGVuZGluZyBldmVudFxyXG4gICAgICAgICAgICBjb25zdCBvblBlbmRpbmcgPSBuMi5wcm9wcyAmJiBuMi5wcm9wcy5vblBlbmRpbmc7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uUGVuZGluZykpIHtcclxuICAgICAgICAgICAgICAgIG9uUGVuZGluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1vdW50IHBlbmRpbmcgYnJhbmNoIGluIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmNvbWluZyBicmFuY2ggaGFzIG5vIGFzeW5jIGRlcHMsIHJlc29sdmUgbm93LlxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50LCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgYGNvbnNvbGUuaW5mb2AgY2Fubm90IGJlIG51bGwgZXJyb3JcclxuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogdW5tb3VudCwgbjogbmV4dCwgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gdG9OdW1iZXIodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudGltZW91dCk7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9IHtcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIGlzU1ZHLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBoaWRkZW5Db250YWluZXIsXHJcbiAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgIGRlcHM6IDAsXHJcbiAgICAgICAgcGVuZGluZ0lkOiAwLFxyXG4gICAgICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiAtMSxcclxuICAgICAgICBhY3RpdmVCcmFuY2g6IG51bGwsXHJcbiAgICAgICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcclxuICAgICAgICBpc0luRmFsbGJhY2s6IHRydWUsXHJcbiAgICAgICAgaXNIeWRyYXRpbmcsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGVmZmVjdHM6IFtdLFxyXG4gICAgICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgcGVuZGluZ0lkLCBlZmZlY3RzLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghcmVzdW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW5pdGlhbCBhbmNob3Igb24gbW91bnRcclxuICAgICAgICAgICAgICAgIGxldCB7IGFuY2hvciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIHRyZWVcclxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmFsbGJhY2sgdHJlZSB3YXMgbW91bnRlZCwgaXQgbWF5IGhhdmUgYmVlbiBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHBhcnQgb2YgYSBwYXJlbnQgc3VzcGVuc2UuIGdldCB0aGUgbGF0ZXN0IGFuY2hvciBmb3IgaW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgY29udGVudCBmcm9tIG9mZi1kb20gY29udGFpbmVyIHRvIGFjdHVhbCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGZsdXNoIGJ1ZmZlcmVkIGVmZmVjdHNcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZVxyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xyXG4gICAgICAgICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIG1lcmdlIGJ1ZmZlcmVkIHBvc3Qgam9ic1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhhdCBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlLCBmbHVzaCBhbGwgam9ic1xyXG4gICAgICAgICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcmVzb2x2ZSBldmVudFxyXG4gICAgICAgICAgICBjb25zdCBvblJlc29sdmUgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblJlc29sdmU7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uUmVzb2x2ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9uUmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGlzU1ZHIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxyXG4gICAgICAgICAgICBjb25zdCBvbkZhbGxiYWNrID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25GYWxsYmFjaztcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25GYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgIG9uRmFsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBmYWxsYmFja1ZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbiAmJiBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgIGlmIChkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxyXG4gICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XHJcbiAgICAgICAgICAgIHRydWUgLy8gc2hvdWxkUmVtb3ZlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgbW91bnRGYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJlxyXG4gICAgICAgICAgICAgICAgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCB0eXBlKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcclxuICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAuYXN5bmNEZXAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmNTZXR1cFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXRyeSB3aGVuIHRoZSBzZXR1cCgpIHByb21pc2UgcmVzb2x2ZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiB1bm1vdW50ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IGZyb20gdGhpcyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2bm9kZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZCBpZiBhbiB1cGRhdGUgaGFwcGVuZWQgYmVmb3JlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzeW5jIGRlcCBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGh5ZHJhdGVkRWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChpbnN0YW5jZSwgdm5vZGUsIFxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSwgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxyXG4gICAgICAgICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLCBzdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZS5lbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGVjcmVhc2UgZGVwcyBjb3VudCBpZiBzdXNwZW5zZSBpcyBub3QgYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHN1c3BlbnNlO1xyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgbm9kZS5wYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgbnVsbCwgaXNTVkcsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIHRydWUgLyogaHlkcmF0aW5nICovKSk7XHJcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxyXG4gICAgLy8gLSBzdWNjZXNzOiBzc3IgY29udGVudCBzaG91bGQgYmUgZnVsbHkgcmVzb2x2ZWRcclxuICAgIC8vIC0gZmFpbHVyZTogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIHRoZSBmYWxsYmFjayBicmFuY2guXHJcbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XHJcbiAgICAvLyBhdHRlbXB0IHRvIGh5ZHJhdGUgdGhlIERPTSBhc3N1bWluZyBpdCBoYXMgc3VjY2VlZGVkLCBidXQgd2Ugc3RpbGxcclxuICAgIC8vIG5lZWQgdG8gY29uc3RydWN0IGEgc3VzcGVuc2UgYm91bmRhcnkgZmlyc3RcclxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xyXG4gICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgbGV0IGZhbGxiYWNrO1xyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5kZWZhdWx0KTtcclxuICAgICAgICBmYWxsYmFjayA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuKTtcclxuICAgICAgICBmYWxsYmFjayA9IG5vcm1hbGl6ZVZOb2RlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGZhbGxiYWNrXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzKSkge1xyXG4gICAgICAgIHMgPSBzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShzKSkge1xyXG4gICAgICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFzaW5nbGVDaGlsZCkge1xyXG4gICAgICAgICAgICB3YXJuKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPSBzaW5nbGVDaGlsZDtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVWTm9kZShzKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcclxuICAgIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XHJcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XHJcbiAgICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xyXG4gICAgY29uc3QgZWwgPSAodm5vZGUuZWwgPSBicmFuY2guZWwpO1xyXG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxyXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRoZSBIT0MgZWxcclxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XHJcbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xyXG4gICAgfVxyXG59XG5cbmxldCBpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdCA9IDA7XHJcbmNvbnN0IHNldENvbXBpbGVkU2xvdFJlbmRlcmluZyA9IChuKSA9PiAoaXNSZW5kZXJpbmdDb21waWxlZFNsb3QgKz0gbik7XHJcbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIGA8c2xvdC8+YFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgXHJcbi8vIHRoaXMgaXMgbm90IGEgdXNlci1mYWNpbmcgZnVuY3Rpb24sIHNvIHRoZSBmYWxsYmFjayBpcyBhbHdheXMgZ2VuZXJhdGVkIGJ5XHJcbi8vIHRoZSBjb21waWxlciBhbmQgZ3VhcmFudGVlZCB0byBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheVxyXG5mYWxsYmFjaykge1xyXG4gICAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB3YXJuKGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgYCArXHJcbiAgICAgICAgICAgIGBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYHBhcmVudCB0ZW1wbGF0ZS5gKTtcclxuICAgICAgICBzbG90ID0gKCkgPT4gW107XHJcbiAgICB9XHJcbiAgICAvLyBhIGNvbXBpbGVkIHNsb3QgZGlzYWJsZXMgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdCB0byBhdm9pZCBtYW51YWxcclxuICAgIC8vIGludm9jYXRpb24gaW50ZXJmZXJpbmcgd2l0aCB0ZW1wbGF0ZS1iYXNlZCBibG9jayB0cmFja2luZywgYnV0IGluXHJcbiAgICAvLyBgcmVuZGVyU2xvdGAgd2UgY2FuIGJlIHN1cmUgdGhhdCBpdCdzIHRlbXBsYXRlLWJhc2VkIHNvIHdlIGNhbiBmb3JjZVxyXG4gICAgLy8gZW5hYmxlIGl0LlxyXG4gICAgaXNSZW5kZXJpbmdDb21waWxlZFNsb3QrKztcclxuICAgIG9wZW5CbG9jaygpO1xyXG4gICAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XHJcbiAgICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IHx8IGBfJHtuYW1lfWAgfSwgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLCB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovXHJcbiAgICAgICAgPyA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9cclxuICAgICAgICA6IC0yIC8qIEJBSUwgKi8pO1xyXG4gICAgaXNSZW5kZXJpbmdDb21waWxlZFNsb3QtLTtcclxuICAgIHJldHVybiByZW5kZXJlZDtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xyXG4gICAgcmV0dXJuIHZub2Rlcy5zb21lKGNoaWxkID0+IHtcclxuICAgICAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pXHJcbiAgICAgICAgPyB2bm9kZXNcclxuICAgICAgICA6IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIFdyYXAgYSBzbG90IGZ1bmN0aW9uIHRvIG1lbW9pemUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2VcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgaWYgKCFjdHgpXHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgLy8gSWYgYSB1c2VyIGNhbGxzIGEgY29tcGlsZWQgc2xvdCBpbnNpZGUgYSB0ZW1wbGF0ZSBleHByZXNzaW9uICgjMTc0NSksIGl0XHJcbiAgICAgICAgLy8gY2FuIG1lc3MgdXAgYmxvY2sgdHJhY2tpbmcsIHNvIGJ5IGRlZmF1bHQgd2UgbmVlZCB0byBwdXNoIGEgbnVsbCBibG9jayB0b1xyXG4gICAgICAgIC8vIGF2b2lkIHRoYXQuIFRoaXMgaXNuJ3QgbmVjZXNzYXJ5IGlmIHJlbmRlcmluZyBhIGNvbXBpbGVkIGA8c2xvdD5gLlxyXG4gICAgICAgIGlmICghaXNSZW5kZXJpbmdDb21waWxlZFNsb3QpIHtcclxuICAgICAgICAgICAgb3BlbkJsb2NrKHRydWUgLyogbnVsbCBibG9jayB0aGF0IGRpc2FibGVzIHRyYWNraW5nICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gZm4oLi4uYXJncyk7XHJcbiAgICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKG93bmVyKTtcclxuICAgICAgICBpZiAoIWlzUmVuZGVyaW5nQ29tcGlsZWRTbG90KSB7XHJcbiAgICAgICAgICAgIGNsb3NlQmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xyXG59XG5cbi8vIFNGQyBzY29wZWQgc3R5bGUgSUQgbWFuYWdlbWVudC5cclxubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcclxuY29uc3Qgc2NvcGVJZFN0YWNrID0gW107XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcclxuICAgIHNjb3BlSWRTdGFjay5wdXNoKChjdXJyZW50U2NvcGVJZCA9IGlkKSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xyXG4gICAgc2NvcGVJZFN0YWNrLnBvcCgpO1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSBzY29wZUlkU3RhY2tbc2NvcGVJZFN0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoU2NvcGVJZChpZCkge1xyXG4gICAgcmV0dXJuICgoZm4pID0+IHdpdGhDdHgoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHB1c2hTY29wZUlkKGlkKTtcclxuICAgICAgICBjb25zdCByZXMgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHBvcFNjb3BlSWQoKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSkpO1xyXG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIC8vIHJlc3VsdCBvZiBiaXR3aXNlIGZsYWcgY29tcGFyaXNvblxyXG5pc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xyXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcclxuICAgIGRlZihhdHRycywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG4gICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcclxuICAgIC8vIHZhbGlkYXRpb25cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bCkge1xyXG4gICAgICAgIC8vIHN0YXRlZnVsXHJcbiAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIG9wdGlvbmFsIHByb3BzLCBwcm9wcyA9PT0gYXR0cnNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gZGVjbGFyZWQgcHJvcHNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGF0dHJzLCB2bm9kZTogeyBwYXRjaEZsYWcgfSB9ID0gaW5zdGFuY2U7XHJcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBpZiAoXHJcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxyXG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcclxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XHJcbiAgICAhKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIChpbnN0YW5jZS50eXBlLl9faG1ySWQgfHxcclxuICAgICAgICAgICAgKGluc3RhbmNlLnBhcmVudCAmJiBpbnN0YW5jZS5wYXJlbnQudHlwZS5fX2htcklkKSkpICYmXHJcbiAgICAgICAgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJlxyXG4gICAgICAgICEocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykpIHtcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAvLyBDb21waWxlci1nZW5lcmF0ZWQgcHJvcHMgJiBubyBrZXlzIGNoYW5nZSwganVzdCBzZXQgdGhlIHVwZGF0ZWRcclxuICAgICAgICAgICAgLy8gdGhlIHByb3BzLlxyXG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBQUk9QUyBmbGFnIGd1YXJhbnRlZXMgcmF3UHJvcHMgdG8gYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0ciAvIHByb3BzIHNlcGFyYXRpb24gd2FzIGRvbmUgb24gaW5pdCBhbmQgd2lsbCBiZSBjb25zaXN0ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjb2RlIHBhdGgsIHNvIGp1c3QgY2hlY2sgaWYgYXR0cnMgaGF2ZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywgY2FtZWxpemVkS2V5LCB2YWx1ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGZ1bGwgcHJvcHMgdXBkYXRlLlxyXG4gICAgICAgIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XHJcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBkeW5hbWljIHByb3BzLCBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSBrZXlzIGZyb21cclxuICAgICAgICAvLyB0aGUgcHJvcHMgb2JqZWN0XHJcbiAgICAgICAgbGV0IGtlYmFiS2V5O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXHJcbiAgICAgICAgICAgICAgICAoIWhhc093bihyYXdQcm9wcywga2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxyXG4gICAgICAgICAgICAgICAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd1Byb3BzIHx8IEVNUFRZX09CSiwga2V5LCB1bmRlZmluZWQsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBmdW5jdGlvbmFsIGNvbXBvbmVudCB3L28gcHJvcHMgZGVjbGFyYXRpb24sIHByb3BzIGFuZFxyXG4gICAgICAgIC8vIGF0dHJzIHBvaW50IHRvIHRoZSBzYW1lIG9iamVjdCBzbyBpdCBzaG91bGQgYWxyZWFkeSBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZXMgZm9yICRhdHRycyBpbiBjYXNlIGl0J3MgdXNlZCBpbiBjb21wb25lbnQgc2xvdHNcclxuICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIgLyogU0VUICovLCAnJGF0dHJzJyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhwcm9wcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xyXG4gICAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgIC8vIGtleSwgcmVmIGFyZSByZXNlcnZlZCBhbmQgbmV2ZXIgcGFzc2VkIGRvd25cclxuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3Agb3B0aW9uIG5hbWVzIGFyZSBjYW1lbGl6ZWQgZHVyaW5nIG5vcm1hbGl6YXRpb24sIHNvIHRvIHN1cHBvcnRcclxuICAgICAgICAgICAgLy8ga2ViYWIgLT4gY2FtZWwgY29udmVyc2lvbiBoZXJlIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIGtleS5cclxuICAgICAgICAgICAgbGV0IGNhbWVsS2V5O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgKGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbnkgbm9uLWRlY2xhcmVkIChlaXRoZXIgYXMgYSBwcm9wIG9yIGFuIGVtaXR0ZWQgZXZlbnQpIHByb3BzIGFyZSBwdXRcclxuICAgICAgICAgICAgICAgIC8vIGludG8gYSBzZXBhcmF0ZSBgYXR0cnNgIG9iamVjdCBmb3Igc3ByZWFkaW5nLiBNYWtlIHN1cmUgdG8gcHJlc2VydmVcclxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIGtleSBjYXNpbmdcclxuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZWVkQ2FzdEtleXMpIHtcclxuICAgICAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgcmF3Q3VycmVudFByb3BzW2tleV0sIGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgIGlmIChvcHQgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCAnZGVmYXVsdCcpO1xyXG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZShwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBib29sZWFuIGNhc3RpbmdcclxuICAgICAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd24ocHJvcHMsIGtleSkgJiYgIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmXHJcbiAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIWFwcENvbnRleHQuZGVvcHQgJiYgY29tcC5fX3Byb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXAuX19wcm9wcztcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XHJcbiAgICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcclxuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcclxuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdykgPT4ge1xyXG4gICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAoa2V5cylcclxuICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xyXG4gICAgICAgICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcclxuICAgICAgICByZXR1cm4gKGNvbXAuX19wcm9wcyA9IEVNUFRZX0FSUik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmF3KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3QocmF3KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSAobm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBvcHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcCBuZWVkcyBib29sZWFuIGNhc3Rpbmcgb3IgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGNvbXAuX19wcm9wcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdKTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xyXG4gICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIHVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayB0eXBlIGNvbnN0cnVjdG9yc1xyXG4vLyBzbyB0aGF0IGl0IHdvcmtzIGFjcm9zcyB2bXMgLyBpZnJhbWVzLlxyXG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gY3RvciAmJiBjdG9yLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XHJcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xyXG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhwcm9wcywgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHJhd1ZhbHVlcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICBpZiAob3B0ID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcChrZXksIHJhd1ZhbHVlc1trZXldLCBvcHQsICFoYXNPd24ocmF3VmFsdWVzLCBrZXkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgaXNBYnNlbnQpIHtcclxuICAgIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciB9ID0gcHJvcDtcclxuICAgIC8vIHJlcXVpcmVkIVxyXG4gICAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XHJcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gbWlzc2luZyBidXQgb3B0aW9uYWxcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdHlwZSBjaGVja1xyXG4gICAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICAgICAgICAvLyB2YWx1ZSBpcyB2YWxpZCBhcyBsb25nIGFzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzIG1hdGNoXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjdXN0b20gdmFsaWRhdG9yXHJcbiAgICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUpKSB7XHJcbiAgICAgICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnQnKTtcclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBsZXQgdmFsaWQ7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gICAgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcclxuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXHJcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcclxuICAgICAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbGlkLFxyXG4gICAgICAgIGV4cGVjdGVkVHlwZVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi5gICtcclxuICAgICAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKX1gO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XHJcbiAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxyXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxyXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcclxuICAgIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcclxuICAgIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xyXG4gICAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xyXG4gICAgcmV0dXJuIGFyZ3Muc29tZShlbGVtID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nKTtcclxufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcclxuICAgICAgICAvLyBjYWNoZSB0aGUgZXJyb3IgaGFuZGxpbmcgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWUgaG9va1xyXG4gICAgICAgIC8vIGNhbiBiZSBwcm9wZXJseSBkZWR1cGVkIGJ5IHRoZSBzY2hlZHVsZXIuIFwiX193ZWhcIiBzdGFuZHMgZm9yIFwid2l0aCBlcnJvclxyXG4gICAgICAgIC8vIGhhbmRsaW5nXCIuXHJcbiAgICAgICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2VoIHx8XHJcbiAgICAgICAgICAgIChob29rLl9fd2VoID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGNhbiBwb3RlbnRpYWxseSBiZSBjYWxsZWQgaW5zaWRlIGVmZmVjdHMuXHJcbiAgICAgICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudEluc3RhbmNlIGR1cmluZyBob29rIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIGhvb2sgZG9lcyBub3Qgc3luY2hyb25vdXNseSB0cmlnZ2VyIG90aGVyIGhvb2tzLCB3aGljaFxyXG4gICAgICAgICAgICAgICAgLy8gY2FuIG9ubHkgYmUgZmFsc2Ugd2hlbiB0aGUgdXNlciBkb2VzIHNvbWV0aGluZyByZWFsbHkgZnVua3kuXHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAocHJlcGVuZCkge1xyXG4gICAgICAgICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JhcHBlZEhvb2s7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3NbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgJycpKTtcclxuICAgICAgICB3YXJuKGAke2FwaU5hbWV9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYCArXHJcbiAgICAgICAgICAgIGBhc3NvY2lhdGVkIHdpdGguIGAgK1xyXG4gICAgICAgICAgICBgTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgK1xyXG4gICAgICAgICAgICAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmBcclxuICAgICAgICAgICAgICAgICkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiBcclxuLy8gcG9zdC1jcmVhdGUgbGlmZWN5Y2xlIHJlZ2lzdHJhdGlvbnMgYXJlIG5vb3BzIGR1cmluZyBTU1JcclxuIWlzSW5TU1JDb21wb25lbnRTZXR1cCAmJiBpbmplY3RIb29rKGxpZmVjeWNsZSwgaG9vaywgdGFyZ2V0KTtcclxuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiIC8qIEJFRk9SRV9NT1VOVCAqLyk7XHJcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIgLyogTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqLyk7XHJcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIgLyogVVBEQVRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIiAvKiBCRUZPUkVfVU5NT1VOVCAqLyk7XHJcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIgLyogVU5NT1VOVEVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFwicnRnXCIgLyogUkVOREVSX1RSSUdHRVJFRCAqLyk7XHJcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUhvb2soXCJydGNcIiAvKiBSRU5ERVJfVFJBQ0tFRCAqLyk7XHJcbmNvbnN0IG9uRXJyb3JDYXB0dXJlZCA9IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IHtcclxuICAgIGluamVjdEhvb2soXCJlY1wiIC8qIEVSUk9SX0NBUFRVUkVEICovLCBob29rLCB0YXJnZXQpO1xyXG59O1xuXG4vLyBTaW1wbGUgZWZmZWN0LlxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XHJcbn1cclxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcclxuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XHJcbiAgICAgICAgd2FybihgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgYCArXHJcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKLCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLCBzLCBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYCArXHJcbiAgICAgICAgICAgIGBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYCk7XHJcbiAgICB9O1xyXG4gICAgbGV0IGdldHRlcjtcclxuICAgIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcclxuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xyXG4gICAgICAgIGZvcmNlVHJpZ2dlciA9ICEhc291cmNlLl9zaGFsbG93O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xyXG4gICAgICAgIGRlZXAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcChzID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUmVmKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzLCBpbnN0YW5jZSwgMiAvKiBXQVRDSF9HRVRURVIgKi8sIFtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyBnZXR0ZXIgd2l0aCBjYlxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMiAvKiBXQVRDSF9HRVRURVIgKi8sIFtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5XHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW29uSW52YWxpZGF0ZV0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IE5PT1A7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2IgJiYgZGVlcCkge1xyXG4gICAgICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcclxuICAgIH1cclxuICAgIGxldCBjbGVhbnVwO1xyXG4gICAgY29uc3Qgb25JbnZhbGlkYXRlID0gKGZuKSA9PiB7XHJcbiAgICAgICAgY2xlYW51cCA9IHJ1bm5lci5vcHRpb25zLm9uU3RvcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgNCAvKiBXQVRDSF9DTEVBTlVQICovKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIGxldCBvbGRWYWx1ZSA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xyXG4gICAgY29uc3Qgam9iID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghcnVubmVyLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJ1bm5lcigpO1xyXG4gICAgICAgICAgICBpZiAoZGVlcCB8fCBmb3JjZVRyaWdnZXIgfHwgaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGJlZm9yZSBydW5uaW5nIGNiIGFnYWluXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSW52YWxpZGF0ZVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxyXG4gICAgICAgICAgICBydW5uZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gaW1wb3J0YW50OiBtYXJrIHRoZSBqb2IgYXMgYSB3YXRjaGVyIGNhbGxiYWNrIHNvIHRoYXQgc2NoZWR1bGVyIGtub3dzXHJcbiAgICAvLyBpdCBpcyBhbGxvd2VkIHRvIHNlbGYtdHJpZ2dlciAoIzE3MjcpXHJcbiAgICBqb2IuYWxsb3dSZWN1cnNlID0gISFjYjtcclxuICAgIGxldCBzY2hlZHVsZXI7XHJcbiAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xyXG4gICAgICAgIHNjaGVkdWxlciA9IGpvYjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkZWZhdWx0OiAncHJlJ1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZSB8fCBpbnN0YW5jZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUHJlRmx1c2hDYihqb2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd2l0aCAncHJlJyBvcHRpb24sIHRoZSBmaXJzdCBjYWxsIG11c3QgaGFwcGVuIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIHNvIGl0IGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgICAgICAgICAgam9iKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcnVubmVyID0gZWZmZWN0KGdldHRlciwge1xyXG4gICAgICAgIGxhenk6IHRydWUsXHJcbiAgICAgICAgb25UcmFjayxcclxuICAgICAgICBvblRyaWdnZXIsXHJcbiAgICAgICAgc2NoZWR1bGVyXHJcbiAgICB9KTtcclxuICAgIHJlY29yZEluc3RhbmNlQm91bmRFZmZlY3QocnVubmVyLCBpbnN0YW5jZSk7XHJcbiAgICAvLyBpbml0aWFsIHJ1blxyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICBqb2IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcnVubmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChydW5uZXIsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJ1bm5lcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBzdG9wKHJ1bm5lcik7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZShpbnN0YW5jZS5lZmZlY3RzLCBydW5uZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gdGhpcy4kd2F0Y2hcclxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcclxuICAgIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSlcclxuICAgICAgICA/ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxyXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcyk7XHJcbiAgICByZXR1cm4gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMsIHRoaXMpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbHVlLCBzZWVuID0gbmV3IFNldCgpKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBzZWVuLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZWVuLmFkZCh2YWx1ZSk7XHJcbiAgICBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2LCBzZWVuKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHtcclxuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzTGVhdmluZzogZmFsc2UsXHJcbiAgICAgICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcclxuICAgICAgICBsZWF2aW5nVk5vZGVzOiBuZXcgTWFwKClcclxuICAgIH07XHJcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcclxuICAgIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIG1vZGU6IFN0cmluZyxcclxuICAgICAgICBhcHBlYXI6IEJvb2xlYW4sXHJcbiAgICAgICAgcGVyc2lzdGVkOiBCb29sZWFuLFxyXG4gICAgICAgIC8vIGVudGVyXHJcbiAgICAgICAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25FbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBsZWF2ZVxyXG4gICAgICAgIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgLy8gYXBwZWFyXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFwcGVhckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3JcclxuICAgIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xyXG4gICAgICAgIGxldCBwcmV2VHJhbnNpdGlvbktleTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFjayByZWFjdGl2aXR5IGZvciB0aGVzZSBwcm9wcyBzbyB1c2UgdGhlIHJhd1xyXG4gICAgICAgICAgICAvLyBwcm9wcyBmb3IgYSBiaXQgYmV0dGVyIHBlcmZcclxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIG1vZGVcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtb2RlICYmICFbJ2luLW91dCcsICdvdXQtaW4nLCAnZGVmYXVsdCddLmluY2x1ZGVzKG1vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCBjaGlsZHJlbiBoYXMgYSBndWFyYW50ZWVkIGxlbmd0aCBvZiAxLlxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgPHRyYW5zaXRpb24+PGtlZXAtYWxpdmUvPjwvdHJhbnNpdGlvbj4sIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgdHlwZSBvZiB0aGUga2VwdC1hbGl2ZSBjaGlsZHJlbi5cclxuICAgICAgICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldEtlZXBBbGl2ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgaWYgKCFpbm5lckNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRJbm5lckNoaWxkID0gb2xkQ2hpbGQgJiYgZ2V0S2VlcEFsaXZlQ2hpbGQob2xkQ2hpbGQpO1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbktleUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgeyBnZXRUcmFuc2l0aW9uS2V5IH0gPSBpbm5lckNoaWxkLnR5cGU7XHJcbiAgICAgICAgICAgIGlmIChnZXRUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRUcmFuc2l0aW9uS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlRyYW5zaXRpb25LZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSBwcmV2VHJhbnNpdGlvbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgbW9kZVxyXG4gICAgICAgICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJlxyXG4gICAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50ICYmXHJcbiAgICAgICAgICAgICAgICAoIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSB8fCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb2xkIHRyZWUncyBob29rcyBpbiBjYXNlIG9mIGR5bmFtaWMgdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgYmV0d2VlbiBkaWZmZXJlbnQgdmlld3NcclxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgb2xkSW5uZXJDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhcmx5IHJlbW92YWwgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcclxuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcclxuICAgIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XHJcbiAgICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XHJcbiAgICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xyXG4gICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XHJcbn1cclxuLy8gVGhlIHRyYW5zaXRpb24gaG9va3MgYXJlIGF0dGFjaGVkIHRvIHRoZSB2bm9kZSBhcyB2bm9kZS50cmFuc2l0aW9uXHJcbi8vIGFuZCB3aWxsIGJlIGNhbGxlZCBhdCBhcHByb3ByaWF0ZSB0aW1pbmcgaW4gdGhlIHJlbmRlcmVyLlxyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IGFwcGVhciwgbW9kZSwgcGVyc2lzdGVkID0gZmFsc2UsIG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uQWZ0ZXJFbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25CZWZvcmVMZWF2ZSwgb25MZWF2ZSwgb25BZnRlckxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciwgb25BcHBlYXIsIG9uQWZ0ZXJBcHBlYXIsIG9uQXBwZWFyQ2FuY2VsbGVkIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xyXG4gICAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xyXG4gICAgICAgIGhvb2sgJiZcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDkgLyogVFJBTlNJVElPTl9IT09LICovLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBob29rcyA9IHtcclxuICAgICAgICBtb2RlLFxyXG4gICAgICAgIHBlcnNpc3RlZCxcclxuICAgICAgICBiZWZvcmVFbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHNhbWUgZWxlbWVudCAodi1zaG93KVxyXG4gICAgICAgICAgICBpZiAoZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3IgdG9nZ2xlZCBlbGVtZW50IHdpdGggc2FtZSBrZXkgKHYtaWYpXHJcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2RlICYmXHJcbiAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiZcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgZWFybHkgcmVtb3ZhbCAobm90IGNhbmNlbGxlZClcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGhvb2ssIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xyXG4gICAgICAgICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJIb29rID0gb25BZnRlckFwcGVhciB8fCBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhvb2spIHtcclxuICAgICAgICAgICAgICAgIGhvb2soZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChlbC5fZW50ZXJDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9sZWF2ZUNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPT09IHZub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPSB2bm9kZTtcclxuICAgICAgICAgICAgaWYgKG9uTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIG9uTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uTGVhdmUubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lKHZub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhvb2tzO1xyXG59XHJcbi8vIHRoZSBwbGFjZWhvbGRlciByZWFsbHkgb25seSBoYW5kbGVzIG9uZSBzcGVjaWFsIGNhc2U6IEtlZXBBbGl2ZVxyXG4vLyBpbiB0aGUgY2FzZSBvZiBhIEtlZXBBbGl2ZSBpbiBhIGxlYXZlIHBoYXNlIHdlIG5lZWQgdG8gcmV0dXJuIGEgS2VlcEFsaXZlXHJcbi8vIHBsYWNlaG9sZGVyIHdpdGggZW1wdHkgY29udGVudCB0byBhdm9pZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGZyb20gYmVpbmdcclxuLy8gdW5tb3VudGVkLlxyXG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XHJcbiAgICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XHJcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEtlZXBBbGl2ZUNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gaXNLZWVwQWxpdmUodm5vZGUpXHJcbiAgICAgICAgPyB2bm9kZS5jaGlsZHJlblxyXG4gICAgICAgICAgICA/IHZub2RlLmNoaWxkcmVuWzBdXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgICAgOiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiYgdm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XHJcbiAgICAgICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgcmV0ID0gW107XHJcbiAgICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vIGhhbmRsZSBmcmFnbWVudCBjaGlsZHJlbiBjYXNlLCBlLmcuIHYtZm9yXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8pXHJcbiAgICAgICAgICAgICAgICBrZXllZEZyYWdtZW50Q291bnQrKztcclxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbW1lbnQgcGxhY2Vob2xkZXJzIHNob3VsZCBiZSBza2lwcGVkLCBlLmcuIHYtaWZcclxuICAgICAgICBlbHNlIGlmIChrZWVwQ29tbWVudCB8fCBjaGlsZC50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjMTEyNiBpZiBhIHRyYW5zaXRpb24gY2hpbGRyZW4gbGlzdCBjb250YWlucyBtdWx0aXBsZSBzdWIgZnJhZ21lbnRzLCB0aGVzZVxyXG4gICAgLy8gZnJhZ21lbnRzIHdpbGwgYmUgbWVyZ2VkIGludG8gYSBmbGF0IGNoaWxkcmVuIGFycmF5LiBTaW5jZSBlYWNoIHYtZm9yXHJcbiAgICAvLyBmcmFnbWVudCBtYXkgY29udGFpbiBkaWZmZXJlbnQgc3RhdGljIGJpbmRpbmdzIGluc2lkZSwgd2UgbmVlZCB0byBkZS1vcFxyXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gdG8gZm9yY2UgZnVsbCBkaWZmcyB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci5cclxuICAgIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yIC8qIEJBSUwgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xyXG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xyXG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXHJcbiAgICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxyXG4gICAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcclxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cclxuICAgIF9faXNLZWVwQWxpdmU6IHRydWUsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XHJcbiAgICAgICAgLy8gS2VlcEFsaXZlIGNvbW11bmljYXRlcyB3aXRoIHRoZSBpbnN0YW50aWF0ZWQgcmVuZGVyZXIgdmlhIHRoZVxyXG4gICAgICAgIC8vIGN0eCB3aGVyZSB0aGUgcmVuZGVyZXIgcGFzc2VzIGluIGl0cyBpbnRlcm5hbHMsXHJcbiAgICAgICAgLy8gYW5kIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZXhwb3NlcyBhY3RpdmF0ZS9kZWFjdGl2YXRlIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAvLyBUaGUgd2hvbGUgcG9pbnQgb2YgdGhpcyBpcyB0byBhdm9pZCBpbXBvcnRpbmcgS2VlcEFsaXZlIGRpcmVjdGx5IGluIHRoZVxyXG4gICAgICAgIC8vIHJlbmRlcmVyIHRvIGZhY2lsaXRhdGUgdHJlZS1zaGFraW5nLlxyXG4gICAgICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAgICAgY29uc3QgeyByZW5kZXJlcjogeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IF91bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9IH0gPSBzaGFyZWRDb250ZXh0O1xyXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSBwcm9wcyBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgcGF0Y2goaW5zdGFuY2Uudm5vZGUsIHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxIC8qIExFQVZFICovLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5kYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNoYXBlRmxhZyBzbyBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgKCFmaWx0ZXIgfHwgIWZpbHRlcihuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCBjYWNoZWQudHlwZSAhPT0gY3VycmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgaW5zdGFuY2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBrZXB0LWFsaXZlLlxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdW5tb3VudCBpdCBub3cgYnV0IGl0IG1pZ2h0IGJlIGxhdGVyLCBzbyByZXNldCBpdHMgZmxhZyBub3cuXHJcbiAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcHJ1bmUgY2FjaGUgb24gaW5jbHVkZS9leGNsdWRlIHByb3AgY2hhbmdlXHJcbiAgICAgICAgd2F0Y2goKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLCAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XHJcbiAgICAgICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xyXG4gICAgICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUobmFtZSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgfSwgXHJcbiAgICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcclxuICAgICAgICB7IGZsdXNoOiAncG9zdCcsIGRlZXA6IHRydWUgfSk7XHJcbiAgICAgICAgLy8gY2FjaGUgc3ViIHRyZWUgYWZ0ZXIgcmVuZGVyXHJcbiAgICAgICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBmaXggIzE2MjEsIHRoZSBwZW5kaW5nQ2FjaGVLZXkgY291bGQgYmUgMFxyXG4gICAgICAgICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvblVwZGF0ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWNoZS5mb3JFYWNoKGNhY2hlZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaW5zdGFuY2Ugd2lsbCBiZSB1bm1vdW50ZWQgYXMgcGFydCBvZiBrZWVwLWFsaXZlJ3MgdW5tb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaW52b2tlIGl0cyBkZWFjdGl2YXRlZCBob29rIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcclxuICAgICAgICAgICAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wKTtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBpZiAoKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcclxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIC8vIGNsb25lIHZub2RlIGlmIGl0J3MgcmV1c2VkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG11dGF0ZSBpdFxyXG4gICAgICAgICAgICBpZiAodm5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gIzE1MTMgaXQncyBwb3NzaWJsZSBmb3IgdGhlIHJldHVybmVkIHZub2RlIHRvIGJlIGNsb25lZCBkdWUgdG8gYXR0clxyXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaCBvciBzY29wZUlkLCBzbyB0aGUgdm5vZGUgaGVyZSBtYXkgbm90IGJlIHRoZSBmaW5hbCB2bm9kZVxyXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG1vdW50ZWQuIEluc3RlYWQgb2YgY2FjaGluZyBpdCBkaXJlY3RseSwgd2Ugc3RvcmUgdGhlIHBlbmRpbmdcclxuICAgICAgICAgICAgLy8ga2V5IGFuZCBjYWNoZSBgaW5zdGFuY2Uuc3ViVHJlZWAgKHRoZSBub3JtYWxpemVkIHZub2RlKSBpblxyXG4gICAgICAgICAgICAvLyBiZWZvcmVNb3VudC9iZWZvcmVVcGRhdGUgaG9va3MuXHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb3B5IG92ZXIgbW91bnRlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcclxuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRyYW5zaXRpb24gaG9va3Mgb24gc3ViVHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyBtb3VudGVkIGFzIGZyZXNoXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGtleSB0aGUgZnJlc2hlc3RcclxuICAgICAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcclxuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdHRlcm4udGVzdCkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiIC8qIEFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiAvKiBERUFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAvLyBjYWNoZSB0aGUgZGVhY3RpdmF0ZSBicmFuY2ggY2hlY2sgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWVcclxuICAgIC8vIGhvb2sgY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dkY1wiIHN0YW5kcyBmb3IgXCJ3aXRoXHJcbiAgICAvLyBkZWFjdGl2YXRpb24gY2hlY2tcIi5cclxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fFxyXG4gICAgICAgIChob29rLl9fd2RjID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGZpcmUgdGhlIGhvb2sgaWYgdGhlIHRhcmdldCBpbnN0YW5jZSBpcyBOT1QgaW4gYSBkZWFjdGl2YXRlZCBicmFuY2guXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob29rKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xyXG4gICAgLy8gSW4gYWRkaXRpb24gdG8gcmVnaXN0ZXJpbmcgaXQgb24gdGhlIHRhcmdldCBpbnN0YW5jZSwgd2Ugd2FsayB1cCB0aGUgcGFyZW50XHJcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgLy8gVGhpcyBhdm9pZHMgdGhlIG5lZWQgdG8gd2FsayB0aGUgZW50aXJlIGNvbXBvbmVudCB0cmVlIHdoZW4gaW52b2tpbmcgdGhlc2VcclxuICAgIC8vIGhvb2tzLCBhbmQgbW9yZSBpbXBvcnRhbnRseSwgYXZvaWRzIHRoZSBuZWVkIHRvIHRyYWNrIGNoaWxkIGNvbXBvbmVudHMgaW5cclxuICAgIC8vIGFycmF5cy5cclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xyXG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXHJcbiAgICAvLyB0aGUgd3JhcHBlZCB2ZXJzaW9uLlxyXG4gICAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKHR5cGUsIGhvb2ssIGtlZXBBbGl2ZVJvb3QsIHRydWUgLyogcHJlcGVuZCAqLyk7XHJcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcclxuICAgIH0sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcclxuICAgIGxldCBzaGFwZUZsYWcgPSB2bm9kZS5zaGFwZUZsYWc7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgPSBzaGFwZUZsYWc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLyA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xyXG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09ICdfJyB8fCBrZXkgPT09ICckc3RhYmxlJztcclxuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKVxyXG4gICAgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpXHJcbiAgICA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xyXG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB3aXRoQ3R4KChwcm9wcykgPT4ge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICB3YXJuKGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IGAgK1xyXG4gICAgICAgICAgICBgdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gYCArXHJcbiAgICAgICAgICAgIGBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdChwcm9wcykpO1xyXG59LCBjdHgpO1xyXG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMpID0+IHtcclxuICAgIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xyXG4gICAgICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3U2xvdHNba2V5XTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkpIHtcclxuICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gYCArXHJcbiAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xyXG4gICAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XHJcbn07XHJcbmNvbnN0IGluaXRTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnNsb3RzID0gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIC8vIG1ha2UgY29tcGlsZXIgbWFya2VyIG5vbi1lbnVtZXJhYmxlXHJcbiAgICAgICAgICAgIGRlZihjaGlsZHJlbiwgJ18nLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCAoaW5zdGFuY2Uuc2xvdHMgPSB7fSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLnNsb3RzID0ge307XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWYoaW5zdGFuY2Uuc2xvdHMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxufTtcclxuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xyXG4gICAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXBpbGVkIHNsb3RzLlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcmVudCB3YXMgSE1SIHVwZGF0ZWQgc28gc2xvdCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSB1cGRhdGUgc2xvdHMgYW5kIG1hcmsgaW5zdGFuY2UgZm9yIGhtciBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgQU5EIHN0YWJsZS5cclxuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdXBkYXRlLCBhbmQgc2tpcCBzdGFsZSBzbG90cyByZW1vdmFsLlxyXG4gICAgICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIGJ1dCBkeW5hbWljICh2LWlmL3YtZm9yIG9uIHNsb3RzKSAtIHVwZGF0ZSBzbG90cywgYnV0IHNraXBcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIC8vIG5vbiBzbG90IG9iamVjdCBjaGlsZHJlbiAoZGlyZWN0IHZhbHVlKSBwYXNzZWQgdG8gYSBjb21wb25lbnRcclxuICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XHJcbiAgICB9XHJcbiAgICAvLyBkZWxldGUgc3RhbGUgc2xvdHNcclxuICAgIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmICEoa2V5IGluIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuXG4vKipcclxuUnVudGltZSBoZWxwZXIgZm9yIGFwcGx5aW5nIGRpcmVjdGl2ZXMgdG8gYSB2bm9kZS4gRXhhbXBsZSB1c2FnZTpcclxuXG5jb25zdCBjb21wID0gcmVzb2x2ZUNvbXBvbmVudCgnY29tcCcpXHJcbmNvbnN0IGZvbyA9IHJlc29sdmVEaXJlY3RpdmUoJ2ZvbycpXHJcbmNvbnN0IGJhciA9IHJlc29sdmVEaXJlY3RpdmUoJ2JhcicpXHJcblxucmV0dXJuIHdpdGhEaXJlY3RpdmVzKGgoY29tcCksIFtcclxuICBbZm9vLCB0aGlzLnhdLFxyXG4gIFtiYXIsIHRoaXMueV1cclxuXSlcclxuKi9cclxuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCcpO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xyXG4gICAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiAnICsgbmFtZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgZGlyZWN0aXZlcyB0byBhIFZOb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcclxuICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XHJcbiAgICAgICAgICAgIGRpciA9IHtcclxuICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGRpcixcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IGRpclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBiaW5kaW5ncy5wdXNoKHtcclxuICAgICAgICAgICAgZGlyLFxyXG4gICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIG9sZFZhbHVlOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIGFyZyxcclxuICAgICAgICAgICAgbW9kaWZpZXJzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgcHJldlZOb2RlLCBpbnN0YW5jZSwgbmFtZSkge1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xyXG4gICAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xyXG4gICAgICAgIGlmIChvbGRCaW5kaW5ncykge1xyXG4gICAgICAgICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcclxuICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCAvKiBESVJFQ1RJVkVfSE9PSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwsXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nLFxyXG4gICAgICAgICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2Vk5vZGVcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFwcDogbnVsbCxcclxuICAgICAgICBjb25maWc6IHtcclxuICAgICAgICAgICAgaXNOYXRpdmVUYWc6IE5PLFxyXG4gICAgICAgICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxyXG4gICAgICAgICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxyXG4gICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQ6IE5PLFxyXG4gICAgICAgICAgICBlcnJvckhhbmRsZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgd2FybkhhbmRsZXI6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWl4aW5zOiBbXSxcclxuICAgICAgICBjb21wb25lbnRzOiB7fSxcclxuICAgICAgICBkaXJlY3RpdmVzOiB7fSxcclxuICAgICAgICBwcm92aWRlczogT2JqZWN0LmNyZWF0ZShudWxsKVxyXG4gICAgfTtcclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcclxuICAgICAgICAgICAgcm9vdFByb3BzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XHJcbiAgICAgICAgICAgIF91aWQ6IHVpZCsrLFxyXG4gICAgICAgICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcclxuICAgICAgICAgICAgX2NvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgIHZlcnNpb24sXHJcbiAgICAgICAgICAgIGdldCBjb25maWcoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCBjb25maWcodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtaXhpbihtaXhpbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsIG1peGluIHdpdGggcHJvcHMvZW1pdHMgZGUtb3B0aW1pemVzIHByb3BzL2VtaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24gY2FjaGluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1peGluLnByb3BzIHx8IG1peGluLmVtaXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRlb3B0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiAnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShyb290Q29tcG9uZW50LCByb290UHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGFwcCBjb250ZXh0IG9uIHRoZSByb290IFZOb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBzZXQgb24gdGhlIHJvb3QgaW5zdGFuY2Ugb24gaW5pdGlhbCBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBITVIgcm9vdCByZWxvYWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudC5wcm94eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVubW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc1VubW91bnRBcHAoYXBwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gY29udGV4dC5wcm92aWRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyB2YWx1ZS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBhbGxvdyBzeW1ib2xzIGFzIGluZGV4IHR5cGVcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjQ1ODdcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhcHA7XHJcbiAgICB9O1xyXG59XG5cbmxldCBoYXNNaXNtYXRjaCA9IGZhbHNlO1xyXG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IC9zdmcvLnRlc3QoY29udGFpbmVyLm5hbWVzcGFjZVVSSSkgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09ICdmb3JlaWduT2JqZWN0JztcclxuY29uc3QgaXNDb21tZW50ID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ09NTUVOVCAqLztcclxuLy8gTm90ZTogaHlkcmF0aW9uIGlzIERPTS1zcGVjaWZpY1xyXG4vLyBCdXQgd2UgaGF2ZSB0byBwbGFjZSBpdCBpbiBjb3JlIGR1ZSB0byB0aWdodCBjb3VwbGluZyB3aXRoIGNvcmUgLSBzcGxpdHRpbmdcclxuLy8gaXQgb3V0IGNyZWF0ZXMgYSB0b24gb2YgdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cclxuLy8gSHlkcmF0aW9uIGFsc28gZGVwZW5kcyBvbiBzb21lIHJlbmRlcmVyIGludGVybmFsIGxvZ2ljIHdoaWNoIG5lZWRzIHRvIGJlXHJcbi8vIHBhc3NlZCBpbiB2aWEgYXJndW1lbnRzLlxyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgIGNvbnN0IHsgbXQ6IG1vdW50Q29tcG9uZW50LCBwOiBwYXRjaCwgbzogeyBwYXRjaFByb3AsIG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCByZW1vdmUsIGluc2VydCwgY3JlYXRlQ29tbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBgICtcclxuICAgICAgICAgICAgICAgIGBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgaWYgKGhhc01pc21hdGNoICYmICFmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBzaG93IHVwIGluIHByb2R1Y3Rpb25cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snO1xyXG4gICAgICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNGcmFnbWVudFN0YXJ0KTtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgICAgICBjb25zdCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcclxuICAgICAgICB2bm9kZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoOmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfWAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIFNlcnZlcjogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFuY2hvciwgYWRvcHQgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdGljIHZub2RlIGhhcyBpdHMgY29udGVudCBzdHJpcHBlZCBkdXJpbmcgYnVpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRvcHQgaXQgZnJvbSB0aGUgc2VydmVyLXJlbmRlcmVkIEhUTUwuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm91dGVySFRNTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50eXBlICE9PSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHNldHRpbmcgdXAgdGhlIHJlbmRlciBlZmZlY3QsIGlmIHRoZSBpbml0aWFsIHZub2RlIGFscmVhZHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgLmVsIHNldCwgdGhlIGNvbXBvbmVudCB3aWxsIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBpdHMgc3ViLXRyZWUuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudCh2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZEFzeW5jID0gdm5vZGUudHlwZS5fX2FzeW5jTG9hZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkQXN5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEFzeW5jKCkudGhlbihoeWRyYXRlQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVDb21wb25lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBiZSBhc3luYywgc28gaW4gdGhlIGNhc2Ugb2YgZnJhZ21lbnRzIHdlIGNhbm5vdCByZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gY29tcG9uZW50J3MgcmVuZGVyZWQgb3V0cHV0IHRvIGRldGVybWluZSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQsIHdlIGRvIGEgbG9va2FoZWFkIHRvIGZpbmQgdGhlIGVuZCBhbmNob3Igbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgeyBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIC8vIHNraXAgcHJvcHMgJiBjaGlsZHJlbiBpZiB0aGlzIGlzIGhvaXN0ZWQgc3RhdGljIG5vZGVzXHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAhPT0gLTEgLyogSE9JU1RFRCAqLykge1xyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpbWl6ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGljayBsaXN0ZW5lcnMgKHdoaWNoIGlzIG1vc3Qgb2Z0ZW4pIHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW5nIHRocm91Z2ggcHJvcHMuXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCAnb25DbGljaycsIG51bGwsIHByb3BzLm9uQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZub2RlIC8gZGlyZWN0aXZlIGhvb2tzXHJcbiAgICAgICAgICAgIGxldCB2bm9kZUhvb2tzO1xyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcclxuICAgICAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8gJiZcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcclxuICAgICAgICAgICAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihlbC5maXJzdENoaWxkLCB2bm9kZSwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgU1NSZWQgRE9NIGNvbnRhaW5zIG1vcmUgbm9kZXMgdGhhbiBpdCBzaG91bGQuIFJlbW92ZSB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjpcXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIFNlcnZlcjogJHt2bm9kZS5jaGlsZHJlbn1gKTtcclxuICAgICAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbC5uZXh0U2libGluZztcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgICAgIDogKGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIFNTUmVkIERPTSBkaWRuJ3QgY29udGFpbiBlbm91Z2ggbm9kZXMuIE1vdW50IHRoZSBtaXNzaW5nIG9uZXMuXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSAnXScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKCh2bm9kZS5hbmNob3IgPSBuZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmcmFnbWVudCBkaWRuJ3QgaHlkcmF0ZSBzdWNjZXNzZnVsbHksIHNpbmNlIHdlIGRpZG4ndCBnZXQgYSBlbmQgYW5jaG9yXHJcbiAgICAgICAgICAgIC8vIGJhY2suIFRoaXMgc2hvdWxkIGhhdmUgbGVkIHRvIG5vZGUvY2hpbGRyZW4gbWlzbWF0Y2ggd2FybmluZ3MuXHJcbiAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGFuY2hvciBpcyBtaXNzaW5nLCB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmUgYW5kIGluc2VydCBpdFxyXG4gICAgICAgICAgICBpbnNlcnQoKHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSksIGNvbnRhaW5lciwgbmV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNGcmFnbWVudCkgPT4ge1xyXG4gICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XFxuLSBDbGllbnQgdm5vZGU6YCwgdm5vZGUudHlwZSwgYFxcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLCBub2RlLCBub2RlLm5vZGVUeXBlID09PSAzIC8qIFRFWFQgKi9cclxuICAgICAgICAgICAgICAgID8gYCh0ZXh0KWBcclxuICAgICAgICAgICAgICAgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWBcclxuICAgICAgICAgICAgICAgICAgICA6IGBgKTtcclxuICAgICAgICB2bm9kZS5lbCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGlzRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4Y2Vzc2l2ZSBmcmFnbWVudCBub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICByZW1vdmUobm9kZSk7XHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbmV4dCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSk7XHJcbiAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yID0gKG5vZGUpID0+IHtcclxuICAgICAgICBsZXQgbWF0Y2ggPSAwO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnWycpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2grKztcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcclxufVxuXG5sZXQgc3VwcG9ydGVkO1xyXG5sZXQgcGVyZjtcclxuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xyXG4gICAgICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xyXG4gICAgICAgIHBlcmYubWFyayhlbmRUYWcpO1xyXG4gICAgICAgIHBlcmYubWVhc3VyZShgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcclxuICAgIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbiAgICB9XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcclxuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG59XG5cbi8qKlxyXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIGluIGVzbS1idW5kbGVyIGJ1aWxkcy5cclxuICogSXQgaXMgY2FsbGVkIHdoZW4gYSByZW5kZXJlciBpcyBjcmVhdGVkLCBpbiBgYmFzZUNyZWF0ZVJlbmRlcmVyYCBzbyB0aGF0XHJcbiAqIGltcG9ydGluZyBydW50aW1lLWNvcmUgaXMgc2lkZS1lZmZlY3RzIGZyZWUuXHJcbiAqXHJcbiAqIGlzdGFuYnVsLWlnbm9yZS1uZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xyXG4gICAgbGV0IG5lZWRXYXJuID0gZmFsc2U7XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIG5lZWRXYXJuID0gdHJ1ZTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgbmVlZFdhcm4gPSB0cnVlO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLiBJdCBpcyByZWNvbW1lbmRlZCB0byBgICtcclxuICAgICAgICAgICAgYGNvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gZXhwbGljaXRseSByZXBsYWNlIGZlYXR1cmUgZmxhZyBnbG9iYWxzIGAgK1xyXG4gICAgICAgICAgICBgd2l0aCBib29sZWFuIGxpdGVyYWxzIHRvIGdldCBwcm9wZXIgdHJlZS1zaGFraW5nIGluIHRoZSBmaW5hbCBidW5kbGUuIGAgK1xyXG4gICAgICAgICAgICBgU2VlIGh0dHA6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzIGZvciBtb3JlIGRldGFpbHMuYCk7XHJcbiAgICB9XHJcbn1cblxuLy8gaW1wbGVtZW50YXRpb24sIGNsb3NlIHRvIG5vLW9wXHJcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IHsgc2V0dXA6IG9wdGlvbnMsIG5hbWU6IG9wdGlvbnMubmFtZSB9IDogb3B0aW9ucztcclxufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xyXG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcclxuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGxvYWRlciwgbG9hZGluZ0NvbXBvbmVudCwgZXJyb3JDb21wb25lbnQsIGRlbGF5ID0gMjAwLCB0aW1lb3V0LCAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcclxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSwgb25FcnJvcjogdXNlck9uRXJyb3IgfSA9IHNvdXJjZTtcclxuICAgIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICBsZXQgcmVzb2x2ZWRDb21wO1xyXG4gICAgbGV0IHJldHJpZXMgPSAwO1xyXG4gICAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0cmllcysrO1xyXG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gbG9hZCgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHRoaXNSZXF1ZXN0O1xyXG4gICAgICAgIHJldHVybiAocGVuZGluZ1JlcXVlc3QgfHxcclxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPSBsb2FkZXIoKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXNlck9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChjb21wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2R1bGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcclxuICAgICAgICAgICAgICAgICAgICAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29tcCAmJiAhaXNPYmplY3QoY29tcCkgJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICAgICAgX19hc3luY0xvYWRlcjogbG9hZCxcclxuICAgICAgICBuYW1lOiAnQXN5bmNDb21wb25lbnRXcmFwcGVyJyxcclxuICAgICAgICBzZXR1cCgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgcmVzb2x2ZWRcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqLywgIWVycm9yQ29tcG9uZW50IC8qIGRvIG5vdCB0aHJvdyBpbiBkZXYgaWYgdXNlciBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgKi8pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBzdXNwZW5zZS1jb250cm9sbGVkIG9yIFNTUi5cclxuICAgICAgICAgICAgaWYgKChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSkgfHxcclxuICAgICAgICAgICAgICAgIChmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY29tcCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkKClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgeyB2bm9kZTogeyByZWYsIHByb3BzLCBjaGlsZHJlbiB9IH0pIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcclxuICAgIC8vIGVuc3VyZSBpbm5lciBjb21wb25lbnQgaW5oZXJpdHMgdGhlIGFzeW5jIHdyYXBwZXIncyByZWYgb3duZXJcclxuICAgIHZub2RlLnJlZiA9IHJlZjtcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxuXG5jb25zdCBwcm9kRWZmZWN0T3B0aW9ucyA9IHtcclxuICAgIHNjaGVkdWxlcjogcXVldWVKb2IsXHJcbiAgICAvLyAjMTgwMSwgIzIwNDMgY29tcG9uZW50IHJlbmRlciBlZmZlY3RzIHNob3VsZCBhbGxvdyByZWN1cnNpdmUgdXBkYXRlc1xyXG4gICAgYWxsb3dSZWN1cnNlOiB0cnVlXHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZURldkVmZmVjdE9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2NoZWR1bGVyOiBxdWV1ZUpvYixcclxuICAgICAgICBhbGxvd1JlY3Vyc2U6IHRydWUsXHJcbiAgICAgICAgb25UcmFjazogaW5zdGFuY2UucnRjID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwLFxyXG4gICAgICAgIG9uVHJpZ2dlcjogaW5zdGFuY2UucnRnID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwXHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlXHJcbiAgICA7XHJcbmNvbnN0IHNldFJlZiA9IChyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlKSA9PiB7XHJcbiAgICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XHJcbiAgICAgICAgcmF3UmVmLmZvckVhY2goKHIsIGkpID0+IHNldFJlZihyLCBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksIHBhcmVudFN1c3BlbnNlLCB2bm9kZSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB2YWx1ZTtcclxuICAgIGlmICghdm5vZGUgfHwgaXNBc3luY1dyYXBwZXIodm5vZGUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdm5vZGUuY29tcG9uZW50LmV4cG9zZWQgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2bm9kZS5lbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIW93bmVyKSB7XHJcbiAgICAgICAgd2FybihgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBgICtcclxuICAgICAgICAgICAgYEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcclxuICAgIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyAob3duZXIucmVmcyA9IHt9KSA6IG93bmVyLnJlZnM7XHJcbiAgICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcclxuICAgIC8vIHVuc2V0IG9sZCByZWZcclxuICAgIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgb2xkUmVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RyaW5nKHJlZikpIHtcclxuICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vICMxNzg5OiBmb3Igbm9uLW51bGwgdmFsdWVzLCBzZXQgdGhlbSBhZnRlciByZW5kZXJcclxuICAgICAgICAvLyBudWxsIHZhbHVlcyBtZWFucyB0aGlzIGlzIHVubW91bnQgYW5kIGl0IHNob3VsZCBub3Qgb3ZlcndyaXRlIGFub3RoZXJcclxuICAgICAgICAvLyByZWYgd2l0aCB0aGUgc2FtZSBrZXlcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgZG9TZXQuaWQgPSAtMTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb1NldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVmKHJlZikpIHtcclxuICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgZG9TZXQuaWQgPSAtMTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb1NldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xyXG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiAvKiBGVU5DVElPTl9SRUYgKi8sIFt2YWx1ZSwgcmVmc10pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybignSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCB2YWx1ZSwgYCgke3R5cGVvZiB2YWx1ZX0pYCk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgY3JlYXRlUmVuZGVyZXIgZnVuY3Rpb24gYWNjZXB0cyB0d28gZ2VuZXJpYyBhcmd1bWVudHM6XHJcbiAqIEhvc3ROb2RlIGFuZCBIb3N0RWxlbWVudCwgY29ycmVzcG9uZGluZyB0byBOb2RlIGFuZCBFbGVtZW50IHR5cGVzIGluIHRoZVxyXG4gKiBob3N0IGVudmlyb25tZW50LiBGb3IgZXhhbXBsZSwgZm9yIHJ1bnRpbWUtZG9tLCBIb3N0Tm9kZSB3b3VsZCBiZSB0aGUgRE9NXHJcbiAqIGBOb2RlYCBpbnRlcmZhY2UgYW5kIEhvc3RFbGVtZW50IHdvdWxkIGJlIHRoZSBET00gYEVsZW1lbnRgIGludGVyZmFjZS5cclxuICpcclxuICogQ3VzdG9tIHJlbmRlcmVycyBjYW4gcGFzcyBpbiB0aGUgcGxhdGZvcm0gc3BlY2lmaWMgdHlwZXMgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogY29uc3QgeyByZW5kZXIsIGNyZWF0ZUFwcCB9ID0gY3JlYXRlUmVuZGVyZXI8Tm9kZSwgRWxlbWVudD4oe1xyXG4gKiAgIHBhdGNoUHJvcCxcclxuICogICAuLi5ub2RlT3BzXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcclxufVxyXG4vLyBTZXBhcmF0ZSBBUEkgZm9yIGNyZWF0aW5nIGh5ZHJhdGlvbi1lbmFibGVkIHJlbmRlcmVyLlxyXG4vLyBIeWRyYXRpb24gbG9naWMgaXMgb25seSB1c2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCBtYWtpbmcgaXRcclxuLy8gdHJlZS1zaGFrYWJsZS5cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcclxuICAgIC8vIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIGNoZWNrXHJcbiAgICB7XHJcbiAgICAgICAgaW5pdEZlYXR1cmVGbGFncygpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XHJcbiAgICAgICAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xyXG4gICAgICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGluc2VydDogaG9zdEluc2VydCwgcmVtb3ZlOiBob3N0UmVtb3ZlLCBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsIGZvcmNlUGF0Y2hQcm9wOiBob3N0Rm9yY2VQYXRjaFByb3AsIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LCBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsIHNldFRleHQ6IGhvc3RTZXRUZXh0LCBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LCBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSwgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZywgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLCBjbG9uZU5vZGU6IGhvc3RDbG9uZU5vZGUsIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50IH0gPSBvcHRpb25zO1xyXG4gICAgLy8gTm90ZTogZnVuY3Rpb25zIGluc2lkZSB0aGlzIGNsb3N1cmUgc2hvdWxkIHVzZSBgY29uc3QgeHh4ID0gKCkgPT4ge31gXHJcbiAgICAvLyBzdHlsZSBpbiBvcmRlciB0byBwcmV2ZW50IGJlaW5nIGlubGluZWQgYnkgbWluaWZpZXJzLlxyXG4gICAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgaXNTVkcgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICAvLyBwYXRjaGluZyAmIG5vdCBzYW1lIHR5cGUsIHVubW91bnQgb2xkIHRyZWVcclxuICAgICAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XHJcbiAgICAgICAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBuMSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yIC8qIEJBSUwgKi8pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzRnJhZ21lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVk5vZGUgdHlwZTonLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCAnJykpLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIHN1cHBvcnQgZm9yIGR5bmFtaWMgY29tbWVudHNcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpID0+IHtcclxuICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERldiAvIEhNUiBvbmx5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcclxuICAgICAgICAvLyBzdGF0aWMgbm9kZXMgYXJlIG9ubHkgcGF0Y2hlZCBkdXJpbmcgZGV2IGZvciBITVJcclxuICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcclxuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XHJcbiAgICAgICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgICAgICAgICAgZWwgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgZWwgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRFbGVtZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaEVsZW1lbnQobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgc2NvcGVJZCwgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB2bm9kZS5lbCAmJlxyXG4gICAgICAgICAgICBob3N0Q2xvbmVOb2RlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdm5vZGUgaGFzIG5vbi1udWxsIGVsLCBpdCBtZWFucyBpdCdzIGJlaW5nIHJldXNlZC5cclxuICAgICAgICAgICAgLy8gT25seSBzdGF0aWMgdm5vZGVzIGNhbiBiZSByZXVzZWQsIHNvIGl0cyBtb3VudGVkIERPTSBub2RlcyBzaG91bGQgYmVcclxuICAgICAgICAgICAgLy8gZXhhY3RseSB0aGUgc2FtZSwgYW5kIHdlIGNhbiBzaW1wbHkgZG8gYSBjbG9uZSBoZXJlLlxyXG4gICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaW4gcHJvZHVjdGlvbiBzaW5jZSBjbG9uZWQgdHJlZXMgY2Fubm90IGJlIEhNUiB1cGRhdGVkLlxyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENsb25lTm9kZSh2bm9kZS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSwgaXNTVkcsIHByb3BzICYmIHByb3BzLmlzKTtcclxuICAgICAgICAgICAgLy8gbW91bnQgY2hpbGRyZW4gZmlyc3QsIHNpbmNlIHNvbWUgcHJvcHMgbWF5IHJlbHkgb24gY2hpbGQgY29udGVudFxyXG4gICAgICAgICAgICAvLyBiZWluZyBhbHJlYWR5IHJlbmRlcmVkLCBlLmcuIGA8c2VsZWN0IHZhbHVlPmBcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCB2bm9kZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4odm5vZGUuY2hpbGRyZW4sIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyAmJiB0eXBlICE9PSAnZm9yZWlnbk9iamVjdCcsIG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNjb3BlSWRcclxuICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgc2NvcGVJZCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdm5vZGUnLCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdm5vZGUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192dWVQYXJlbnRDb21wb25lbnQnLCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vICMxNTgzIEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSBub3QgcmVzb2x2ZWQgY2FzZSwgZW50ZXIgaG9vayBzaG91bGQgY2FsbCB3aGVuIHN1c3BlbnNlIHJlc29sdmVkXHJcbiAgICAgICAgLy8gIzE2ODkgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIHJlc29sdmVkIGNhc2UsIGp1c3QgY2FsbCBpdFxyXG4gICAgICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gKCFwYXJlbnRTdXNwZW5zZSB8fCAocGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpKSAmJlxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICF0cmFuc2l0aW9uLnBlcnNpc3RlZDtcclxuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fFxyXG4gICAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fFxyXG4gICAgICAgICAgICBkaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldFNjb3BlSWQgPSAoZWwsIHNjb3BlSWQsIHZub2RlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcclxuICAgICAgICBpZiAoc2NvcGVJZCkge1xyXG4gICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJlZU93bmVySWQgPSBwYXJlbnRDb21wb25lbnQudHlwZS5fX3Njb3BlSWQ7XHJcbiAgICAgICAgICAgIC8vIHZub2RlJ3Mgb3duIHNjb3BlSWQgYW5kIHRoZSBjdXJyZW50IHBhdGNoZWQgY29tcG9uZW50J3Mgc2NvcGVJZCBpc1xyXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgLSB0aGlzIGlzIGEgc2xvdCBjb250ZW50IG5vZGUuXHJcbiAgICAgICAgICAgIGlmICh0cmVlT3duZXJJZCAmJiB0cmVlT3duZXJJZCAhPT0gc2NvcGVJZCkge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHRyZWVPd25lcklkICsgJy1zJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHN1YlRyZWUgPSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzdWJUcmVlLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTY29wZUlkKGVsLCBwYXJlbnRDb21wb25lbnQudm5vZGUuc2NvcGVJZCwgcGFyZW50Q29tcG9uZW50LnZub2RlLCBwYXJlbnRDb21wb25lbnQucGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIGNoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcclxuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzE0MjYgdGFrZSB0aGUgb2xkIHZub2RlJ3MgcGF0Y2ggZmxhZyBpbnRvIGFjY291bnQgc2luY2UgdXNlciBtYXkgY2xvbmUgYVxyXG4gICAgICAgIC8vIGNvbXBpbGVyLWdlbmVyYXRlZCB2bm9kZSwgd2hpY2ggZGUtb3B0cyB0byBGVUxMX1BST1BTXHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi87XHJcbiAgICAgICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgLy8gdGhlIHByZXNlbmNlIG9mIGEgcGF0Y2hGbGFnIG1lYW5zIHRoaXMgZWxlbWVudCdzIHJlbmRlciBjb2RlIHdhc1xyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyIGFuZCBjYW4gdGFrZSB0aGUgZmFzdCBwYXRoLlxyXG4gICAgICAgICAgICAvLyBpbiB0aGlzIHBhdGggb2xkIG5vZGUgYW5kIG5ldyBub2RlIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcclxuICAgICAgICAgICAgLy8gKGkuZS4gYXQgdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSB0ZW1wbGF0ZSlcclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgcHJvcHMgY29udGFpbiBkeW5hbWljIGtleXMsIGZ1bGwgZGlmZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsYXNzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIGNsYXNzIGJpbmRpbmdzLlxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIgLyogQ0xBU1MgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdjbGFzcycsIG51bGwsIG5ld1Byb3BzLmNsYXNzLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3R5bGVcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgc3R5bGUgYmluZGluZ3NcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA0IC8qIFNUWUxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3N0eWxlJywgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBwcm9wL2F0dHIgYmluZGluZ3NcclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHRoYW4gY2xhc3MgYW5kIHN0eWxlLiBUaGUga2V5cyBvZiBkeW5hbWljIHByb3AvYXR0cnMgYXJlIHNhdmVkIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gZmFzdGVyIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgZHluYW1pYyBrZXlzIGxpa2UgOltmb29dPVwiYmFyXCIgd2lsbCBjYXVzZSB0aGlzIG9wdGltaXphdGlvbiB0b1xyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBvdXQgYW5kIGdvIHRocm91Z2ggYSBmdWxsIGRpZmYgYmVjYXVzZSB3ZSBuZWVkIHRvIHVuc2V0IHRoZSBvbGQga2V5XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmbGFnIGlzIHByZXNlbnQgdGhlbiBkeW5hbWljUHJvcHMgbXVzdCBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChob3N0Rm9yY2VQYXRjaFByb3AgJiYgaG9zdEZvcmNlUGF0Y2hQcm9wKGVsLCBrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgbjEuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGV4dFxyXG4gICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBvbmx5IGR5bmFtaWMgdGV4dCBjaGlsZHJlbi5cclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gdW5vcHRpbWl6ZWQsIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFyZUNoaWxkcmVuU1ZHID0gaXNTVkcgJiYgbjIudHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xyXG4gICAgICAgICAgICAvLyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XHJcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICd1cGRhdGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhlIGZhc3QgcGF0aCBmb3IgYmxvY2tzLlxyXG4gICAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvbnRhaW5lciAocGFyZW50IGVsZW1lbnQpIGZvciB0aGUgcGF0Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IFxyXG4gICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxyXG4gICAgICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgb2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHxcclxuICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqL1xyXG4gICAgICAgICAgICAgICAgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbClcclxuICAgICAgICAgICAgICAgIDogLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBwYXRjaChvbGRWTm9kZSwgbmV3Vk5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCB2bm9kZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBub3QgdmFsaWQgcHJvcFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHxcclxuICAgICAgICAgICAgICAgICAgICAoaG9zdEZvcmNlUGF0Y2hQcm9wICYmIGhvc3RGb3JjZVBhdGNoUHJvcChlbCwga2V5KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgb2xkUHJvcHNba2V5XSwgbnVsbCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSAobjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IChuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAvLyBhIGZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYXJyYXkgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxyXG4gICAgICAgICAgICAvLyBmcm9tIGFycmF5cy5cclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBmcmFnbWVudEVuZEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBjaGlsZHJlbiBvcmRlciwgYnV0IGl0IG1heSBjb250YWluIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcclxuICAgICAgICAgICAgICAgIC8vICBnZXQgbW92ZWQgYXJvdW5kLiBNYWtlIHN1cmUgYWxsIHJvb3QgbGV2ZWwgdm5vZGVzIGluaGVyaXQgZWwuXHJcbiAgICAgICAgICAgICAgICAvLyAjMjEzNCBvciBpZiBpdCdzIGEgY29tcG9uZW50IHJvb3QsIGl0IG1heSBhbHNvIGdldCBtb3ZlZCBhcm91bmRcclxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXHJcbiAgICAgICAgICAgICAgICBuMi5rZXkgIT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnRDb21wb25lbnQgJiYgbjIgPT09IHBhcmVudENvbXBvbmVudC5zdWJUcmVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlIC8qIHNoYWxsb3cgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8ga2V5ZWQgLyB1bmtleWVkLCBvciBtYW51YWwgZnJhZ21lbnRzLlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGtleWVkICYgdW5rZXllZCwgc2luY2UgdGhleSBhcmUgY29tcGlsZXIgZ2VuZXJhdGVkIGZyb20gdi1mb3IsXHJcbiAgICAgICAgICAgICAgICAvLyBlYWNoIGNoaWxkIGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBibG9jayBzbyB0aGUgZnJhZ21lbnQgd2lsbCBuZXZlclxyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBkeW5hbWljQ2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY29udGFpbmVyLCBmcmFnbWVudEVuZEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShpbml0aWFsVk5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCByZW5kZXJlciBpbnRlcm5hbHMgZm9yIGtlZXBBbGl2ZVxyXG4gICAgICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzb2x2ZSBwcm9wcyBhbmQgc2xvdHMgZm9yIHNldHVwIGNvbnRleHRcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0dXAoKSBpcyBhc3luYy4gVGhpcyBjb21wb25lbnQgcmVsaWVzIG9uIGFzeW5jIGxvZ2ljIHRvIGJlIHJlc29sdmVkXHJcbiAgICAgICAgLy8gYmVmb3JlIHByb2NlZWRpbmdcclxuICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KTtcclxuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIHBsYWNlaG9sZGVyIGlmIHRoaXMgaXMgbm90IGh5ZHJhdGlvblxyXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBzZWxmLWRlZmluZWQgZmFsbGJhY2tcclxuICAgICAgICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAmIHN0aWxsIHBlbmRpbmcgLSBqdXN0IHVwZGF0ZSBwcm9wcyBhbmQgc2xvdHNcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb21wb25lbnQncyByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlciBpc24ndCBzZXQtdXAgeWV0XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcclxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdXBkYXRpbmcgdGhlIHNhbWUgY2hpbGQgY29tcG9uZW50IGluIHRoZSBzYW1lIGZsdXNoLlxyXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUpvYihpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QgcnVubmVyLlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZSBuZWVkZWQuIGp1c3QgY29weSBvdmVyIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXJpbmdcclxuICAgICAgICBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QoZnVuY3Rpb24gY29tcG9uZW50RWZmZWN0KCkge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgaGFzIGFkb3B0ZWQgaG9zdCBub2RlIC0gcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICBoeWRyYXRlTm9kZShpbml0aWFsVk5vZGUuZWwsIHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVNb3VudGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZhdGVkIGhvb2sgZm9yIGtlZXAtYWxpdmUgcm9vdHMuXHJcbiAgICAgICAgICAgICAgICAvLyAjMTc0MiBhY3RpdmF0ZWQgaG9vayBtdXN0IGJlIGFjY2Vzc2VkIGFmdGVyIGZpcnN0IHJlbmRlclxyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGhvb2sgbWF5IGJlIGluamVjdGVkIGJ5IGEgY2hpbGQga2VlcC1hbGl2ZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBhIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmIChhICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoYSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAjMjQ1ODogZGVmZXJlbmNlIG1vdW50LW9ubHkgb2JqZWN0IHBhcmFtZXRlcnMgdG8gcHJldmVudCBtZW1sZWFrc1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlID0gY29udGFpbmVyID0gYW5jaG9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0cmlnZ2VyZWQgYnkgbXV0YXRpb24gb2YgY29tcG9uZW50J3Mgb3duIHN0YXRlIChuZXh0OiBudWxsKVxyXG4gICAgICAgICAgICAgICAgLy8gT1IgcGFyZW50IGNhbGxpbmcgcHJvY2Vzc0NvbXBvbmVudCAobmV4dDogVk5vZGUpXHJcbiAgICAgICAgICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luTmV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuZXh0IHx8IGluc3RhbmNlLnZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZVVwZGF0ZSBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYnUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlVXBkYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gocHJldlRyZWUsIG5leHRUcmVlLCBcclxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxyXG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0LmVsID0gbmV4dFRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYtdHJpZ2dlcmVkIHVwZGF0ZS4gSW4gY2FzZSBvZiBIT0MsIHVwZGF0ZSBwYXJlbnQgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgZWwuIEhPQyBpcyBpbmRpY2F0ZWQgYnkgcGFyZW50IGluc3RhbmNlJ3Mgc3ViVHJlZSBwb2ludGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGNoaWxkIGNvbXBvbmVudCdzIHZub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCBuZXh0VHJlZS5lbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmICh1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVVcGRhdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZURldkVmZmVjdE9wdGlvbnMoaW5zdGFuY2UpIDogcHJvZEVmZmVjdE9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XHJcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XHJcbiAgICAgICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XHJcbiAgICAgICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIHByb3BzIHVwZGF0ZSBtYXkgaGF2ZSB0cmlnZ2VyZWQgcHJlLWZsdXNoIHdhdGNoZXJzLlxyXG4gICAgICAgIC8vIGZsdXNoIHRoZW0gYmVmb3JlIHRoZSByZW5kZXIgdXBkYXRlLlxyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnModW5kZWZpbmVkLCBpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBwcmV2U2hhcGVGbGFnID0gbjEgPyBuMS5zaGFwZUZsYWcgOiAwO1xyXG4gICAgICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoXHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBlaXRoZXIgZnVsbHkta2V5ZWQgb3IgbWl4ZWQgKHNvbWUga2V5ZWQgc29tZSBub3QpXHJcbiAgICAgICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiBwYXRjaEZsYWcgbWVhbnMgY2hpbGRyZW4gYXJlIGd1YXJhbnRlZWQgdG8gYmUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHVua2V5ZWRcclxuICAgICAgICAgICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgLy8gdGV4dCBjaGlsZHJlbiBmYXN0IHBhdGhcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYzIgIT09IGMxKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0d28gYXJyYXlzLCBjYW5ub3QgYXNzdW1lIGFueXRoaW5nLCBkbyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZXcgY2hpbGRyZW4sIGp1c3QgdW5tb3VudCBvbGRcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgdGV4dCBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICAvLyBuZXcgY2hpbGRyZW4gaXMgYXJyYXkgT1IgbnVsbFxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXcgaWYgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgcGF0Y2goYzFbaV0sIG5leHRDaGlsZCwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkXHJcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgZmFsc2UsIGNvbW1vbkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBtb3VudCBuZXdcclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQsIGNvbW1vbkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBhbGwta2V5ZWQgb3IgbWl4ZWRcclxuICAgIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7IC8vIHByZXYgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgbGV0IGUyID0gbDIgLSAxOyAvLyBuZXh0IGVuZGluZyBpbmRleFxyXG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKSBkIGVcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMi4gc3luYyBmcm9tIGVuZFxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyBkIGUgKGIgYylcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xyXG4gICAgICAgICAgICBjb25zdCBuMiA9IChjMltlMl0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltlMl0pKTtcclxuICAgICAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlMS0tO1xyXG4gICAgICAgICAgICBlMi0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLiBjb21tb24gc2VxdWVuY2UgKyBtb3VudFxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDEsIGUyID0gMlxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gYyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IC0xLCBlMiA9IDBcclxuICAgICAgICBpZiAoaSA+IGUxKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSksIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDQuIGNvbW1vbiBzZXF1ZW5jZSArIHVubW91bnRcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSAyLCBlMiA9IDFcclxuICAgICAgICAvLyBhIChiIGMpXHJcbiAgICAgICAgLy8gKGIgYylcclxuICAgICAgICAvLyBpID0gMCwgZTEgPSAwLCBlMiA9IC0xXHJcbiAgICAgICAgZWxzZSBpZiAoaSA+IGUyKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDw9IGUxKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1LiB1bmtub3duIHNlcXVlbmNlXHJcbiAgICAgICAgLy8gW2kgLi4uIGUxICsgMV06IGEgYiBbYyBkIGVdIGYgZ1xyXG4gICAgICAgIC8vIFtpIC4uLiBlMiArIDFdOiBhIGIgW2UgZCBjIGhdIGYgZ1xyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDQsIGUyID0gNVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzMSA9IGk7IC8vIHByZXYgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgY29uc3QgczIgPSBpOyAvLyBuZXh0IHN0YXJ0aW5nIGluZGV4XHJcbiAgICAgICAgICAgIC8vIDUuMSBidWlsZCBrZXk6aW5kZXggbWFwIGZvciBuZXdDaGlsZHJlblxyXG4gICAgICAgICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMjsgaSA8PSBlMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCwgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjIgbG9vcCB0aHJvdWdoIG9sZCBjaGlsZHJlbiBsZWZ0IHRvIGJlIHBhdGNoZWQgYW5kIHRyeSB0byBwYXRjaFxyXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBub2RlcyAmIHJlbW92ZSBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudFxyXG4gICAgICAgICAgICBsZXQgajtcclxuICAgICAgICAgICAgbGV0IHBhdGNoZWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xyXG4gICAgICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBub2RlIGhhcyBtb3ZlZFxyXG4gICAgICAgICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XHJcbiAgICAgICAgICAgIC8vIHdvcmtzIGFzIE1hcDxuZXdJbmRleCwgb2xkSW5kZXg+XHJcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbGRJbmRleCBpcyBvZmZzZXQgYnkgKzFcclxuICAgICAgICAgICAgLy8gYW5kIG9sZEluZGV4ID0gMCBpcyBhIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGluZyB0aGUgbmV3IG5vZGUgaGFzXHJcbiAgICAgICAgICAgIC8vIG5vIGNvcnJlc3BvbmRpbmcgb2xkIG5vZGUuXHJcbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGRldGVybWluaW5nIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoaWxkID0gYzFbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBuZXcgY2hpbGRyZW4gaGF2ZSBiZWVuIHBhdGNoZWQgc28gdGhpcyBjYW4gb25seSBiZSBhIHJlbW92YWxcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleS1sZXNzIG5vZGUsIHRyeSB0byBsb2NhdGUgYSBrZXktbGVzcyBub2RlIG9mIHRoZSBzYW1lIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChwcmV2Q2hpbGQsIGMyW25ld0luZGV4XSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gNS4zIG1vdmUgYW5kIG1vdW50XHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlIG9ubHkgd2hlbiBub2RlcyBoYXZlIG1vdmVkXHJcbiAgICAgICAgICAgIGNvbnN0IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlID0gbW92ZWRcclxuICAgICAgICAgICAgICAgID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKVxyXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9BUlI7XHJcbiAgICAgICAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAvLyBsb29waW5nIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiB1c2UgbGFzdCBwYXRjaGVkIG5vZGUgYXMgYW5jaG9yXHJcbiAgICAgICAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHMyICsgaTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXdcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaWY6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3RhYmxlIHN1YnNlcXVlbmNlIChlLmcuIGEgcmV2ZXJzZSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBPUiBjdXJyZW50IG5vZGUgaXMgbm90IGFtb25nIHRoZSBzdGFibGUgc2VxdWVuY2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgICAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2luZ2xlIG5vZGVzXHJcbiAgICAgICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAvKiBSRU9SREVSICovICYmXHJcbiAgICAgICAgICAgIHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uO1xyXG4gICAgICAgIGlmIChuZWVkVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogRU5URVIgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBzaGFwZUZsYWcsIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gdW5zZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIGRpcnM7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xyXG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVbm1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXHJcbiAgICAgICAgICAgICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIGZvciBibG9jayBub2Rlczogb25seSBuZWVkIHRvIHVubW91bnQgZHluYW1pYyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihkeW5hbWljQ2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gRnJhZ21lbnQgJiZcclxuICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLykpIHx8XHJcbiAgICAgICAgICAgICAgICAoIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYW4gdW5tb3VudGVkIHRlbGVwb3J0IHNob3VsZCBhbHdheXMgcmVtb3ZlIGl0cyBjaGlsZHJlbiBpZiBub3QgZGlzYWJsZWRcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovICYmXHJcbiAgICAgICAgICAgICAgICAoZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlVW5tb3VudGVkKSB8fCBzaG91bGRJbnZva2VEaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAndW5tb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVtb3ZlID0gdm5vZGUgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGVyZm9ybVJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xyXG4gICAgICAgIC8vIEZvciBmcmFnbWVudHMsIGRpcmVjdGx5IHJlbW92ZSBhbGwgY29udGFpbmVkIERPTSBub2Rlcy5cclxuICAgICAgICAvLyAoZnJhZ21lbnQgY2hpbGQgbm9kZXMgY2Fubm90IGhhdmUgdHJhbnNpdGlvbilcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoZW5kKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBidW0sIGVmZmVjdHMsIHVwZGF0ZSwgc3ViVHJlZSwgdW0gfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIC8vIGJlZm9yZVVubW91bnQgaG9va1xyXG4gICAgICAgIGlmIChidW0pIHtcclxuICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVmZmVjdHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9wKGVmZmVjdHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVwZGF0ZSBtYXkgYmUgbnVsbCBpZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIGl0cyBhc3luY1xyXG4gICAgICAgIC8vIHNldHVwIGhhcyByZXNvbHZlZC5cclxuICAgICAgICBpZiAodXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHN0b3AodXBkYXRlKTtcclxuICAgICAgICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdW5tb3VudGVkIGhvb2tcclxuICAgICAgICBpZiAodW0pIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgLy8gQSBjb21wb25lbnQgd2l0aCBhc3luYyBkZXAgaW5zaWRlIGEgcGVuZGluZyBzdXNwZW5zZSBpcyB1bm1vdW50ZWQgYmVmb3JlXHJcbiAgICAgICAgLy8gaXRzIGFzeW5jIGRlcCByZXNvbHZlcy4gVGhpcyBzaG91bGQgcmVtb3ZlIHRoZSBkZXAgZnJvbSB0aGUgc3VzcGVuc2UsIGFuZFxyXG4gICAgICAgIC8vIGNhdXNlIHRoZSBzdXNwZW5zZSB0byByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoYXQgd2FzIHRoZSBsYXN0IGRlcC5cclxuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiZcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJlxyXG4gICAgICAgICAgICAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiZcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgJiZcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gdm5vZGUgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaG9zdE5leHRTaWJsaW5nKCh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBpbnRlcm5hbHMgPSB7XHJcbiAgICAgICAgcDogcGF0Y2gsXHJcbiAgICAgICAgdW06IHVubW91bnQsXHJcbiAgICAgICAgbTogbW92ZSxcclxuICAgICAgICByOiByZW1vdmUsXHJcbiAgICAgICAgbXQ6IG1vdW50Q29tcG9uZW50LFxyXG4gICAgICAgIG1jOiBtb3VudENoaWxkcmVuLFxyXG4gICAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxyXG4gICAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxyXG4gICAgICAgIG46IGdldE5leHRIb3N0Tm9kZSxcclxuICAgICAgICBvOiBvcHRpb25zXHJcbiAgICB9O1xyXG4gICAgbGV0IGh5ZHJhdGU7XHJcbiAgICBsZXQgaHlkcmF0ZU5vZGU7XHJcbiAgICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAgICAgICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhpbnRlcm5hbHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW5kZXIsXHJcbiAgICAgICAgaHlkcmF0ZSxcclxuICAgICAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcclxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3IC8qIFZOT0RFX0hPT0sgKi8sIFtcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBwcmV2Vk5vZGVcclxuICAgIF0pO1xyXG59XHJcbi8qKlxyXG4gKiAjMTE1NlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIEhNUi1lbmFibGVkLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBzdGF0aWMgbm9kZXNcclxuICogaW5zaWRlIGEgYmxvY2sgYWxzbyBpbmhlcml0IHRoZSBET00gZWxlbWVudCBmcm9tIHRoZSBwcmV2aW91cyB0cmVlIHNvIHRoYXRcclxuICogSE1SIHVwZGF0ZXMgKHdoaWNoIGFyZSBmdWxsIHVwZGF0ZXMpIGNhbiByZXRyaWV2ZSB0aGUgZWxlbWVudCBmb3IgcGF0Y2hpbmcuXHJcbiAqXHJcbiAqICMyMDgwXHJcbiAqIEluc2lkZSBrZXllZCBgdGVtcGxhdGVgIGZyYWdtZW50IHN0YXRpYyBjaGlsZHJlbiwgaWYgYSBmcmFnbWVudCBpcyBtb3ZlZCxcclxuICogdGhlIGNoaWxkcmVuIHdpbGwgYWx3YXlzIG1vdmVkIHNvIHRoYXQgbmVlZCBpbmhlcml0IGVsIGZvcm0gcHJldmlvdXMgbm9kZXNcclxuICogdG8gZW5zdXJlIGNvcnJlY3QgbW92ZWQgcG9zaXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgY2FsbGVkIGluIHRoZSBvcHRpbWl6ZWQgcGF0aCBzbyBhcnJheSBjaGlsZHJlbiBhcmVcclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlZCB0byBiZSB2bm9kZXNcclxuICAgICAgICAgICAgY29uc3QgYzEgPSBjaDFbaV07XHJcbiAgICAgICAgICAgIGxldCBjMiA9IGNoMltpXTtcclxuICAgICAgICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93KVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIGluaGVyaXQgZm9yIGNvbW1lbnQgbm9kZXMsIGJ1dCBub3QgcGxhY2Vob2xkZXJzIChlLmcuIHYtaWYgd2hpY2hcclxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSByZWNlaXZlZCAuZWwgZHVyaW5nIGJsb2NrIHBhdGNoKVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGMyLnR5cGUgPT09IENvbW1lbnQgJiYgIWMyLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvbmdlc3RfaW5jcmVhc2luZ19zdWJzZXF1ZW5jZVxyXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcclxuICAgIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFswXTtcclxuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xyXG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XHJcbiAgICAgICAgaWYgKGFyckkgIT09IDApIHtcclxuICAgICAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gKCh1ICsgdikgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcclxuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcclxuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xyXG4gICAgICAgIGNvbnN0IHsgbWM6IG1vdW50Q2hpbGRyZW4sIHBjOiBwYXRjaENoaWxkcmVuLCBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbiwgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gaW50ZXJuYWxzO1xyXG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IG4yO1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIGluc2VydCBhbmNob3JzIGluIHRoZSBtYWluIHZpZXdcclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAobjIuZWwgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tbWVudCgndGVsZXBvcnQgc3RhcnQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IGVuZCcpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjY1MiB3ZSBjb3VsZCBiZSB0ZWxlcG9ydGluZyBmcm9tIGEgbm9uLVNWRyB0cmVlIGludG8gYW4gU1ZHIHRyZWVcclxuICAgICAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgKmFsd2F5cyogaGFzIEFycmF5IGNoaWxkcmVuLiBUaGlzIGlzIGVuZm9yY2VkIGluIGJvdGggdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlciBhbmQgdm5vZGUgY2hpbGRyZW4gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSBuMS50YXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKG4yLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIHRlbGVwb3J0IGhhcHBlbnMgdG8gYmUgYSBibG9jayByb290XHJcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBuMi5keW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gYmxvY2sgdHJlZSBtb2RlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCByb290LWxldmVsIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgdGVsZXBvcnQgaW5oZXJpdCBwcmV2aW91cyBET00gcmVmZXJlbmNlcyBzbyB0aGF0IHRoZXkgY2FuXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBtb3ZlZCBpbiBmdXR1cmUgcGF0Y2hlcy5cclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY3VycmVudENvbnRhaW5lciwgY3VycmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZWQgLT4gZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gbWFpbiBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIGNvbnRhaW5lciwgbWFpbkFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRPR0dMRSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIG5leHRUYXJnZXQsIG51bGwsIGludGVybmFscywgMCAvKiBUQVJHRVRfQ0hBTkdFICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIC0+IGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gdGVsZXBvcnQgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCB0YXJnZXQsIHRhcmdldEFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRPR0dMRSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlKHZub2RlLCB7IHI6IHJlbW92ZSwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9KSB7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBhbmNob3IgfSA9IHZub2RlO1xyXG4gICAgICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKGNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXHJcbiAgICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcclxufTtcclxuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMiAvKiBSRU9SREVSICovKSB7XHJcbiAgICAvLyBtb3ZlIHRhcmdldCBhbmNob3IgaWYgdGhpcyBpcyBhIHRhcmdldCBjaGFuZ2UuXHJcbiAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogVEFSR0VUX0NIQU5HRSAqLykge1xyXG4gICAgICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDIgLyogUkVPUkRFUiAqLztcclxuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXHJcbiAgICBpZiAoaXNSZW9yZGVyKSB7XHJcbiAgICAgICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbiAgICAvLyBpZiB0aGlzIGlzIGEgcmUtb3JkZXIgYW5kIHRlbGVwb3J0IGlzIGVuYWJsZWQgKGNvbnRlbnQgaXMgaW4gdGFyZ2V0KVxyXG4gICAgLy8gZG8gbm90IG1vdmUgY2hpbGRyZW4uIFNvIHRoZSBvcHBvc2l0ZSBpczogb25seSBtb3ZlIGNoaWxkcmVuIGlmIHRoaXNcclxuICAgIC8vIGlzIG5vdCBhIHJlb3JkZXIsIG9yIHRoZSB0ZWxlcG9ydCBpcyBkaXNhYmxlZFxyXG4gICAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgIC8vIFRlbGVwb3J0IGhhcyBlaXRoZXIgQXJyYXkgY2hpbGRyZW4gb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIHsgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciB9IH0sIGh5ZHJhdGVDaGlsZHJlbikge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gKHZub2RlLnRhcmdldCA9IHJlc29sdmVUYXJnZXQodm5vZGUucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZSB0ZWxlcG9ydHMgcmVuZGVyZWQgdG8gdGhlIHNhbWUgdGFyZ2V0IGVsZW1lbnQsIHdlIG5lZWQgdG9cclxuICAgICAgICAvLyBwaWNrIHVwIGZyb20gd2hlcmUgdGhlIGxhc3QgdGVsZXBvcnQgZmluaXNoZWQgaW5zdGVhZCBvZiB0aGUgZmlyc3Qgbm9kZVxyXG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgaWYgKGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIHBhcmVudE5vZGUobm9kZSksIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YXJnZXQuX2xwYSA9XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XHJcbn1cclxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcclxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5cbmNvbnN0IENPTVBPTkVOVFMgPSAnY29tcG9uZW50cyc7XHJcbmNvbnN0IERJUkVDVElWRVMgPSAnZGlyZWN0aXZlcyc7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUpIHx8IG5hbWU7XHJcbn1cclxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGludmFsaWQgdHlwZXMgd2lsbCBmYWxsdGhyb3VnaCB0byBjcmVhdGVWTm9kZSBhbmQgcmFpc2Ugd2FybmluZ1xyXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgLy8gc2VsZiBuYW1lIGhhcyBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcclxuICAgICAgICAgICAgLy8gc3BlY2lhbCBzZWxmIHJlZmVyZW5jaW5nIGNhbGwgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVyXHJcbiAgICAgICAgICAgIC8vIGluZmVycmVkIGZyb20gU0ZDIGZpbGVuYW1lXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBgX3NlbGZgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcclxuICAgICAgICAgICAgICAgIChzZWxmTmFtZSA9PT0gbmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gXHJcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3QgZm9yIGNvbXBvbmVudHMgd2l0aCBtaXhpbiBvciBleHRlbmRzLlxyXG4gICAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fFxyXG4gICAgICAgICAgICAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gYCArXHJcbiAgICAgICAgICAgIGBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIChyZWdpc3RyeSAmJlxyXG4gICAgICAgIChyZWdpc3RyeVtuYW1lXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKSk7XHJcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0ZyYWdtZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFRleHQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1RleHQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgQ29tbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnQ29tbWVudCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBTdGF0aWMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1N0YXRpYycgOiB1bmRlZmluZWQpO1xyXG4vLyBTaW5jZSB2LWlmIGFuZCB2LWZvciBhcmUgdGhlIHR3byBwb3NzaWJsZSB3YXlzIG5vZGUgc3RydWN0dXJlIGNhbiBkeW5hbWljYWxseVxyXG4vLyBjaGFuZ2UsIG9uY2Ugd2UgY29uc2lkZXIgdi1pZiBicmFuY2hlcyBhbmQgZWFjaCB2LWZvciBmcmFnbWVudCBhIGJsb2NrLCB3ZVxyXG4vLyBjYW4gZGl2aWRlIGEgdGVtcGxhdGUgaW50byBuZXN0ZWQgYmxvY2tzLCBhbmQgd2l0aGluIGVhY2ggYmxvY2sgdGhlIG5vZGVcclxuLy8gc3RydWN0dXJlIHdvdWxkIGJlIHN0YWJsZS4gVGhpcyBhbGxvd3MgdXMgdG8gc2tpcCBtb3N0IGNoaWxkcmVuIGRpZmZpbmdcclxuLy8gYW5kIG9ubHkgd29ycnkgYWJvdXQgdGhlIGR5bmFtaWMgbm9kZXMgKGluZGljYXRlZCBieSBwYXRjaCBmbGFncykuXHJcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcclxubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XHJcbi8qKlxyXG4gKiBPcGVuIGEgYmxvY2suXHJcbiAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AuIEl0IGNhbm5vdCBiZSBwYXJ0IG9mIGBjcmVhdGVCbG9ja2BcclxuICogYmVjYXVzZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGJsb2NrIGFyZSBldmFsdWF0ZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AgaXRzZWxmXHJcbiAqIGlzIGNhbGxlZC4gVGhlIGdlbmVyYXRlZCBjb2RlIHR5cGljYWxseSBsb29rcyBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICogICByZXR1cm4gKG9wZW5CbG9jaygpLGNyZWF0ZUJsb2NrKCdkaXYnLCBudWxsLCBbLi4uXSkpXHJcbiAqIH1cclxuICogYGBgXHJcbiAqIGRpc2FibGVUcmFja2luZyBpcyB0cnVlIHdoZW4gY3JlYXRpbmcgYSB2LWZvciBmcmFnbWVudCBibG9jaywgc2luY2UgYSB2LWZvclxyXG4gKiBmcmFnbWVudCBhbHdheXMgZGlmZnMgaXRzIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XHJcbiAgICBibG9ja1N0YWNrLnB1c2goKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XHJcbiAgICBibG9ja1N0YWNrLnBvcCgpO1xyXG4gICAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XHJcbn1cclxuLy8gV2hldGhlciB3ZSBzaG91bGQgYmUgdHJhY2tpbmcgZHluYW1pYyBjaGlsZCBub2RlcyBpbnNpZGUgYSBibG9jay5cclxuLy8gT25seSB0cmFja3Mgd2hlbiB0aGlzIHZhbHVlIGlzID4gMFxyXG4vLyBXZSBhcmUgbm90IHVzaW5nIGEgc2ltcGxlIGJvb2xlYW4gYmVjYXVzZSB0aGlzIHZhbHVlIG1heSBuZWVkIHRvIGJlXHJcbi8vIGluY3JlbWVudGVkL2RlY3JlbWVudGVkIGJ5IG5lc3RlZCB1c2FnZSBvZiB2LW9uY2UgKHNlZSBiZWxvdylcclxubGV0IHNob3VsZFRyYWNrID0gMTtcclxuLyoqXHJcbiAqIEJsb2NrIHRyYWNraW5nIHNvbWV0aW1lcyBuZWVkcyB0byBiZSBkaXNhYmxlZCwgZm9yIGV4YW1wbGUgZHVyaW5nIHRoZVxyXG4gKiBjcmVhdGlvbiBvZiBhIHRyZWUgdGhhdCBuZWVkcyB0byBiZSBjYWNoZWQgYnkgdi1vbmNlLiBUaGUgY29tcGlsZXIgZ2VuZXJhdGVzXHJcbiAqIGNvZGUgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogX2NhY2hlWzFdIHx8IChcclxuICogICBzZXRCbG9ja1RyYWNraW5nKC0xKSxcclxuICogICBfY2FjaGVbMV0gPSBjcmVhdGVWTm9kZSguLi4pLFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXHJcbiAqICAgX2NhY2hlWzFdXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XHJcbiAgICBzaG91bGRUcmFjayArPSB2YWx1ZTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgYmxvY2sgcm9vdCB2bm9kZS4gVGFrZXMgdGhlIHNhbWUgZXhhY3QgYXJndW1lbnRzIGFzIGBjcmVhdGVWTm9kZWAuXHJcbiAqIEEgYmxvY2sgcm9vdCBrZWVwcyB0cmFjayBvZiBkeW5hbWljIG5vZGVzIHdpdGhpbiB0aGUgYmxvY2sgaW4gdGhlXHJcbiAqIGBkeW5hbWljQ2hpbGRyZW5gIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCB0cnVlIC8qIGlzQmxvY2s6IHByZXZlbnQgYSBibG9jayBmcm9tIHRyYWNraW5nIGl0c2VsZiAqLyk7XHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgYmxvY2sgY2hpbGRyZW4gb24gdGhlIGJsb2NrIHZub2RlXHJcbiAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBjdXJyZW50QmxvY2sgfHwgRU1QVFlfQVJSO1xyXG4gICAgLy8gY2xvc2UgYmxvY2tcclxuICAgIGNsb3NlQmxvY2soKTtcclxuICAgIC8vIGEgYmxvY2sgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIHBhdGNoZWQsIHNvIHRyYWNrIGl0IGFzIGEgY2hpbGQgb2YgaXRzXHJcbiAgICAvLyBwYXJlbnQgYmxvY2tcclxuICAgIGlmIChzaG91bGRUcmFjayA+IDAgJiYgY3VycmVudEJsb2NrKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIG4yLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xyXG4gICAgICAgIC8vIEhNUiBvbmx5OiBpZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGhvdC11cGRhdGVkLCBmb3JjZSBhIHJlbG9hZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcclxufVxyXG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBBUEkgZm9yIHJlZ2lzdGVyaW5nIGFuIGFyZ3VtZW50cyB0cmFuc2Zvcm0gZm9yIGNyZWF0ZVZOb2RlXHJcbiAqIHVzZWQgZm9yIGNyZWF0aW5nIHN0dWJzIGluIHRoZSB0ZXN0LXV0aWxzXHJcbiAqIEl0IGlzICppbnRlcm5hbCogYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQgZm9yIHRlc3QtdXRpbHMgdG8gcGljayB1cCBwcm9wZXJcclxuICogdHlwaW5nc1xyXG4gKi9cclxuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XHJcbiAgICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xyXG59XHJcbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgcmV0dXJuIF9jcmVhdGVWTm9kZSguLi4odm5vZGVBcmdzVHJhbnNmb3JtZXJcclxuICAgICAgICA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSlcclxuICAgICAgICA6IGFyZ3MpKTtcclxufTtcclxuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xyXG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xyXG5jb25zdCBub3JtYWxpemVSZWYgPSAoeyByZWYgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChyZWYgIT0gbnVsbFxyXG4gICAgICAgID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKVxyXG4gICAgICAgICAgICA/IHsgaTogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCByOiByZWYgfVxyXG4gICAgICAgICAgICA6IHJlZlxyXG4gICAgICAgIDogbnVsbCk7XHJcbn07XHJcbmNvbnN0IGNyZWF0ZVZOb2RlID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtXHJcbiAgICA6IF9jcmVhdGVWTm9kZSk7XHJcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0eXBlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0eXBlID0gQ29tbWVudDtcclxuICAgIH1cclxuICAgIGlmIChpc1ZOb2RlKHR5cGUpKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlVk5vZGUgcmVjZWl2aW5nIGFuIGV4aXN0aW5nIHZub2RlLiBUaGlzIGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxyXG4gICAgICAgIC8vIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIi8+XHJcbiAgICAgICAgLy8gIzIwNzggbWFrZSBzdXJlIHRvIG1lcmdlIHJlZnMgZHVyaW5nIHRoZSBjbG9uZSBpbnN0ZWFkIG9mIG92ZXJ3cml0aW5nIGl0XHJcbiAgICAgICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh0eXBlLCBwcm9wcywgdHJ1ZSAvKiBtZXJnZVJlZjogdHJ1ZSAqLyk7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xvbmVkO1xyXG4gICAgfVxyXG4gICAgLy8gY2xhc3MgY29tcG9uZW50IG5vcm1hbGl6YXRpb24uXHJcbiAgICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xyXG4gICAgICAgIHR5cGUgPSB0eXBlLl9fdmNjT3B0cztcclxuICAgIH1cclxuICAgIC8vIGNsYXNzICYgc3R5bGUgbm9ybWFsaXphdGlvbi5cclxuICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgIC8vIGZvciByZWFjdGl2ZSBvciBwcm94eSBvYmplY3RzLCB3ZSBuZWVkIHRvIGNsb25lIGl0IHRvIGVuYWJsZSBtdXRhdGlvbi5cclxuICAgICAgICBpZiAoaXNQcm94eShwcm9wcykgfHwgSW50ZXJuYWxPYmplY3RLZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgcHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XHJcbiAgICAgICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcclxuICAgICAgICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcclxuICAgICAgICAgICAgLy8gcmVhY3RpdmUgc3RhdGUgb2JqZWN0cyBuZWVkIHRvIGJlIGNsb25lZCBzaW5jZSB0aGV5IGFyZSBsaWtlbHkgdG8gYmVcclxuICAgICAgICAgICAgLy8gbXV0YXRlZFxyXG4gICAgICAgICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGVuY29kZSB0aGUgdm5vZGUgdHlwZSBpbmZvcm1hdGlvbiBpbnRvIGEgYml0bWFwXHJcbiAgICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKVxyXG4gICAgICAgID8gMSAvKiBFTEVNRU5UICovXHJcbiAgICAgICAgOiBpc1N1c3BlbnNlKHR5cGUpXHJcbiAgICAgICAgICAgID8gMTI4IC8qIFNVU1BFTlNFICovXHJcbiAgICAgICAgICAgIDogaXNUZWxlcG9ydCh0eXBlKVxyXG4gICAgICAgICAgICAgICAgPyA2NCAvKiBURUxFUE9SVCAqL1xyXG4gICAgICAgICAgICAgICAgOiBpc09iamVjdCh0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi9cclxuICAgICAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24odHlwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAyIC8qIEZVTkNUSU9OQUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8gJiYgaXNQcm94eSh0eXBlKSkge1xyXG4gICAgICAgIHR5cGUgPSB0b1Jhdyh0eXBlKTtcclxuICAgICAgICB3YXJuKGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgd2hpY2ggd2FzIG1hZGUgYSByZWFjdGl2ZSBvYmplY3QuIFRoaXMgY2FuIGAgK1xyXG4gICAgICAgICAgICBgbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCwgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IGAgK1xyXG4gICAgICAgICAgICBgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGAgK1xyXG4gICAgICAgICAgICBgaW5zdGVhZCBvZiBcXGByZWZcXGAuYCwgYFxcbkNvbXBvbmVudCB0aGF0IHdhcyBtYWRlIHJlYWN0aXZlOiBgLCB0eXBlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZub2RlID0ge1xyXG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxyXG4gICAgICAgIFtcIl9fdl9za2lwXCIgLyogU0tJUCAqL106IHRydWUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXHJcbiAgICAgICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxyXG4gICAgICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxyXG4gICAgICAgIGNoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcclxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcclxuICAgICAgICBzc0NvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcclxuICAgICAgICBkaXJzOiBudWxsLFxyXG4gICAgICAgIHRyYW5zaXRpb246IG51bGwsXHJcbiAgICAgICAgZWw6IG51bGwsXHJcbiAgICAgICAgYW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IDAsXHJcbiAgICAgICAgc2hhcGVGbGFnLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyB2YWxpZGF0ZSBrZXlcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcclxuICAgICAgICB3YXJuKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xyXG4gICAgLy8gbm9ybWFsaXplIHN1c3BlbnNlIGNoaWxkcmVuXHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgY29uc3QgeyBjb250ZW50LCBmYWxsYmFjayB9ID0gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSk7XHJcbiAgICAgICAgdm5vZGUuc3NDb250ZW50ID0gY29udGVudDtcclxuICAgICAgICB2bm9kZS5zc0ZhbGxiYWNrID0gZmFsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkVHJhY2sgPiAwICYmXHJcbiAgICAgICAgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXHJcbiAgICAgICAgIWlzQmxvY2tOb2RlICYmXHJcbiAgICAgICAgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXHJcbiAgICAgICAgY3VycmVudEJsb2NrICYmXHJcbiAgICAgICAgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cclxuICAgICAgICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcclxuICAgICAgICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cclxuICAgICAgICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXHJcbiAgICAgICAgKHBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXHJcbiAgICAgICAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cclxuICAgICAgICBwYXRjaEZsYWcgIT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcclxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBOT1QgdXNpbmcgc3ByZWFkIG9yIGV4dGVuZCB0byBhdm9pZCB0aGUgcnVudGltZVxyXG4gICAgLy8ga2V5IGVudW1lcmF0aW9uIGNvc3QuXHJcbiAgICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgW1wiX192X3NraXBcIiAvKiBTS0lQICovXTogdHJ1ZSxcclxuICAgICAgICB0eXBlOiB2bm9kZS50eXBlLFxyXG4gICAgICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcclxuICAgICAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXHJcbiAgICAgICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmXHJcbiAgICAgICAgICAgID8gLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXHJcbiAgICAgICAgICAgICAgICBtZXJnZVJlZiAmJiByZWZcclxuICAgICAgICAgICAgICAgICAgICA/IGlzQXJyYXkocmVmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV1cclxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxyXG4gICAgICAgICAgICA6IHJlZixcclxuICAgICAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxyXG4gICAgICAgIGNoaWxkcmVuOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovICYmIGlzQXJyYXkoY2hpbGRyZW4pXHJcbiAgICAgICAgICAgID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKVxyXG4gICAgICAgICAgICA6IGNoaWxkcmVuLFxyXG4gICAgICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxyXG4gICAgICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxyXG4gICAgICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcclxuICAgICAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcclxuICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xyXG4gICAgICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXHJcbiAgICAgICAgLy8gbm90ZTogcGVyc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxyXG4gICAgICAgIC8vIGZhc3QgcGF0aHMgb25seS5cclxuICAgICAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnRcclxuICAgICAgICAgICAgPyBwYXRjaEZsYWcgPT09IC0xIC8vIGhvaXN0ZWQgbm9kZVxyXG4gICAgICAgICAgICAgICAgPyAxNiAvKiBGVUxMX1BST1BTICovXHJcbiAgICAgICAgICAgICAgICA6IHBhdGNoRmxhZyB8IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgOiBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcclxuICAgICAgICBkaXJzOiB2bm9kZS5kaXJzLFxyXG4gICAgICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXHJcbiAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXHJcbiAgICAgICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XHJcbiAgICAgICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xyXG4gICAgICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXHJcbiAgICAgICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxyXG4gICAgICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcclxuICAgICAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXHJcbiAgICAgICAgZWw6IHZub2RlLmVsLFxyXG4gICAgICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBEZXYgb25seSwgZm9yIEhNUiBvZiBob2lzdGVkIHZub2RlcyByZXVzZWQgaW4gdi1mb3JcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy8yMDIyXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xyXG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gJyAnLCBmbGFnID0gMCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xyXG4gICAgLy8gQSBzdGF0aWMgdm5vZGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgc3RyaW5naWZpZWQgZWxlbWVudHMsIGFuZCB0aGUgbnVtYmVyXHJcbiAgICAvLyBvZiBlbGVtZW50cyBpcyBuZWNlc3NhcnkgZm9yIGh5ZHJhdGlvbi5cclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcclxuICAgIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gJycsIFxyXG4vLyB3aGVuIHVzZWQgYXMgdGhlIHYtZWxzZSBicmFuY2gsIHRoZSBjb21tZW50IG5vZGUgbXVzdCBiZSBjcmVhdGVkIGFzIGFcclxuLy8gYmxvY2sgdG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcy5cclxuYXNCbG9jayA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gYXNCbG9ja1xyXG4gICAgICAgID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50LCBudWxsLCB0ZXh0KSlcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XHJcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIC8vIGVtcHR5IHBsYWNlaG9sZGVyXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcclxuICAgICAgICAvLyBmcmFnbWVudFxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShGcmFnbWVudCwgbnVsbCwgY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIGFscmVhZHkgdm5vZGUsIHRoaXMgc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiBzaW5jZSBjb21waWxlZCB0ZW1wbGF0ZXNcclxuICAgICAgICAvLyBhbHdheXMgcHJvZHVjZSBhbGwtdm5vZGUgY2hpbGRyZW4gYXJyYXlzXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnNcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gb3B0aW1pemVkIG5vcm1hbGl6YXRpb24gZm9yIHRlbXBsYXRlLWNvbXBpbGVkIHJlbmRlciBmbnNcclxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcclxuICAgIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgdHlwZSA9IDA7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gfHwgc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHNsb3QgdG8gcGxhaW4gY2hpbGRyZW4gZm9yIHBsYWluIGVsZW1lbnQgYW5kIFRlbGVwb3J0XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gX2MgbWFya2VyIGlzIGFkZGVkIGJ5IHdpdGhDdHgoKSBpbmRpY2F0aW5nIHRoaXMgaXMgYSBjb21waWxlZCBzbG90XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIHNldENvbXBpbGVkU2xvdFJlbmRlcmluZygxKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5fYyAmJiBzZXRDb21waWxlZFNsb3RSZW5kZXJpbmcoLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgICAgICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RGbGFnICYmICEoSW50ZXJuYWxPYmplY3RLZXkgaW4gY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsb3RGbGFnID09PSAzIC8qIEZPUldBUkRFRCAqLyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgY2hpbGQgY29tcG9uZW50IHJlY2VpdmVzIGZvcndhcmRlZCBzbG90cyBmcm9tIHRoZSBwYXJlbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBpdHMgc2xvdCB0eXBlIGlzIGRldGVybWluZWQgYnkgaXRzIHBhcmVudCdzIHNsb3QgdHlwZS5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uudm5vZGUucGF0Y2hGbGFnICYgMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDIgLyogRFlOQU1JQyAqLztcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDEgLyogU1RBQkxFICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xyXG4gICAgICAgIHR5cGUgPSAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcclxuICAgICAgICAvLyBmb3JjZSB0ZWxlcG9ydCBjaGlsZHJlbiB0byBhcnJheSBzbyBpdCBjYW4gYmUgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLztcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gOCAvKiBURVhUX0NISUxEUkVOICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHJldCA9IGV4dGVuZCh7fSwgYXJnc1swXSk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgIT09IGluY29taW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgdG9NZXJnZVtrZXldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGluY29taW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XHJcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBpbmhlcml0cyBpdHMgcGFyZW50J3MgcHJvdmlkZXMgb2JqZWN0XHJcbiAgICAgICAgLy8gYnV0IHdoZW4gaXQgbmVlZHMgdG8gcHJvdmlkZSB2YWx1ZXMgb2YgaXRzIG93biwgaXQgY3JlYXRlcyBpdHNcclxuICAgICAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxyXG4gICAgICAgIC8vIHRoaXMgd2F5IGluIGBpbmplY3RgIHdlIGNhbiBzaW1wbHkgbG9vayB1cCBpbmplY3Rpb25zIGZyb20gZGlyZWN0XHJcbiAgICAgICAgLy8gcGFyZW50IGFuZCBsZXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkbyB0aGUgd29yay5cclxuICAgICAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcclxuICAgICAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xyXG4gICAgLy8gZmFsbGJhY2sgdG8gYGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZWAgc28gdGhhdCB0aGlzIGNhbiBiZSBjYWxsZWQgaW5cclxuICAgIC8vIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcclxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIC8vICMyNDAwXHJcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBgYXBwLnVzZWAgcGx1Z2lucyxcclxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHBDb250ZXh0J3MgYHByb3ZpZGVzYCBpZiB0aGUgaW50YW5jZSBpcyBhdCByb290XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbFxyXG4gICAgICAgICAgICA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlc1xyXG4gICAgICAgICAgICA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcclxuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZSgpXHJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xyXG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxubGV0IGlzSW5CZWZvcmVDcmVhdGUgPSBmYWxzZTtcclxuZnVuY3Rpb24gYXBwbHlPcHRpb25zKGluc3RhbmNlLCBvcHRpb25zLCBkZWZlcnJlZERhdGEgPSBbXSwgZGVmZXJyZWRXYXRjaCA9IFtdLCBkZWZlcnJlZFByb3ZpZGUgPSBbXSwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IFxyXG4gICAgLy8gY29tcG9zaXRpb25cclxuICAgIG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMsIFxyXG4gICAgLy8gc3RhdGVcclxuICAgIGRhdGE6IGRhdGFPcHRpb25zLCBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLCBtZXRob2RzLCB3YXRjaDogd2F0Y2hPcHRpb25zLCBwcm92aWRlOiBwcm92aWRlT3B0aW9ucywgaW5qZWN0OiBpbmplY3RPcHRpb25zLCBcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGJlZm9yZU1vdW50LCBtb3VudGVkLCBiZWZvcmVVcGRhdGUsIHVwZGF0ZWQsIGFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQsIGJlZm9yZURlc3Ryb3ksIGJlZm9yZVVubW91bnQsIGRlc3Ryb3llZCwgdW5tb3VudGVkLCByZW5kZXIsIHJlbmRlclRyYWNrZWQsIHJlbmRlclRyaWdnZXJlZCwgZXJyb3JDYXB0dXJlZCwgXHJcbiAgICAvLyBwdWJsaWMgQVBJXHJcbiAgICBleHBvc2UgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XHJcbiAgICBjb25zdCBnbG9iYWxNaXhpbnMgPSBpbnN0YW5jZS5hcHBDb250ZXh0Lm1peGlucztcclxuICAgIGlmIChhc01peGluICYmIHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XHJcbiAgICB9XHJcbiAgICAvLyBhcHBseU9wdGlvbnMgaXMgY2FsbGVkIG5vbi1hcy1taXhpbiBvbmNlIHBlciBpbnN0YW5jZVxyXG4gICAgaWYgKCFhc01peGluKSB7XHJcbiAgICAgICAgaXNJbkJlZm9yZUNyZWF0ZSA9IHRydWU7XHJcbiAgICAgICAgY2FsbFN5bmNIb29rKCdiZWZvcmVDcmVhdGUnLCBcImJjXCIgLyogQkVGT1JFX0NSRUFURSAqLywgb3B0aW9ucywgaW5zdGFuY2UsIGdsb2JhbE1peGlucyk7XHJcbiAgICAgICAgaXNJbkJlZm9yZUNyZWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgZmlyc3RcclxuICAgICAgICBhcHBseU1peGlucyhpbnN0YW5jZSwgZ2xvYmFsTWl4aW5zLCBkZWZlcnJlZERhdGEsIGRlZmVycmVkV2F0Y2gsIGRlZmVycmVkUHJvdmlkZSk7XHJcbiAgICB9XHJcbiAgICAvLyBleHRlbmRpbmcgYSBiYXNlIGNvbXBvbmVudC4uLlxyXG4gICAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XHJcbiAgICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlLCBleHRlbmRzT3B0aW9ucywgZGVmZXJyZWREYXRhLCBkZWZlcnJlZFdhdGNoLCBkZWZlcnJlZFByb3ZpZGUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLy8gbG9jYWwgbWl4aW5zXHJcbiAgICBpZiAobWl4aW5zKSB7XHJcbiAgICAgICAgYXBwbHlNaXhpbnMoaW5zdGFuY2UsIG1peGlucywgZGVmZXJyZWREYXRhLCBkZWZlcnJlZFdhdGNoLCBkZWZlcnJlZFByb3ZpZGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgICAgICBpZiAocHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgaW5pdGlhbGl6YXRpb24gb3JkZXIgKHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBWdWUgMik6XHJcbiAgICAvLyAtIHByb3BzIChhbHJlYWR5IGRvbmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uKVxyXG4gICAgLy8gLSBpbmplY3RcclxuICAgIC8vIC0gbWV0aG9kc1xyXG4gICAgLy8gLSBkYXRhIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIC8vIC0gY29tcHV0ZWRcclxuICAgIC8vIC0gd2F0Y2ggKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxyXG4gICAgaWYgKGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShpbmplY3RPcHRpb25zKSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGluamVjdE9wdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdChrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gaW5qZWN0T3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdChvcHQuZnJvbSB8fCBrZXksIG9wdC5kZWZhdWx0LCB0cnVlIC8qIHRyZWF0IGRlZmF1bHQgZnVuY3Rpb24gYXMgZmFjdG9yeSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdChvcHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChtZXRob2RzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gZGV2IG1vZGUsIHdlIHVzZSB0aGUgYGNyZWF0ZVJlbmRlckNvbnRleHRgIGZ1bmN0aW9uIHRvIGRlZmluZSBtZXRob2RzIHRvIHRoZSBwcm94eSB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhvc2UgYXJlIHJlYWQtb25seSBidXQgcmVjb25maWd1cmFibGUsIHNvIGl0IG5lZWRzIHRvIGJlIHJlZGVmaW5lZCBoZXJlXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWFzTWl4aW4pIHtcclxuICAgICAgICBpZiAoZGVmZXJyZWREYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBkZWZlcnJlZERhdGEuZm9yRWFjaChkYXRhRm4gPT4gcmVzb2x2ZURhdGEoaW5zdGFuY2UsIGRhdGFGbiwgcHVibGljVGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBkYXRhT3B0aW9ucyBpcyBub3QgZnVsbHkgdHlwZSBzYWZlXHJcbiAgICAgICAgICAgIHJlc29sdmVEYXRhKGluc3RhbmNlLCBkYXRhT3B0aW9ucywgcHVibGljVGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc3QgcmF3RGF0YSA9IHRvUmF3KGluc3RhbmNlLmRhdGEpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIGV4cG9zZSBkYXRhIG9uIGN0eCBkdXJpbmcgZGV2XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnJCcgJiYga2V5WzBdICE9PSAnXycpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHJhd0RhdGFba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkYXRhT3B0aW9ucykge1xyXG4gICAgICAgIGRlZmVycmVkRGF0YS5wdXNoKGRhdGFPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KVxyXG4gICAgICAgICAgICAgICAgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ2V0ID09PSBOT09QKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgICAgICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xyXG4gICAgICAgICAgICAgICAgZ2V0LFxyXG4gICAgICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGMudmFsdWUgPSB2KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICBkZWZlcnJlZFdhdGNoLnB1c2god2F0Y2hPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGlmICghYXNNaXhpbiAmJiBkZWZlcnJlZFdhdGNoLmxlbmd0aCkge1xyXG4gICAgICAgIGRlZmVycmVkV2F0Y2guZm9yRWFjaCh3YXRjaE9wdGlvbnMgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XHJcbiAgICAgICAgZGVmZXJyZWRQcm92aWRlLnB1c2gocHJvdmlkZU9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhc01peGluICYmIGRlZmVycmVkUHJvdmlkZS5sZW5ndGgpIHtcclxuICAgICAgICBkZWZlcnJlZFByb3ZpZGUuZm9yRWFjaChwcm92aWRlT3B0aW9ucyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucylcclxuICAgICAgICAgICAgICAgID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiBwcm92aWRlT3B0aW9ucztcclxuICAgICAgICAgICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gYXNzZXQgb3B0aW9ucy5cclxuICAgIC8vIFRvIHJlZHVjZSBtZW1vcnkgdXNhZ2UsIG9ubHkgY29tcG9uZW50cyB3aXRoIG1peGlucyBvciBleHRlbmRzIHdpbGwgaGF2ZVxyXG4gICAgLy8gcmVzb2x2ZWQgYXNzZXQgcmVnaXN0cnkgYXR0YWNoZWQgdG8gaW5zdGFuY2UuXHJcbiAgICBpZiAoYXNNaXhpbikge1xyXG4gICAgICAgIGlmIChjb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChpbnN0YW5jZS5jb21wb25lbnRzIHx8XHJcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UuY29tcG9uZW50cyA9IGV4dGVuZCh7fSwgaW5zdGFuY2UudHlwZS5jb21wb25lbnRzKSksIGNvbXBvbmVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgICBleHRlbmQoaW5zdGFuY2UuZGlyZWN0aXZlcyB8fFxyXG4gICAgICAgICAgICAgICAgKGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBleHRlbmQoe30sIGluc3RhbmNlLnR5cGUuZGlyZWN0aXZlcykpLCBkaXJlY3RpdmVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBsaWZlY3ljbGUgb3B0aW9uc1xyXG4gICAgaWYgKCFhc01peGluKSB7XHJcbiAgICAgICAgY2FsbFN5bmNIb29rKCdjcmVhdGVkJywgXCJjXCIgLyogQ1JFQVRFRCAqLywgb3B0aW9ucywgaW5zdGFuY2UsIGdsb2JhbE1peGlucyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmVmb3JlTW91bnQpIHtcclxuICAgICAgICBvbkJlZm9yZU1vdW50KGJlZm9yZU1vdW50LmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vdW50ZWQpIHtcclxuICAgICAgICBvbk1vdW50ZWQobW91bnRlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmIChiZWZvcmVVcGRhdGUpIHtcclxuICAgICAgICBvbkJlZm9yZVVwZGF0ZShiZWZvcmVVcGRhdGUuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodXBkYXRlZCkge1xyXG4gICAgICAgIG9uVXBkYXRlZCh1cGRhdGVkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFjdGl2YXRlZCkge1xyXG4gICAgICAgIG9uQWN0aXZhdGVkKGFjdGl2YXRlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmIChkZWFjdGl2YXRlZCkge1xyXG4gICAgICAgIG9uRGVhY3RpdmF0ZWQoZGVhY3RpdmF0ZWQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyb3JDYXB0dXJlZCkge1xyXG4gICAgICAgIG9uRXJyb3JDYXB0dXJlZChlcnJvckNhcHR1cmVkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlbmRlclRyYWNrZWQpIHtcclxuICAgICAgICBvblJlbmRlclRyYWNrZWQocmVuZGVyVHJhY2tlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmIChyZW5kZXJUcmlnZ2VyZWQpIHtcclxuICAgICAgICBvblJlbmRlclRyaWdnZXJlZChyZW5kZXJUcmlnZ2VyZWQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGJlZm9yZURlc3Ryb3kpIHtcclxuICAgICAgICB3YXJuKGBcXGBiZWZvcmVEZXN0cm95XFxgIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgYmVmb3JlVW5tb3VudFxcYC5gKTtcclxuICAgIH1cclxuICAgIGlmIChiZWZvcmVVbm1vdW50KSB7XHJcbiAgICAgICAgb25CZWZvcmVVbm1vdW50KGJlZm9yZVVubW91bnQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGRlc3Ryb3llZCkge1xyXG4gICAgICAgIHdhcm4oYFxcYGRlc3Ryb3llZFxcYCBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHVubW91bnRlZFxcYC5gKTtcclxuICAgIH1cclxuICAgIGlmICh1bm1vdW50ZWQpIHtcclxuICAgICAgICBvblVubW91bnRlZCh1bm1vdW50ZWQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShleHBvc2UpKSB7XHJcbiAgICAgICAgaWYgKCFhc01peGluKSB7XHJcbiAgICAgICAgICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHByb3h5UmVmcyh7fSkpO1xyXG4gICAgICAgICAgICAgICAgZXhwb3NlLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBleHBvc2VkW2tleV0gPSB0b1JlZihwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSBFTVBUWV9PQko7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSBcXGBleHBvc2VcXGAgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiB1c2VkIGluIG1peGlucy5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbFN5bmNIb29rKG5hbWUsIHR5cGUsIG9wdGlvbnMsIGluc3RhbmNlLCBnbG9iYWxNaXhpbnMpIHtcclxuICAgIGNhbGxIb29rRnJvbU1peGlucyhuYW1lLCB0eXBlLCBnbG9iYWxNaXhpbnMsIGluc3RhbmNlKTtcclxuICAgIGNvbnN0IHsgZXh0ZW5kczogYmFzZSwgbWl4aW5zIH0gPSBvcHRpb25zO1xyXG4gICAgaWYgKGJhc2UpIHtcclxuICAgICAgICBjYWxsSG9va0Zyb21FeHRlbmRzKG5hbWUsIHR5cGUsIGJhc2UsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmIChtaXhpbnMpIHtcclxuICAgICAgICBjYWxsSG9va0Zyb21NaXhpbnMobmFtZSwgdHlwZSwgbWl4aW5zLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZWxmSG9vayA9IG9wdGlvbnNbbmFtZV07XHJcbiAgICBpZiAoc2VsZkhvb2spIHtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhzZWxmSG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rRnJvbUV4dGVuZHMobmFtZSwgdHlwZSwgYmFzZSwgaW5zdGFuY2UpIHtcclxuICAgIGlmIChiYXNlLmV4dGVuZHMpIHtcclxuICAgICAgICBjYWxsSG9va0Zyb21FeHRlbmRzKG5hbWUsIHR5cGUsIGJhc2UuZXh0ZW5kcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmFzZUhvb2sgPSBiYXNlW25hbWVdO1xyXG4gICAgaWYgKGJhc2VIb29rKSB7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoYmFzZUhvb2suYmluZChpbnN0YW5jZS5wcm94eSksIGluc3RhbmNlLCB0eXBlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSG9va0Zyb21NaXhpbnMobmFtZSwgdHlwZSwgbWl4aW5zLCBpbnN0YW5jZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGFpbmVkTWl4aW5zID0gbWl4aW5zW2ldLm1peGlucztcclxuICAgICAgICBpZiAoY2hhaW5lZE1peGlucykge1xyXG4gICAgICAgICAgICBjYWxsSG9va0Zyb21NaXhpbnMobmFtZSwgdHlwZSwgY2hhaW5lZE1peGlucywgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmbiA9IG1peGluc1tpXVtuYW1lXTtcclxuICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4uYmluZChpbnN0YW5jZS5wcm94eSksIGluc3RhbmNlLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlNaXhpbnMoaW5zdGFuY2UsIG1peGlucywgZGVmZXJyZWREYXRhLCBkZWZlcnJlZFdhdGNoLCBkZWZlcnJlZFByb3ZpZGUpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlLCBtaXhpbnNbaV0sIGRlZmVycmVkRGF0YSwgZGVmZXJyZWRXYXRjaCwgZGVmZXJyZWRQcm92aWRlLCB0cnVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlRGF0YShpbnN0YW5jZSwgZGF0YUZuLCBwdWJsaWNUaGlzKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uKGRhdGFGbikpIHtcclxuICAgICAgICB3YXJuKGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBgICtcclxuICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IGRhdGFGbi5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1Byb21pc2UoZGF0YSkpIHtcclxuICAgICAgICB3YXJuKGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgYCArXHJcbiAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xyXG4gICAgICAgICAgICBgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGluc3RhbmNlLmRhdGEgPT09IEVNUFRZX09CSikge1xyXG4gICAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGV4aXN0aW5nIGRhdGE6IHRoaXMgaXMgYSBtaXhpbiBvciBleHRlbmRzLlxyXG4gICAgICAgIGV4dGVuZChpbnN0YW5jZS5kYXRhLCBkYXRhKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcclxuICAgIGNvbnN0IGdldHRlciA9IGtleS5pbmNsdWRlcygnLicpXHJcbiAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSlcclxuICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcclxuICAgIGlmIChpc1N0cmluZyhyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XHJcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCByYXcuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgICAgICByYXcuZm9yRWFjaChyID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKVxyXG4gICAgICAgICAgICAgICAgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGN0eFtyYXcuaGFuZGxlcl07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xyXG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGxldCBjdXIgPSBjdHg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcclxuICAgICAgICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cjtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHJhdyA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBjb25zdCB7IF9fbWVyZ2VkLCBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSByYXc7XHJcbiAgICBpZiAoX19tZXJnZWQpXHJcbiAgICAgICAgcmV0dXJuIF9fbWVyZ2VkO1xyXG4gICAgY29uc3QgZ2xvYmFsTWl4aW5zID0gaW5zdGFuY2UuYXBwQ29udGV4dC5taXhpbnM7XHJcbiAgICBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpXHJcbiAgICAgICAgcmV0dXJuIHJhdztcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcclxuICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKG0gPT4gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIG0sIGluc3RhbmNlKSk7XHJcbiAgICBtZXJnZU9wdGlvbnMob3B0aW9ucywgcmF3LCBpbnN0YW5jZSk7XHJcbiAgICByZXR1cm4gKHJhdy5fX21lcmdlZCA9IG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHN0cmF0cyA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcclxuICAgIGV4dGVuZHNPcHRpb25zICYmIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIGluc3RhbmNlKTtcclxuICAgIG1peGlucyAmJlxyXG4gICAgICAgIG1peGlucy5mb3JFYWNoKChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIGluc3RhbmNlKSk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKHN0cmF0cyAmJiBoYXNPd24oc3RyYXRzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHRvW2tleV0gPSBzdHJhdHNba2V5XSh0b1trZXldLCBmcm9tW2tleV0sIGluc3RhbmNlLnByb3h5LCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqICMyNDM3IEluIFZ1ZSAzLCBmdW5jdGlvbmFsIGNvbXBvbmVudHMgZG8gbm90IGhhdmUgYSBwdWJsaWMgaW5zdGFuY2UgcHJveHkgYnV0XHJcbiAqIHRoZXkgZXhpc3QgaW4gdGhlIGludGVybmFsIHBhcmVudCBjaGFpbi4gRm9yIGNvZGUgdGhhdCByZWxpZXMgb24gdHJhdmVyc2luZ1xyXG4gKiBwdWJsaWMgJHBhcmVudCBjaGFpbnMsIHNraXAgZnVuY3Rpb25hbCBvbmVzIGFuZCBnbyB0byB0aGUgcGFyZW50IGluc3RlYWQuXHJcbiAqL1xyXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XHJcbiAgICBpZiAoIWkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcclxuICAgICAgICByZXR1cm4gaS5leHBvc2VkID8gaS5leHBvc2VkIDogaS5wcm94eTtcclxuICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XHJcbn07XHJcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwge1xyXG4gICAgJDogaSA9PiBpLFxyXG4gICAgJGVsOiBpID0+IGkudm5vZGUuZWwsXHJcbiAgICAkZGF0YTogaSA9PiBpLmRhdGEsXHJcbiAgICAkcHJvcHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMpLFxyXG4gICAgJGF0dHJzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzKSxcclxuICAgICRzbG90czogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyksXHJcbiAgICAkcmVmczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMpLFxyXG4gICAgJHBhcmVudDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXHJcbiAgICAkcm9vdDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxyXG4gICAgJGVtaXQ6IGkgPT4gaS5lbWl0LFxyXG4gICAgJG9wdGlvbnM6IGkgPT4gKF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSksXHJcbiAgICAkZm9yY2VVcGRhdGU6IGkgPT4gKCkgPT4gcXVldWVKb2IoaS51cGRhdGUpLFxyXG4gICAgJG5leHRUaWNrOiBpID0+IG5leHRUaWNrLmJpbmQoaS5wcm94eSksXHJcbiAgICAkd2F0Y2g6IGkgPT4gKF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QKVxyXG59KTtcclxuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gbGV0IEB2dWUvcmVhY3Rpdml0eSBrbm93IGl0IHNob3VsZCBuZXZlciBvYnNlcnZlIFZ1ZSBwdWJsaWMgaW5zdGFuY2VzLlxyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X3NraXBcIiAvKiBTS0lQICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgZm9ybWF0dGVycyB0byBrbm93IHRoYXQgdGhpcyBpcyBhIFZ1ZSBpbnN0YW5jZVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5ID09PSAnX19pc1Z1ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRhdGEgLyBwcm9wcyAvIGN0eFxyXG4gICAgICAgIC8vIFRoaXMgZ2V0dGVyIGdldHMgY2FsbGVkIGZvciBldmVyeSBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIHJlbmRlciBjb250ZXh0XHJcbiAgICAgICAgLy8gZHVyaW5nIHJlbmRlciBhbmQgaXMgYSBtYWpvciBob3RzcG90LiBUaGUgbW9zdCBleHBlbnNpdmUgcGFydCBvZiB0aGlzXHJcbiAgICAgICAgLy8gaXMgdGhlIG11bHRpcGxlIGhhc093bigpIGNhbGxzLiBJdCdzIG11Y2ggZmFzdGVyIHRvIGRvIGEgc2ltcGxlIHByb3BlcnR5XHJcbiAgICAgICAgLy8gYWNjZXNzIG9uIGEgcGxhaW4gb2JqZWN0LCBzbyB3ZSB1c2UgYW4gYWNjZXNzQ2FjaGUgb2JqZWN0ICh3aXRoIG51bGxcclxuICAgICAgICAvLyBwcm90b3R5cGUpIHRvIG1lbW9pemUgd2hhdCBhY2Nlc3MgdHlwZSBhIGtleSBjb3JyZXNwb25kcyB0by5cclxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xyXG4gICAgICAgIGlmIChrZXlbMF0gIT09ICckJykge1xyXG4gICAgICAgICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIFNFVFVQICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBEQVRBICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBDT05URVhUICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIFBST1BTICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0OiBqdXN0IGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBTRVRVUCAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBEQVRBICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgLy8gb25seSBjYWNoZSBvdGhlciBwcm9wZXJ0aWVzIHdoZW4gaW5zdGFuY2UgaGFzIGRlY2xhcmVkICh0aHVzIHN0YWJsZSlcclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiZcclxuICAgICAgICAgICAgICAgIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIFBST1BTICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogQ09OVEVYVCAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCAhaXNJbkJlZm9yZUNyZWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogT1RIRVIgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xyXG4gICAgICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XHJcbiAgICAgICAgLy8gcHVibGljICR4eHggcHJvcGVydGllc1xyXG4gICAgICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRhdHRycycpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxyXG4gICAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiZcclxuICAgICAgICAgICAgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3NzTW9kdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZXIgbWF5IHNldCBjdXN0b20gcHJvcGVydGllcyB0byBgdGhpc2AgdGhhdCBzdGFydCB3aXRoIGAkYFxyXG4gICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgKChnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcyksXHJcbiAgICAgICAgICAgIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsUHJvcGVydGllc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmXHJcbiAgICAgICAgICAgICghaXNTdHJpbmcoa2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcclxuICAgICAgICAgICAgICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAga2V5LmluZGV4T2YoJ19fdicpICE9PSAwKSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmXHJcbiAgICAgICAgICAgICAgICAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpICYmXHJcbiAgICAgICAgICAgICAgICBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBgICtcclxuICAgICAgICAgICAgICAgICAgICBgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgaGFzKHsgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfSB9LCBrZXkpIHtcclxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xyXG4gICAgICAgIHJldHVybiAoYWNjZXNzQ2FjaGVba2V5XSAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHx8XHJcbiAgICAgICAgICAgICgobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICBoYXNPd24oY3R4LCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKTtcclxuICAgIH1cclxufTtcclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UpIHtcclxuICAgIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBgICtcclxuICAgICAgICAgICAgYFRoZSBrZXlzIHdpbGwgYmUgZW1wdHkgaW4gcHJvZHVjdGlvbiBtb2RlIHRvIGF2b2lkIHBlcmZvcm1hbmNlIG92ZXJoZWFkLmApO1xyXG4gICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcclxuICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdW5zY29wYWJsZXMgd2hlbiB1c2luZyBgd2l0aGAgYmxvY2tcclxuICAgICAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcclxuICAgIH0sXHJcbiAgICBoYXMoXywga2V5KSB7XHJcbiAgICAgICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSAnXycgJiYgIWlzR2xvYmFsbHlXaGl0ZWxpc3RlZChrZXkpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcclxuICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhcztcclxuICAgIH1cclxufSk7XHJcbi8vIEluIGRldiBtb2RlLCB0aGUgcHJveHkgdGFyZ2V0IGV4cG9zZXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBzZWVuIG9uIGB0aGlzYFxyXG4vLyBmb3IgZWFzaWVyIGNvbnNvbGUgaW5zcGVjdGlvbi4gSW4gcHJvZCBtb2RlIGl0IHdpbGwgYmUgYW4gZW1wdHkgb2JqZWN0IHNvXHJcbi8vIHRoZXNlIHByb3BlcnRpZXMgZGVmaW5pdGlvbnMgY2FuIGJlIHNraXBwZWQuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xyXG4gICAgLy8gZXhwb3NlIGludGVybmFsIGluc3RhbmNlIGZvciBwcm94eSBoYW5kbGVyc1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2VcclxuICAgIH0pO1xyXG4gICAgLy8gZXhwb3NlIHB1YmxpYyBwcm9wZXJ0aWVzXHJcbiAgICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcclxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxyXG4gICAgICAgICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgLy8gZXhwb3NlIGdsb2JhbCBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCB7IGdsb2JhbFByb3BlcnRpZXMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xyXG4gICAgT2JqZWN0LmtleXMoZ2xvYmFsUHJvcGVydGllcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IGdsb2JhbFByb3BlcnRpZXNba2V5XSxcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxyXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcclxuICAgIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnIHx8IGtleVswXSA9PT0gJ18nKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XHJcbmxldCB1aWQkMSA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcclxuICAgIC8vIGluaGVyaXQgcGFyZW50IGFwcCBjb250ZXh0IC0gb3IgLSBpZiByb290LCBhZG9wdCBmcm9tIHJvb3Qgdm5vZGVcclxuICAgIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcclxuICAgICAgICB1aWQ6IHVpZCQxKyssXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgYXBwQ29udGV4dCxcclxuICAgICAgICByb290OiBudWxsLFxyXG4gICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgc3ViVHJlZTogbnVsbCxcclxuICAgICAgICB1cGRhdGU6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyOiBudWxsLFxyXG4gICAgICAgIHByb3h5OiBudWxsLFxyXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXHJcbiAgICAgICAgd2l0aFByb3h5OiBudWxsLFxyXG4gICAgICAgIGVmZmVjdHM6IG51bGwsXHJcbiAgICAgICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXHJcbiAgICAgICAgYWNjZXNzQ2FjaGU6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyQ2FjaGU6IFtdLFxyXG4gICAgICAgIC8vIGxvY2FsIHJlc292bGVkIGFzc2V0c1xyXG4gICAgICAgIGNvbXBvbmVudHM6IG51bGwsXHJcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcclxuICAgICAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xyXG4gICAgICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIC8vIGVtaXRcclxuICAgICAgICBlbWl0OiBudWxsLFxyXG4gICAgICAgIGVtaXR0ZWQ6IG51bGwsXHJcbiAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICBjdHg6IEVNUFRZX09CSixcclxuICAgICAgICBkYXRhOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcHJvcHM6IEVNUFRZX09CSixcclxuICAgICAgICBhdHRyczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNsb3RzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcmVmczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcclxuICAgICAgICBzZXR1cENvbnRleHQ6IG51bGwsXHJcbiAgICAgICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxyXG4gICAgICAgIHN1c3BlbnNlLFxyXG4gICAgICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcclxuICAgICAgICBhc3luY0RlcDogbnVsbCxcclxuICAgICAgICBhc3luY1Jlc29sdmVkOiBmYWxzZSxcclxuICAgICAgICAvLyBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGJjOiBudWxsLFxyXG4gICAgICAgIGM6IG51bGwsXHJcbiAgICAgICAgYm06IG51bGwsXHJcbiAgICAgICAgbTogbnVsbCxcclxuICAgICAgICBidTogbnVsbCxcclxuICAgICAgICB1OiBudWxsLFxyXG4gICAgICAgIHVtOiBudWxsLFxyXG4gICAgICAgIGJ1bTogbnVsbCxcclxuICAgICAgICBkYTogbnVsbCxcclxuICAgICAgICBhOiBudWxsLFxyXG4gICAgICAgIHJ0ZzogbnVsbCxcclxuICAgICAgICBydGM6IG51bGwsXHJcbiAgICAgICAgZWM6IG51bGxcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcclxuICAgIGluc3RhbmNlLmVtaXQgPSBlbWl0LmJpbmQobnVsbCwgaW5zdGFuY2UpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG59XHJcbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG5jb25zdCBnZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcclxuICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG59O1xyXG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb25maWcpIHtcclxuICAgIGNvbnN0IGFwcElzTmF0aXZlVGFnID0gY29uZmlnLmlzTmF0aXZlVGFnIHx8IE5PO1xyXG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi87XHJcbn1cclxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XHJcbiAgICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XHJcbiAgICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XHJcbiAgICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bFxyXG4gICAgICAgID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuICAgIHJldHVybiBzZXR1cFJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMC4gY3JlYXRlIHJlbmRlciBwcm94eSBwcm9wZXJ0eSBhY2Nlc3MgY2FjaGVcclxuICAgIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIC8vIDEuIGNyZWF0ZSBwdWJsaWMgaW5zdGFuY2UgLyByZW5kZXIgcHJveHlcclxuICAgIC8vIGFsc28gbWFyayBpdCByYXcgc28gaXQncyBuZXZlciBvYnNlcnZlZFxyXG4gICAgaW5zdGFuY2UucHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8vIDIuIGNhbGwgc2V0dXAoKVxyXG4gICAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xyXG4gICAgaWYgKHNldHVwKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gKGluc3RhbmNlLnNldHVwQ29udGV4dCA9XHJcbiAgICAgICAgICAgIHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNldHVwLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLywgWyhwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcywgc2V0dXBDb250ZXh0XSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGlzUHJvbWlzZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzU1NSKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHByb21pc2Ugc28gc2VydmVyLXJlbmRlcmVyIGNhbiB3YWl0IG9uIGl0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHQudGhlbigocmVzb2x2ZWRSZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyBzZXR1cCByZXR1cm5lZCBQcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBoZXJlIGFuZCB3YWl0IGZvciByZS1lbnRyeS5cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGFuIGlubGluZSByZW5kZXIgZnVuY3Rpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSBgICtcclxuICAgICAgICAgICAgICAgIGByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYmluZGluZ3MuXHJcbiAgICAgICAgLy8gYXNzdW1pbmcgYSByZW5kZXIgZnVuY3Rpb24gY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBpcyBwcmVzZW50LlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzZXR1cFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YCk7XHJcbiAgICB9XHJcbiAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSk7XHJcbn1cclxubGV0IGNvbXBpbGU7XHJcbi8vIGRldiBvbmx5XHJcbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcclxuLyoqXHJcbiAqIEZvciBydW50aW1lLWRvbSB0byByZWdpc3RlciB0aGUgY29tcGlsZXIuXHJcbiAqIE5vdGUgdGhlIGV4cG9ydGVkIG1ldGhvZCB1c2VzIGFueSB0byBhdm9pZCBkLnRzIHJlbHlpbmcgb24gdGhlIGNvbXBpbGVyIHR5cGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcclxuICAgIGNvbXBpbGUgPSBfY29tcGlsZTtcclxufVxyXG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXHJcbiAgICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xyXG4gICAgICAgIC8vIGNvdWxkIGJlIHNldCBmcm9tIHNldHVwKClcclxuICAgICAgICBpZiAoY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKENvbXBvbmVudC50ZW1wbGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50OiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzOiBDb21wb25lbnQuZGVsaW1pdGVyc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSAoQ29tcG9uZW50LnJlbmRlciB8fCBOT09QKTtcclxuICAgICAgICAvLyBmb3IgcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9ja3MsIHRoZSByZW5kZXJcclxuICAgICAgICAvLyBwcm94eSB1c2VkIG5lZWRzIGEgZGlmZmVyZW50IGBoYXNgIGhhbmRsZXIgd2hpY2ggaXMgbW9yZSBwZXJmb3JtYW50IGFuZFxyXG4gICAgICAgIC8vIGFsc28gb25seSBhbGxvd3MgYSB3aGl0ZWxpc3Qgb2YgZ2xvYmFscyB0byBmYWxsdGhyb3VnaC5cclxuICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9yYykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS53aXRoUHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN1cHBvcnQgZm9yIDIueCBvcHRpb25zXHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UsIENvbXBvbmVudCk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyB3YXJuIG1pc3NpbmcgdGVtcGxhdGUvcmVuZGVyXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgYCArXHJcbiAgICAgICAgICAgICAgICBgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgK1xyXG4gICAgICAgICAgICAgICAgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYFxyXG4gICAgICAgICAgICAgICAgICAgICkgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBhdHRySGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gICAgfSxcclxuICAgIHNldDogKCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IHtcclxuICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGV4cG9zZSA9IGV4cG9zZWQgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHByb3h5UmVmcyhleHBvc2VkKTtcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgLy8gV2UgdXNlIGdldHRlcnMgaW4gZGV2IGluIGNhc2UgbGlicyBsaWtlIHRlc3QtdXRpbHMgb3ZlcndyaXRlIGluc3RhbmNlXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgICAgIGdldCBwcm9wcygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0ckhhbmRsZXJzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IHNsb3RzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5zbG90cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBlbWl0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXR0cnM6IGluc3RhbmNlLmF0dHJzLFxyXG4gICAgICAgICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXHJcbiAgICAgICAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLy8gcmVjb3JkIGVmZmVjdHMgY3JlYXRlZCBkdXJpbmcgYSBjb21wb25lbnQncyBzZXR1cCgpIHNvIHRoYXQgdGhleSBjYW4gYmVcclxuLy8gc3RvcHBlZCB3aGVuIHRoZSBjb21wb25lbnQgdW5tb3VudHNcclxuZnVuY3Rpb24gcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChlZmZlY3QsIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAoaW5zdGFuY2UuZWZmZWN0cyB8fCAoaW5zdGFuY2UuZWZmZWN0cyA9IFtdKSkucHVzaChlZmZlY3QpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XHJcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KVxyXG4gICAgICAgID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lXHJcbiAgICAgICAgOiBDb21wb25lbnQubmFtZTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcclxuICAgIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSBuYW1lIGJhc2VkIG9uIHJldmVyc2UgcmVzb2x1dGlvblxyXG4gICAgICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbmFtZSA9XHJcbiAgICAgICAgICAgIGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmNvbXBvbmVudHMgfHxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHMpIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcclxufVxyXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgJ19fdmNjT3B0cycgaW4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XHJcbiAgICBjb25zdCBjID0gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMpO1xyXG4gICAgcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChjLmVmZmVjdCk7XHJcbiAgICByZXR1cm4gYztcclxufVxuXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBkZWZpbmVQcm9wcygpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYCArXHJcbiAgICAgICAgICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXHJcbiAgICAgICAgICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZUVtaXQoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgZGVmaW5lRW1pdCgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYCArXHJcbiAgICAgICAgICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXHJcbiAgICAgICAgICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHVzZUNvbnRleHQoKSB7XHJcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpKSB7XHJcbiAgICAgICAgd2FybihgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xyXG59XG5cbi8vIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgaWYgKGwgPT09IDIpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2bm9kZSB3aXRob3V0IHByb3BzXHJcbiAgICAgICAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHMgd2l0aG91dCBjaGlsZHJlblxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG9taXQgcHJvcHNcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGwgPiAzKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzc3JDb250ZXh0YCA6IGBgKTtcclxuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcclxuICAgIHtcclxuICAgICAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XHJcbiAgICAgICAgaWYgKCFjdHgpIHtcclxuICAgICAgICAgICAgd2FybihgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCBgICtcclxuICAgICAgICAgICAgICAgIGB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3R4O1xyXG4gICAgfVxyXG59O1xuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMzYmE3NzYnIH07XHJcbiAgICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojMGIxYmM5JyB9O1xyXG4gICAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6I2I2MmUyNCcgfTtcclxuICAgIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojOWQyODhjJyB9O1xyXG4gICAgLy8gY3VzdG9tIGZvcm1hdHRlciBmb3IgQ2hyb21lXHJcbiAgICAvLyBodHRwczovL3d3dy5tYXR0emV1bmVydC5jb20vMjAxNi8wMi8xOS9jdXN0b20tY2hyb21lLWRldnRvb2xzLW9iamVjdC1mb3JtYXR0ZXJzLmh0bWxcclxuICAgIGNvbnN0IGZvcm1hdHRlciA9IHtcclxuICAgICAgICBoZWFkZXIob2JqKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gYWxzbyBmb3JtYXQgQ29tcG9uZW50UHVibGljSW5zdGFuY2UgJiBjdHguc2xvdHMvYXR0cnMgaW4gc2V0dXBcclxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZihvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsICdSZWFjdGl2ZSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsICdSZWFkb25seSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgICc+J1xyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0JvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5KG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3Byb3BzJywgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnc2V0dXAnLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnZGF0YScsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdjb21wdXRlZCcpO1xyXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdjb21wdXRlZCcsIGNvbXB1dGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdpbmplY3QnKTtcclxuICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnaW5qZWN0ZWQnLCBpbmplY3RlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBibG9ja3MucHVzaChbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyAnO29wYWNpdHk6MC42NidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnJCAoaW50ZXJuYWwpOiAnXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsnb2JqZWN0JywgeyBvYmplY3Q6IGluc3RhbmNlIH1dXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xyXG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHt9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHsgc3R5bGU6ICdsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbScgfSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdjb2xvcjojNDc2NTgyJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdwYWRkaW5nLWxlZnQ6MS4yNWVtJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIGtleSArICc6ICddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgbnVtYmVyU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIGtleXdvcmRTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ29iamVjdCcsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRba2V5XSA9IGluc3RhbmNlLmN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcclxuICAgICAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcclxuICAgICAgICBpZiAoKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpKSB8fFxyXG4gICAgICAgICAgICAoaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUobSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcclxuICAgICAgICBpZiAodi5fc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodi5lZmZlY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgUmVmYDtcclxuICAgIH1cclxuICAgIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0pIHtcclxuICAgIGxldCByZXQ7XHJcbiAgICBpZiAoaXNBcnJheShzb3VyY2UpIHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XHJcbiAgICAgICAgICAgIHJldCA9IEFycmF5LmZyb20oc291cmNlLCByZW5kZXJJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gICAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldCA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vKipcclxuICogRm9yIHByZWZpeGluZyBrZXlzIGluIHYtb249XCJvYmpcIiB3aXRoIFwib25cIlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmopIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIHdhcm4oYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0W3RvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vKipcclxuICogQ29tcGlsZXIgcnVudGltZSBoZWxwZXIgZm9yIGNyZWF0aW5nIGR5bmFtaWMgc2xvdHMgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XHJcbiAgICAgICAgLy8gYXJyYXkgb2YgZHluYW1pYyBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIiAjWy4uLl0+XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbmRpdGlvbmFsIHNpbmdsZSBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1pZj1cIi4uLlwiICNmb28+XHJcbiAgICAgICAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzbG90cztcclxufVxuXG4vLyBDb3JlIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgdmVyc2lvbiA9IFwiMy4wLjdcIjtcclxuLyoqXHJcbiAqIFNTUiB1dGlscyBmb3IgXFxAdnVlL3NlcnZlci1yZW5kZXJlci4gT25seSBleHBvc2VkIGluIGNqcyBidWlsZHMuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3Qgc3NyVXRpbHMgPSAobnVsbCk7XG5cbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBDb21tZW50LCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0LCBkZWZpbmVQcm9wcywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBoLCBoYW5kbGVFcnJvciwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VDb250ZXh0LCB1c2VTU1JDb250ZXh0LCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2l0aEN0eCwgd2l0aERpcmVjdGl2ZXMsIHdpdGhTY29wZUlkIH07XG4iLCJpbXBvcnQgeyBjYW1lbGl6ZSwgd2FybiwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGdldEN1cnJlbnRJbnN0YW5jZSwgb25Nb3VudGVkLCB3YXRjaEVmZmVjdCwgb25VcGRhdGVkLCBGcmFnbWVudCwgaCwgQmFzZVRyYW5zaXRpb24sIHVzZVRyYW5zaXRpb25TdGF0ZSwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBjcmVhdGVWTm9kZSwgY3JlYXRlUmVuZGVyZXIsIGlzUnVudGltZU9ubHksIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzQXJyYXksIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgaXNGdW5jdGlvbiwgRU1QVFlfT0JKLCBleHRlbmQsIGlzT2JqZWN0LCB0b051bWJlciwgaW52b2tlQXJyYXlGbnMsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGlzSFRNTFRhZywgaXNTVkdUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuY29uc3QgZG9jID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGwpO1xyXG5sZXQgdGVtcENvbnRhaW5lcjtcclxubGV0IHRlbXBTVkdDb250YWluZXI7XHJcbmNvbnN0IG5vZGVPcHMgPSB7XHJcbiAgICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBjaGlsZCA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIGlzU1ZHLCBpcykgPT4gaXNTVkdcclxuICAgICAgICA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZylcclxuICAgICAgICA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgaXMgPyB7IGlzIH0gOiB1bmRlZmluZWQpLFxyXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXHJcbiAgICBjcmVhdGVDb21tZW50OiB0ZXh0ID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxyXG4gICAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcclxuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBwYXJlbnROb2RlOiBub2RlID0+IG5vZGUucGFyZW50Tm9kZSxcclxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXHJcbiAgICBxdWVyeVNlbGVjdG9yOiBzZWxlY3RvciA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXHJcbiAgICBzZXRTY29wZUlkKGVsLCBpZCkge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xyXG4gICAgfSxcclxuICAgIGNsb25lTm9kZShlbCkge1xyXG4gICAgICAgIHJldHVybiBlbC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgLy8gX19VTlNBRkVfX1xyXG4gICAgLy8gUmVhc29uOiBpbm5lckhUTUwuXHJcbiAgICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxyXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcpIHtcclxuICAgICAgICBjb25zdCB0ZW1wID0gaXNTVkdcclxuICAgICAgICAgICAgPyB0ZW1wU1ZHQ29udGFpbmVyIHx8XHJcbiAgICAgICAgICAgICAgICAodGVtcFNWR0NvbnRhaW5lciA9IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsICdzdmcnKSlcclxuICAgICAgICAgICAgOiB0ZW1wQ29udGFpbmVyIHx8ICh0ZW1wQ29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcclxuICAgICAgICB0ZW1wLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgY29uc3QgZmlyc3QgPSB0ZW1wLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBmaXJzdDtcclxuICAgICAgICBsZXQgbGFzdCA9IG5vZGU7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgbGFzdCA9IG5vZGU7XHJcbiAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0KG5vZGUsIHBhcmVudCwgYW5jaG9yKTtcclxuICAgICAgICAgICAgbm9kZSA9IHRlbXAuZmlyc3RDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtmaXJzdCwgbGFzdF07XHJcbiAgICB9XHJcbn07XG5cbi8vIGNvbXBpbGVyIHNob3VsZCBub3JtYWxpemUgY2xhc3MgKyA6Y2xhc3MgYmluZGluZ3Mgb24gdGhlIHNhbWUgZWxlbWVudFxyXG4vLyBpbnRvIGEgc2luZ2xlIGJpbmRpbmcgWydzdGF0aWNDbGFzcycsIGR5bmFtaWNdXHJcbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRpcmVjdGx5IHNldHRpbmcgY2xhc3NOYW1lIHNob3VsZCBiZSBmYXN0ZXIgdGhhbiBzZXRBdHRyaWJ1dGUgaW4gdGhlb3J5XHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBlbGVtZW50IGR1cmluZyBhIHRyYW5zaXRpb24sIHRha2UgdGhlIHRlbXBvcmFyeSB0cmFuc2l0aW9uXHJcbiAgICAgICAgLy8gY2xhc3NlcyBpbnRvIGFjY291bnQuXHJcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdnRjO1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZVxyXG4gICAgICAgICAgICAgICAgPyBbdmFsdWUsIC4uLnRyYW5zaXRpb25DbGFzc2VzXVxyXG4gICAgICAgICAgICAgICAgOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHBhdGNoU3R5bGUoZWwsIHByZXYsIG5leHQpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICBpZiAoIW5leHQpIHtcclxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyhuZXh0KSkge1xyXG4gICAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdHlsZS5kaXNwbGF5O1xyXG4gICAgICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHRoYXQgdGhlIGBkaXNwbGF5YCBvZiB0aGUgZWxlbWVudCBpcyBjb250cm9sbGVkIGJ5IGB2LXNob3dgLFxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBhbHdheXMga2VlcCB0aGUgY3VycmVudCBgZGlzcGxheWAgdmFsdWUgcmVnYXJkbGVzcyBvZiB0aGUgYHN0eWxlYCB2YWx1ZSxcclxuICAgICAgICAgICAgLy8gdGh1cyBoYW5kaW5nIG92ZXIgY29udHJvbCB0byBgdi1zaG93YC5cclxuICAgICAgICAgICAgaWYgKCdfdm9kJyBpbiBlbCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2ICYmICFpc1N0cmluZyhwcmV2KSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcclxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIHZhbC5mb3JFYWNoKHYgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJy0tJykpIHtcclxuICAgICAgICAgICAgLy8gY3VzdG9tIHByb3BlcnR5IGRlZmluaXRpb25cclxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIC8vICFpbXBvcnRhbnRcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShwcmVmaXhlZCksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xyXG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlLCByYXdOYW1lKSB7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcclxuICAgIGlmIChuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lIGluIHN0eWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWUpO1xyXG4gICAgfVxyXG4gICAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XHJcbiAgICAgICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhd05hbWU7XHJcbn1cblxuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcclxuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xyXG4gICAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBub3RlIHdlIGFyZSBvbmx5IGNoZWNraW5nIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IGRvbid0IGhhdmUgYVxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZG9tIHByb3Agb2YgdGhlIHNhbWUgbmFtZSBoZXJlLlxyXG4gICAgICAgIGNvbnN0IGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSk7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGlzQm9vbGVhbiAmJiB2YWx1ZSA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNCb29sZWFuID8gJycgOiB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIF9fVU5TQUZFX19cclxuLy8gZnVuY3Rpb25zLiBUaGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3IgdXNpbmcgdGhlbSB3aXRoIG9ubHkgdHJ1c3RlZCBjb250ZW50LlxyXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIFxyXG4vLyB0aGUgZm9sbG93aW5nIGFyZ3MgYXJlIHBhc3NlZCBvbmx5IGR1ZSB0byBwb3RlbnRpYWwgaW5uZXJIVE1ML3RleHRDb250ZW50XHJcbi8vIG92ZXJyaWRpbmcgZXhpc3RpbmcgVk5vZGVzLCBpbiB3aGljaCBjYXNlIHRoZSBvbGQgdHJlZSBtdXN0IGJlIHByb3Blcmx5XHJcbi8vIHVubW91bnRlZC5cclxucHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcclxuICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcclxuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxyXG4gICAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQuXHJcbiAgICAgICAgZWwuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgPT09ICcnICYmIHR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxzZWxlY3QgbXVsdGlwbGU+IGNvbXBpbGVzIHRvIHsgbXVsdGlwbGU6ICcnIH1cclxuICAgICAgICAgICAgZWxba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxkaXYgOmlkPVwibnVsbFwiPlxyXG4gICAgICAgICAgICBlbFtrZXldID0gJyc7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGltZyA6d2lkdGg9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSAwO1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBwZXJmb3JtIHZhbHVlIHZhbGlkYXRpb24gYW5kIHRocm93XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7ZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgYHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXHJcbmxldCBfZ2V0Tm93ID0gRGF0ZS5ub3c7XHJcbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXHJcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXHJcbi8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxyXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXHJcbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICBfZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcclxuICAgIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXHJcbiAgICAvLyAod2hpY2ggaXMgZXZhbHVhdGVkIEFGVEVSKSBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxyXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXHJcbiAgICBfZ2V0Tm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XHJcbn1cclxuLy8gVG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mIHJlcGVhdGVkbHkgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSwgd2UgY2FjaGVcclxuLy8gYW5kIHVzZSB0aGUgc2FtZSB0aW1lc3RhbXAgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQgaW4gdGhlIHNhbWUgdGljay5cclxubGV0IGNhY2hlZE5vdyA9IDA7XHJcbmNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICBjYWNoZWROb3cgPSAwO1xyXG59O1xyXG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbihyZXNldCksIChjYWNoZWROb3cgPSBfZ2V0Tm93KCkpKTtcclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XHJcbiAgICAvLyB2ZWkgPSB2dWUgZXZlbnQgaW52b2tlcnNcclxuICAgIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xyXG4gICAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAvLyBwYXRjaFxyXG4gICAgICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcclxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZFxyXG4gICAgICAgICAgICBjb25zdCBpbnZva2VyID0gKGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlXHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcclxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcclxuICAgIGxldCBvcHRpb25zO1xyXG4gICAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpLCBvcHRpb25zXTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xyXG4gICAgICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xyXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcclxuICAgICAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXHJcbiAgICAgICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IGUudGltZVN0YW1wIHx8IF9nZXROb3coKTtcclxuICAgICAgICBpZiAodGltZVN0YW1wID49IGludm9rZXIuYXR0YWNoZWQgLSAxKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLCBpbnN0YW5jZSwgNSAvKiBOQVRJVkVfRVZFTlRfSEFORExFUiAqLywgW2VdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcclxuICAgIHJldHVybiBpbnZva2VyO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcclxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XHJcbiAgICAgICAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmbiA9PiAoZSkgPT4gIWUuX3N0b3BwZWQgJiYgZm4oZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5hdGl2ZU9uUkUgPSAvXm9uW2Etel0vO1xyXG5jb25zdCBmb3JjZVBhdGNoUHJvcCA9IChfLCBrZXkpID0+IGtleSA9PT0gJ3ZhbHVlJztcclxuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAvLyBzcGVjaWFsXHJcbiAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG4gICAgICAgICAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3R5bGUnOlxyXG4gICAgICAgICAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxpbnB1dCB2LW1vZGVsIHR5cGU9XCJjaGVja2JveFwiPiB3aXRoXHJcbiAgICAgICAgICAgICAgICAvLyA6dHJ1ZS12YWx1ZSAmIDpmYWxzZS12YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgZG9tIHByb3BlcnRpZXMgc2luY2Ugbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndHJ1ZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZmFsc2UtdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcclxuICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgIC8vIG1vc3Qga2V5cyBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGUgb24gc3ZnIGVsZW1lbnRzIHRvIHdvcmtcclxuICAgICAgICAvLyAuLi5leGNlcHQgaW5uZXJIVE1MXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yIG5hdGl2ZSBvbmNsaWNrIHdpdGggZnVuY3Rpb24gdmFsdWVzXHJcbiAgICAgICAgaWYgKGtleSBpbiBlbCAmJiBuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gc3BlbGxjaGVjayBhbmQgZHJhZ2dhYmxlIGFyZSBudW1lcmF0ZWQgYXR0cnMsIGhvd2V2ZXIgdGhlaXJcclxuICAgIC8vIGNvcnJlc3BvbmRpbmcgRE9NIHByb3BlcnRpZXMgYXJlIGFjdHVhbGx5IGJvb2xlYW5zIC0gdGhpcyBsZWFkcyB0b1xyXG4gICAgLy8gc2V0dGluZyBpdCB3aXRoIGEgc3RyaW5nIFwiZmFsc2VcIiB2YWx1ZSBsZWFkaW5nIGl0IHRvIGJlIGNvZXJjZWQgdG9cclxuICAgIC8vIGB0cnVlYCwgc28gd2UgbmVlZCB0byBhbHdheXMgdHJlYXQgdGhlbSBhcyBhdHRyaWJ1dGVzLlxyXG4gICAgLy8gTm90ZSB0aGF0IGBjb250ZW50RWRpdGFibGVgIGRvZXNuJ3QgaGF2ZSB0aGlzIHByb2JsZW06IGl0cyBET01cclxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gZW51bWVyYXRlZCBzdHJpbmcgdmFsdWVzLlxyXG4gICAgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snIHx8IGtleSA9PT0gJ2RyYWdnYWJsZScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTc4NywgIzI4NDAgZm9ybSBwcm9wZXJ0eSBvbiBmb3JtIGVsZW1lbnRzIGlzIHJlYWRvbmx5IGFuZCBtdXN0IGJlIHNldCBhc1xyXG4gICAgLy8gYXR0cmlidXRlLlxyXG4gICAgaWYgKGtleSA9PT0gJ2Zvcm0nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzE1MjYgPGlucHV0IGxpc3Q+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKGtleSA9PT0gJ2xpc3QnICYmIGVsLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMjc2NiA8dGV4dGFyZWEgdHlwZT4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAndHlwZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIG5hdGl2ZSBvbmNsaWNrIHdpdGggc3RyaW5nIHZhbHVlLCBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5IGluIGVsO1xyXG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gJyRzdHlsZScpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xyXG4gICAgICAgIGlmICghbW9kdWxlcykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNldFZhcnMgPSAoKSA9PiBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB3YXRjaEVmZmVjdChzZXRWYXJzLCB7IGZsdXNoOiAncG9zdCcgfSkpO1xyXG4gICAgb25VcGRhdGVkKHNldFZhcnMpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcclxuICAgICAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcclxuICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGRyaWxsIGRvd24gSE9DcyB1bnRpbCBpdCdzIGEgbm9uLWNvbXBvbmVudCB2bm9kZVxyXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICB9XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIHZub2RlLmVsKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB2bm9kZS5lbC5zdHlsZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbmNvbnN0IEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBET00gVHJhbnNpdGlvbiBpcyBhIGhpZ2hlci1vcmRlci1jb21wb25lbnQgYmFzZWQgb24gdGhlIHBsYXRmb3JtLWFnbm9zdGljXHJcbi8vIGJhc2UgVHJhbnNpdGlvbiBjb21wb25lbnQsIHdpdGggRE9NLXNwZWNpZmljIGxvZ2ljLlxyXG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XHJcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSAnVHJhbnNpdGlvbic7XHJcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBjc3M6IHtcclxuICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxyXG4gICAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nXHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAoVHJhbnNpdGlvbi5wcm9wcyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBCYXNlVHJhbnNpdGlvbi5wcm9wcywgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpO1xyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XHJcbiAgICBsZXQgeyBuYW1lID0gJ3YnLCB0eXBlLCBjc3MgPSB0cnVlLCBkdXJhdGlvbiwgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCwgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCwgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcywgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCwgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYCB9ID0gcmF3UHJvcHM7XHJcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XHJcbiAgICAgICAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWNzcykge1xyXG4gICAgICAgIHJldHVybiBiYXNlUHJvcHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XHJcbiAgICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcclxuICAgIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xyXG4gICAgY29uc3QgeyBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsIG9uQXBwZWFyID0gb25FbnRlciwgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkIH0gPSBiYXNlUHJvcHM7XHJcbiAgICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUpID0+IHtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBkb25lICYmIGRvbmUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBtYWtlRW50ZXJIb29rID0gKGlzQXBwZWFyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChlbCwgZG9uZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xyXG4gICAgICAgICAgICBob29rICYmIGhvb2soZWwsIHJlc29sdmUpO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcclxuICAgICAgICAgICAgICAgIGlmICghKGhvb2sgJiYgaG9vay5sZW5ndGggPiAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgZW50ZXJEdXJhdGlvbiwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZChiYXNlUHJvcHMsIHtcclxuICAgICAgICBvbkJlZm9yZUVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIG9uQmVmb3JlRW50ZXIgJiYgb25CZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcclxuICAgICAgICAgICAgb25CZWZvcmVBcHBlYXIgJiYgb25CZWZvcmVBcHBlYXIoZWwpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXHJcbiAgICAgICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXHJcbiAgICAgICAgb25MZWF2ZShlbCwgZG9uZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHNvICotbGVhdmUtZnJvbSBjbGFzc2VzIGltbWVkaWF0ZWx5IHRha2UgZWZmZWN0ICgjMjU5MylcclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEob25MZWF2ZSAmJiBvbkxlYXZlLmxlbmd0aCA+IDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG9uTGVhdmUgJiYgb25MZWF2ZShlbCwgcmVzb2x2ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIG9uRW50ZXJDYW5jZWxsZWQgJiYgb25FbnRlckNhbmNlbGxlZChlbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkICYmIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoTGVhdmUoZWwpO1xyXG4gICAgICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkICYmIG9uTGVhdmVDYW5jZWxsZWQoZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBbbiwgbl07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XHJcbiAgICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uKHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXHJcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgTmFOIC0gYCArXHJcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgKGVsLl92dGMgfHxcclxuICAgICAgICAoZWwuX3Z0YyA9IG5ldyBTZXQoKSkpLmFkZChjbHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XHJcbiAgICBpZiAoX3Z0Yykge1xyXG4gICAgICAgIF92dGMuZGVsZXRlKGNscyk7XHJcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcclxuICAgICAgICAgICAgZWwuX3Z0YyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XHJcbiAgICB9KTtcclxufVxyXG5sZXQgZW5kSWQgPSAwO1xyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XHJcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcclxuICAgIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArICdlbmQnO1xyXG4gICAgbGV0IGVuZGVkID0gMDtcclxuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcclxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbiAgICAgICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQgKyAxKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuICAgIGxldCB0eXBlID0gbnVsbDtcclxuICAgIGxldCB0aW1lb3V0ID0gMDtcclxuICAgIGxldCBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxyXG4gICAgICAgIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChzdHlsZXNbVFJBTlNJVElPTiArICdQcm9wZXJ0eSddKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxyXG4vLyBudW1iZXJzIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93blxyXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxyXG4vLyBzeW5jaHJvbm91c2x5IGZvcmNlIGxheW91dCB0byBwdXQgZWxlbWVudHMgaW50byBhIGNlcnRhaW4gc3RhdGVcclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XHJcbiAgICBuYW1lOiAnVHJhbnNpdGlvbkdyb3VwJyxcclxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xyXG4gICAgICAgIHRhZzogU3RyaW5nLFxyXG4gICAgICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbiAgICB9KSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZDaGlsZHJlbjtcclxuICAgICAgICBsZXQgY2hpbGRyZW47XHJcbiAgICAgICAgb25VcGRhdGVkKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCAndid9LW1vdmVgO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShwcmV2Q2hpbGRyZW5bMF0uZWwsIGluc3RhbmNlLnZub2RlLmVsLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IChlbC5fbW92ZUNiID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBwcmV2Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChjaGlsZCwgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xyXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XHJcbiAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICBpZiAoZWwuX21vdmVDYikge1xyXG4gICAgICAgIGVsLl9tb3ZlQ2IoKTtcclxuICAgIH1cclxuICAgIGlmIChlbC5fZW50ZXJDYikge1xyXG4gICAgICAgIGVsLl9lbnRlckNiKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xyXG4gICAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xyXG4gICAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xyXG4gICAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xyXG4gICAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xyXG4gICAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcclxuICAgIGlmIChkeCB8fCBkeSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xyXG4gICAgICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xyXG4gICAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xyXG4gICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXHJcbiAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcclxuICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcclxuICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xyXG4gICAgLy8gaXMgYXBwbGllZC5cclxuICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XHJcbiAgICBpZiAoZWwuX3Z0Yykge1xyXG4gICAgICAgIGVsLl92dGMuZm9yRWFjaChjbHMgPT4ge1xyXG4gICAgICAgICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IChyb290Lm5vZGVUeXBlID09PSAxXHJcbiAgICAgICAgPyByb290XHJcbiAgICAgICAgOiByb290LnBhcmVudE5vZGUpO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcclxuICAgIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XHJcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xyXG4gICAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcclxufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCBmbiA9IHZub2RlLnByb3BzWydvblVwZGF0ZTptb2RlbFZhbHVlJ107XHJcbiAgICByZXR1cm4gaXNBcnJheShmbikgPyB2YWx1ZSA9PiBpbnZva2VBcnJheUZucyhmbiwgdmFsdWUpIDogZm47XHJcbn07XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XHJcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xyXG4gICAgICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgJ2lucHV0Jyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlcihlbCwgdHlwZSkge1xyXG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcclxuICAgIGVsLmRpc3BhdGNoRXZlbnQoZSk7XHJcbn1cclxuLy8gV2UgYXJlIGV4cG9ydGluZyB0aGUgdi1tb2RlbCBydW50aW1lIGRpcmVjdGx5IGFzIHZub2RlIGhvb2tzIHNvIHRoYXQgaXQgY2FuXHJcbi8vIGJlIHRyZWUtc2hha2VuIGluIGNhc2Ugdi1tb2RlbCBpcyBuZXZlciB1c2VkLlxyXG5jb25zdCB2TW9kZWxUZXh0ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8IGVsLnR5cGUgPT09ICdudW1iZXInO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGxhenkgPyAnY2hhbmdlJyA6ICdpbnB1dCcsIGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNhc3RUb051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSB0b051bWJlcihkb21WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihkb21WYWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFsYXp5KSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cclxuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxyXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXHJcbiAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgLy8gYXZvaWQgY2xlYXJpbmcgdW5yZXNvbHZlZCB0ZXh0LiAjMjMwMlxyXG4gICAgICAgIGlmIChlbC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcclxuICAgICAgICAgICAgaWYgKHRyaW0gJiYgZWwudmFsdWUudHJpbSgpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgobnVtYmVyIHx8IGVsLnR5cGUgPT09ICdudW1iZXInKSAmJiB0b051bWJlcihlbC52YWx1ZSkgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2TW9kZWxDaGVja2JveCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIF8sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSBlbC5fbW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcclxuICAgICAgICAgICAgY29uc3QgYXNzaWduID0gZWwuX2Fzc2lnbjtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbG9vc2VJbmRleE9mKG1vZGVsVmFsdWUsIGVsZW1lbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgU2V0KG1vZGVsVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKGVsZW1lbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oY2xvbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcclxuICAgIG1vdW50ZWQ6IHNldENoZWNrZWQsXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0Q2hlY2tlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcclxuICAgIH1cclxufVxyXG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGdldFZhbHVlKGVsKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2TW9kZWxTZWxlY3QgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxyXG4gICAgICAgICAgICAgICAgLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKChvKSA9PiBudW1iZXIgPyB0b051bWJlcihnZXRWYWx1ZShvKSkgOiBnZXRWYWx1ZShvKSk7XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZWwubXVsdGlwbGVcclxuICAgICAgICAgICAgICAgID8gaXNTZXRNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IFNldChzZWxlY3RlZFZhbClcclxuICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdGVkVmFsXHJcbiAgICAgICAgICAgICAgICA6IHNlbGVjdGVkVmFsWzBdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxyXG4gICAgLy8gPG9wdGlvbj5zLlxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcclxuICAgIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcclxuICAgIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5KHZhbHVlKSAmJiAhaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD4gZXhwZWN0cyBhbiBBcnJheSBvciBTZXQgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBgICtcclxuICAgICAgICAgICAgICAgIGBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSl9LmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZ2V0VmFsdWUob3B0aW9uKTtcclxuICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5oYXMob3B0aW9uVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc011bHRpcGxlKSB7XHJcbiAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgfVxyXG59XHJcbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBzZXQgdmlhIDp2YWx1ZSBiaW5kaW5nc1xyXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xyXG4gICAgcmV0dXJuICdfdmFsdWUnIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIGZvciB0cnVlLXZhbHVlIGFuZCBmYWxzZS12YWx1ZSBzZXQgdmlhIDp0cnVlLXZhbHVlIG9yIDpmYWxzZS12YWx1ZSBiaW5kaW5nc1xyXG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XHJcbiAgICBjb25zdCBrZXkgPSBjaGVja2VkID8gJ190cnVlVmFsdWUnIDogJ19mYWxzZVZhbHVlJztcclxuICAgIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcclxufVxyXG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xyXG4gICAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ2NyZWF0ZWQnKTtcclxuICAgIH0sXHJcbiAgICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnbW91bnRlZCcpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICdiZWZvcmVVcGRhdGUnKTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ3VwZGF0ZWQnKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xyXG4gICAgbGV0IG1vZGVsVG9Vc2U7XHJcbiAgICBzd2l0Y2ggKGVsLnRhZ05hbWUpIHtcclxuICAgICAgICBjYXNlICdTRUxFQ1QnOlxyXG4gICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsU2VsZWN0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdURVhUQVJFQSc6XHJcbiAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxUZXh0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBzd2l0Y2ggKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsQ2hlY2tib3g7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFJhZGlvO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsVGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xyXG4gICAgZm4gJiYgZm4oZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpO1xyXG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddO1xyXG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcclxuICAgIHN0b3A6IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcclxuICAgIHByZXZlbnQ6IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxyXG4gICAgc2VsZjogZSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxyXG4gICAgY3RybDogZSA9PiAhZS5jdHJsS2V5LFxyXG4gICAgc2hpZnQ6IGUgPT4gIWUuc2hpZnRLZXksXHJcbiAgICBhbHQ6IGUgPT4gIWUuYWx0S2V5LFxyXG4gICAgbWV0YTogZSA9PiAhZS5tZXRhS2V5LFxyXG4gICAgbGVmdDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxyXG4gICAgbWlkZGxlOiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDEsXHJcbiAgICByaWdodDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxyXG4gICAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKG0gPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXHJcbn07XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XHJcbiAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xyXG4gICAgICAgICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBLZXB0IGZvciAyLnggY29tcGF0LlxyXG4vLyBOb3RlOiBJRTExIGNvbXBhdCBmb3IgYHNwYWNlYmFyYCBhbmQgYGRlbGAgaXMgcmVtb3ZlZCBmb3Igbm93LlxyXG5jb25zdCBrZXlOYW1lcyA9IHtcclxuICAgIGVzYzogJ2VzY2FwZScsXHJcbiAgICBzcGFjZTogJyAnLFxyXG4gICAgdXA6ICdhcnJvdy11cCcsXHJcbiAgICBsZWZ0OiAnYXJyb3ctbGVmdCcsXHJcbiAgICByaWdodDogJ2Fycm93LXJpZ2h0JyxcclxuICAgIGRvd246ICdhcnJvdy1kb3duJyxcclxuICAgIGRlbGV0ZTogJ2JhY2tzcGFjZSdcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XHJcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCEoJ2tleScgaW4gZXZlbnQpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgLy8gTm9uZSBvZiB0aGUgcHJvdmlkZWQga2V5IG1vZGlmaWVycyBtYXRjaCB0aGUgY3VycmVudCBldmVudCBrZXlcclxuICAgICAgICAhbW9kaWZpZXJzLnNvbWUoayA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHZTaG93ID0ge1xyXG4gICAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBlbC5fdm9kID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xyXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX3ZvZCA6ICdub25lJztcclxufVxuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSBleHRlbmQoeyBwYXRjaFByb3AsIGZvcmNlUGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xyXG4vLyBsYXp5IGNyZWF0ZSB0aGUgcmVuZGVyZXIgLSB0aGlzIG1ha2VzIGNvcmUgcmVuZGVyZXIgbG9naWMgdHJlZS1zaGFrYWJsZVxyXG4vLyBpbiBjYXNlIHRoZSB1c2VyIG9ubHkgaW1wb3J0cyByZWFjdGl2aXR5IHV0aWxpdGllcyBmcm9tIFZ1ZS5cclxubGV0IHJlbmRlcmVyO1xyXG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcclxuICAgIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvblxyXG4gICAgICAgID8gcmVuZGVyZXJcclxuICAgICAgICA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XHJcbiAgICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJlcjtcclxufVxyXG4vLyB1c2UgZXhwbGljaXQgdHlwZSBjYXN0cyBoZXJlIHRvIGF2b2lkIGltcG9ydCgpIGNhbGxzIGluIHJvbGxlZC11cCBkLnRzXHJcbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBoeWRyYXRlID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q3VzdG9tRWxlbWVudENoZWNrKGFwcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xyXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2xlYXIgY29udGVudCBiZWZvcmUgbW91bnRpbmdcclxuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS12LWFwcCcsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q3VzdG9tRWxlbWVudENoZWNrKGFwcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gYXBwO1xyXG59KTtcclxuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XHJcbiAgICAvLyBJbmplY3QgYGlzTmF0aXZlVGFnYFxyXG4gICAgLy8gdGhpcyBpcyB1c2VkIGZvciBjb21wb25lbnQgbmFtZSB2YWxpZGF0aW9uIChkZXYgb25seSlcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNOYXRpdmVUYWcnLCB7XHJcbiAgICAgICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXHJcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBpbmplY3RDdXN0b21FbGVtZW50Q2hlY2soYXBwKSB7XHJcbiAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzQ3VzdG9tRWxlbWVudCcsIHtcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgcnVudGltZSBjb21waWxlci5gICtcclxuICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWRgICtcclxuICAgICAgICAgICAgICAgICAgICBgLSBmb3IgZXhhbXBsZSwgdmlhIHRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgb3B0aW9uIGluIHZ1ZS1sb2FkZXI6IGh0dHBzOi8vdnVlLWxvYWRlci52dWVqcy5vcmcvb3B0aW9ucy5odG1sI2NvbXBpbGVyb3B0aW9ucy5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXJlcykge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmXHJcbiAgICAgICAgY29udGFpbmVyLm1vZGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgd2FybihgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBoeWRyYXRlLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIGh5cGhlbmF0ZSwgZXh0ZW5kLCBpc09iamVjdCwgaXNBcnJheSwgTk8sIG1ha2VNYXAsIGlzU3ltYm9sLCBOT09QLCBFTVBUWV9PQkosIGNhcGl0YWxpemUsIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIFBhdGNoRmxhZ05hbWVzLCBzbG90RmxhZ3NUZXh0LCBpc09uLCBpc1Jlc2VydmVkUHJvcCwgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgZ2VuZXJhdGVDb2RlRnJhbWUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGVycm9yKSB7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgbWVzc2FnZXMsIGFkZGl0aW9uYWxNZXNzYWdlKSB7XHJcbiAgICBjb25zdCBtc2cgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWVcclxuICAgICAgICA/IChtZXNzYWdlcyB8fCBlcnJvck1lc3NhZ2VzKVtjb2RlXSArIChhZGRpdGlvbmFsTWVzc2FnZSB8fCBgYClcclxuICAgICAgICA6IGNvZGU7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihTdHJpbmcobXNnKSk7XHJcbiAgICBlcnJvci5jb2RlID0gY29kZTtcclxuICAgIGVycm9yLmxvYyA9IGxvYztcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgLy8gcGFyc2UgZXJyb3JzXHJcbiAgICBbMCAvKiBBQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovXTogJ0lsbGVnYWwgY29tbWVudC4nLFxyXG4gICAgWzEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovXTogJ0NEQVRBIHNlY3Rpb24gaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LicsXHJcbiAgICBbMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovXTogJ0R1cGxpY2F0ZSBhdHRyaWJ1dGUuJyxcclxuICAgIFszIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovXTogJ0VuZCB0YWcgY2Fubm90IGhhdmUgYXR0cmlidXRlcy4nLFxyXG4gICAgWzQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXHJcbiAgICBbNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxyXG4gICAgWzYgLyogRU9GX0lOX0NEQVRBICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIENEQVRBIHNlY3Rpb24uJyxcclxuICAgIFs3IC8qIEVPRl9JTl9DT01NRU5UICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIGNvbW1lbnQuJyxcclxuICAgIFs4IC8qIEVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBzY3JpcHQuJyxcclxuICAgIFs5IC8qIEVPRl9JTl9UQUcgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXHJcbiAgICBbMTAgLyogSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgY2xvc2VkIGNvbW1lbnQuJyxcclxuICAgIFsxMSAvKiBJTkNPUlJFQ1RMWV9PUEVORURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBvcGVuZWQgY29tbWVudC4nLFxyXG4gICAgWzEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovXTogXCJJbGxlZ2FsIHRhZyBuYW1lLiBVc2UgJyZsdDsnIHRvIHByaW50ICc8Jy5cIixcclxuICAgIFsxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqL106ICdBdHRyaWJ1dGUgdmFsdWUgd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi9dOiAnRW5kIHRhZyBuYW1lIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi9dOiAnV2hpdGVzcGFjZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNiAvKiBORVNURURfQ09NTUVOVCAqL106IFwiVW5leHBlY3RlZCAnPCEtLScgaW4gY29tbWVudC5cIixcclxuICAgIFsxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqL106ICdBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBhbmQgVSswMDNDICg8KS4nLFxyXG4gICAgWzE4IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqL106ICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgVSswMDNDICg8KSwgVSswMDNEICg9KSwgYW5kIFUrMDA2MCAoYCkuJyxcclxuICAgIFsxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqL106IFwiQXR0cmlidXRlIG5hbWUgY2Fubm90IHN0YXJ0IHdpdGggJz0nLlwiLFxyXG4gICAgWzIxIC8qIFVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovXTogXCInPD8nIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC5cIixcclxuICAgIFsyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gICAgLy8gVnVlLXNwZWNpZmljIHBhcnNlIGVycm9yc1xyXG4gICAgWzIzIC8qIFhfSU5WQUxJRF9FTkRfVEFHICovXTogJ0ludmFsaWQgZW5kIHRhZy4nLFxyXG4gICAgWzI0IC8qIFhfTUlTU0lOR19FTkRfVEFHICovXTogJ0VsZW1lbnQgaXMgbWlzc2luZyBlbmQgdGFnLicsXHJcbiAgICBbMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovXTogJ0ludGVycG9sYXRpb24gZW5kIHNpZ24gd2FzIG5vdCBmb3VuZC4nLFxyXG4gICAgWzI2IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi9dOiAnRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuICcgK1xyXG4gICAgICAgICdOb3RlIHRoYXQgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgY2Fubm90IGNvbnRhaW4gc3BhY2VzLicsXHJcbiAgICAvLyB0cmFuc2Zvcm0gZXJyb3JzXHJcbiAgICBbMjcgLyogWF9WX0lGX05PX0VYUFJFU1NJT04gKi9dOiBgdi1pZi92LWVsc2UtaWYgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMjggLyogWF9WX0lGX1NBTUVfS0VZICovXTogYHYtaWYvZWxzZSBicmFuY2hlcyBtdXN0IHVzZSB1bmlxdWUga2V5cy5gLFxyXG4gICAgWzI5IC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovXTogYHYtZWxzZS92LWVsc2UtaWYgaGFzIG5vIGFkamFjZW50IHYtaWYuYCxcclxuICAgIFszMCAvKiBYX1ZfRk9SX05PX0VYUFJFU1NJT04gKi9dOiBgdi1mb3IgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzEgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqL106IGB2LWZvciBoYXMgaW52YWxpZCBleHByZXNzaW9uLmAsXHJcbiAgICBbMzIgLyogWF9WX0ZPUl9URU1QTEFURV9LRVlfUExBQ0VNRU5UICovXTogYDx0ZW1wbGF0ZSB2LWZvcj4ga2V5IHNob3VsZCBiZSBwbGFjZWQgb24gdGhlIDx0ZW1wbGF0ZT4gdGFnLmAsXHJcbiAgICBbMzMgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqL106IGB2LWJpbmQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzQgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi9dOiBgdi1vbiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszNSAvKiBYX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVCAqL106IGBVbmV4cGVjdGVkIGN1c3RvbSBkaXJlY3RpdmUgb24gPHNsb3Q+IG91dGxldC5gLFxyXG4gICAgWzM2IC8qIFhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0UgKi9dOiBgTWl4ZWQgdi1zbG90IHVzYWdlIG9uIGJvdGggdGhlIGNvbXBvbmVudCBhbmQgbmVzdGVkIDx0ZW1wbGF0ZT4uYCArXHJcbiAgICAgICAgYFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIG5hbWVkIHNsb3RzLCBhbGwgc2xvdHMgc2hvdWxkIHVzZSA8dGVtcGxhdGU+IGAgK1xyXG4gICAgICAgIGBzeW50YXggdG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LmAsXHJcbiAgICBbMzcgLyogWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi9dOiBgRHVwbGljYXRlIHNsb3QgbmFtZXMgZm91bmQuIGAsXHJcbiAgICBbMzggLyogWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU4gKi9dOiBgRXh0cmFuZW91cyBjaGlsZHJlbiBmb3VuZCB3aGVuIGNvbXBvbmVudCBhbHJlYWR5IGhhcyBleHBsaWNpdGx5IG5hbWVkIGAgK1xyXG4gICAgICAgIGBkZWZhdWx0IHNsb3QuIFRoZXNlIGNoaWxkcmVuIHdpbGwgYmUgaWdub3JlZC5gLFxyXG4gICAgWzM5IC8qIFhfVl9TTE9UX01JU1BMQUNFRCAqL106IGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4gdGFncy5gLFxyXG4gICAgWzQwIC8qIFhfVl9NT0RFTF9OT19FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNDEgLyogWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgbWVtYmVyIGV4cHJlc3Npb24uYCxcclxuICAgIFs0MiAvKiBYX1ZfTU9ERUxfT05fU0NPUEVfVkFSSUFCTEUgKi9dOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiB2LWZvciBvciB2LXNsb3Qgc2NvcGUgdmFyaWFibGVzIGJlY2F1c2UgdGhleSBhcmUgbm90IHdyaXRhYmxlLmAsXHJcbiAgICBbNDMgLyogWF9JTlZBTElEX0VYUFJFU1NJT04gKi9dOiBgRXJyb3IgcGFyc2luZyBKYXZhU2NyaXB0IGV4cHJlc3Npb246IGAsXHJcbiAgICBbNDQgLyogWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPEtlZXBBbGl2ZT4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuYCxcclxuICAgIC8vIGdlbmVyaWMgZXJyb3JzXHJcbiAgICBbNDUgLyogWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRCAqL106IGBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxyXG4gICAgWzQ2IC8qIFhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqL106IGBFUyBtb2R1bGUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcclxuICAgIFs0NyAvKiBYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqL106IGBcImNhY2hlSGFuZGxlcnNcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB0aGUgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBlbmFibGVkLmAsXHJcbiAgICBbNDggLyogWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwic2NvcGVJZFwiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBtb2R1bGUgbW9kZS5gXHJcbn07XG5cbmNvbnN0IEZSQUdNRU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBGcmFnbWVudGAgOiBgYCk7XHJcbmNvbnN0IFRFTEVQT1JUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUZWxlcG9ydGAgOiBgYCk7XHJcbmNvbnN0IFNVU1BFTlNFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBTdXNwZW5zZWAgOiBgYCk7XHJcbmNvbnN0IEtFRVBfQUxJVkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEtlZXBBbGl2ZWAgOiBgYCk7XHJcbmNvbnN0IEJBU0VfVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgQmFzZVRyYW5zaXRpb25gIDogYGApO1xyXG5jb25zdCBPUEVOX0JMT0NLID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBvcGVuQmxvY2tgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUJsb2NrYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1ZOT0RFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9DT01NRU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVDb21tZW50Vk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfVEVYVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlVGV4dFZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1NUQVRJQyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlU3RhdGljVk5vZGVgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0NPTVBPTkVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZUNvbXBvbmVudGAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9ESVJFQ1RJVkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVEaXJlY3RpdmVgIDogYGApO1xyXG5jb25zdCBXSVRIX0RJUkVDVElWRVMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhEaXJlY3RpdmVzYCA6IGBgKTtcclxuY29uc3QgUkVOREVSX0xJU1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlckxpc3RgIDogYGApO1xyXG5jb25zdCBSRU5ERVJfU0xPVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVuZGVyU2xvdGAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TTE9UUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlU2xvdHNgIDogYGApO1xyXG5jb25zdCBUT19ESVNQTEFZX1NUUklORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9EaXNwbGF5U3RyaW5nYCA6IGBgKTtcclxuY29uc3QgTUVSR0VfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG1lcmdlUHJvcHNgIDogYGApO1xyXG5jb25zdCBUT19IQU5ETEVSUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9IYW5kbGVyc2AgOiBgYCk7XHJcbmNvbnN0IENBTUVMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYW1lbGl6ZWAgOiBgYCk7XHJcbmNvbnN0IENBUElUQUxJWkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNhcGl0YWxpemVgIDogYGApO1xyXG5jb25zdCBUT19IQU5ETEVSX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9IYW5kbGVyS2V5YCA6IGBgKTtcclxuY29uc3QgU0VUX0JMT0NLX1RSQUNLSU5HID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzZXRCbG9ja1RyYWNraW5nYCA6IGBgKTtcclxuY29uc3QgUFVTSF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcHVzaFNjb3BlSWRgIDogYGApO1xyXG5jb25zdCBQT1BfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHBvcFNjb3BlSWRgIDogYGApO1xyXG5jb25zdCBXSVRIX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoU2NvcGVJZGAgOiBgYCk7XHJcbmNvbnN0IFdJVEhfQ1RYID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoQ3R4YCA6IGBgKTtcclxuY29uc3QgVU5SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHVucmVmYCA6IGBgKTtcclxuY29uc3QgSVNfUkVGID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBpc1JlZmAgOiBgYCk7XHJcbi8vIE5hbWUgbWFwcGluZyBmb3IgcnVudGltZSBoZWxwZXJzIHRoYXQgbmVlZCB0byBiZSBpbXBvcnRlZCBmcm9tICd2dWUnIGluXHJcbi8vIGdlbmVyYXRlZCBjb2RlLiBNYWtlIHN1cmUgdGhlc2UgYXJlIGNvcnJlY3RseSBleHBvcnRlZCBpbiB0aGUgcnVudGltZSFcclxuLy8gVXNpbmcgYGFueWAgaGVyZSBiZWNhdXNlIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9scyBhcyBpbmRleCB0eXBlLlxyXG5jb25zdCBoZWxwZXJOYW1lTWFwID0ge1xyXG4gICAgW0ZSQUdNRU5UXTogYEZyYWdtZW50YCxcclxuICAgIFtURUxFUE9SVF06IGBUZWxlcG9ydGAsXHJcbiAgICBbU1VTUEVOU0VdOiBgU3VzcGVuc2VgLFxyXG4gICAgW0tFRVBfQUxJVkVdOiBgS2VlcEFsaXZlYCxcclxuICAgIFtCQVNFX1RSQU5TSVRJT05dOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgW09QRU5fQkxPQ0tdOiBgb3BlbkJsb2NrYCxcclxuICAgIFtDUkVBVEVfQkxPQ0tdOiBgY3JlYXRlQmxvY2tgLFxyXG4gICAgW0NSRUFURV9WTk9ERV06IGBjcmVhdGVWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX0NPTU1FTlRdOiBgY3JlYXRlQ29tbWVudFZOb2RlYCxcclxuICAgIFtDUkVBVEVfVEVYVF06IGBjcmVhdGVUZXh0Vk5vZGVgLFxyXG4gICAgW0NSRUFURV9TVEFUSUNdOiBgY3JlYXRlU3RhdGljVk5vZGVgLFxyXG4gICAgW1JFU09MVkVfQ09NUE9ORU5UXTogYHJlc29sdmVDb21wb25lbnRgLFxyXG4gICAgW1JFU09MVkVfRFlOQU1JQ19DT01QT05FTlRdOiBgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnRgLFxyXG4gICAgW1JFU09MVkVfRElSRUNUSVZFXTogYHJlc29sdmVEaXJlY3RpdmVgLFxyXG4gICAgW1dJVEhfRElSRUNUSVZFU106IGB3aXRoRGlyZWN0aXZlc2AsXHJcbiAgICBbUkVOREVSX0xJU1RdOiBgcmVuZGVyTGlzdGAsXHJcbiAgICBbUkVOREVSX1NMT1RdOiBgcmVuZGVyU2xvdGAsXHJcbiAgICBbQ1JFQVRFX1NMT1RTXTogYGNyZWF0ZVNsb3RzYCxcclxuICAgIFtUT19ESVNQTEFZX1NUUklOR106IGB0b0Rpc3BsYXlTdHJpbmdgLFxyXG4gICAgW01FUkdFX1BST1BTXTogYG1lcmdlUHJvcHNgLFxyXG4gICAgW1RPX0hBTkRMRVJTXTogYHRvSGFuZGxlcnNgLFxyXG4gICAgW0NBTUVMSVpFXTogYGNhbWVsaXplYCxcclxuICAgIFtDQVBJVEFMSVpFXTogYGNhcGl0YWxpemVgLFxyXG4gICAgW1RPX0hBTkRMRVJfS0VZXTogYHRvSGFuZGxlcktleWAsXHJcbiAgICBbU0VUX0JMT0NLX1RSQUNLSU5HXTogYHNldEJsb2NrVHJhY2tpbmdgLFxyXG4gICAgW1BVU0hfU0NPUEVfSURdOiBgcHVzaFNjb3BlSWRgLFxyXG4gICAgW1BPUF9TQ09QRV9JRF06IGBwb3BTY29wZUlkYCxcclxuICAgIFtXSVRIX1NDT1BFX0lEXTogYHdpdGhTY29wZUlkYCxcclxuICAgIFtXSVRIX0NUWF06IGB3aXRoQ3R4YCxcclxuICAgIFtVTlJFRl06IGB1bnJlZmAsXHJcbiAgICBbSVNfUkVGXTogYGlzUmVmYFxyXG59O1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVIZWxwZXJzKGhlbHBlcnMpIHtcclxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVscGVycykuZm9yRWFjaChzID0+IHtcclxuICAgICAgICBoZWxwZXJOYW1lTWFwW3NdID0gaGVscGVyc1tzXTtcclxuICAgIH0pO1xyXG59XG5cbi8vIEFTVCBVdGlsaXRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFNvbWUgZXhwcmVzc2lvbnMsIGUuZy4gc2VxdWVuY2UgYW5kIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLCBhcmUgbmV2ZXJcclxuLy8gYXNzb2NpYXRlZCB3aXRoIHRlbXBsYXRlIG5vZGVzLCBzbyB0aGVpciBzb3VyY2UgbG9jYXRpb25zIGFyZSBqdXN0IGEgc3R1Yi5cclxuLy8gQ29udGFpbmVyIHR5cGVzIGxpa2UgQ29tcG91bmRFeHByZXNzaW9uIGFsc28gZG9uJ3QgbmVlZCBhIHJlYWwgbG9jYXRpb24uXHJcbmNvbnN0IGxvY1N0dWIgPSB7XHJcbiAgICBzb3VyY2U6ICcnLFxyXG4gICAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcclxuICAgIGVuZDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMCAvKiBST09UICovLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGhlbHBlcnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IFtdLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IFtdLFxyXG4gICAgICAgIGhvaXN0czogW10sXHJcbiAgICAgICAgaW1wb3J0czogW10sXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIHRlbXBzOiAwLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2sgPSBmYWxzZSwgZGlzYWJsZVRyYWNraW5nID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihXSVRIX0RJUkVDVElWRVMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTMgLyogVk5PREVfQ0FMTCAqLyxcclxuICAgICAgICB0YWcsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkaXJlY3RpdmVzLFxyXG4gICAgICAgIGlzQmxvY2ssXHJcbiAgICAgICAgZGlzYWJsZVRyYWNraW5nLFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUV4cHJlc3Npb24oZWxlbWVudHMsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgZWxlbWVudHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBwcm9wZXJ0aWVzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTYgLyogSlNfUFJPUEVSVFkgKi8sXHJcbiAgICAgICAgbG9jOiBsb2NTdHViLFxyXG4gICAgICAgIGtleTogaXNTdHJpbmcoa2V5KSA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oa2V5LCB0cnVlKSA6IGtleSxcclxuICAgICAgICB2YWx1ZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGlzU3RhdGljLCBsb2MgPSBsb2NTdHViLCBjb25zdFR5cGUgPSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGlzU3RhdGljLFxyXG4gICAgICAgIGNvbnN0VHlwZTogaXNTdGF0aWMgPyAzIC8qIENBTl9TVFJJTkdJRlkgKi8gOiBjb25zdFR5cGVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW50ZXJwb2xhdGlvbihjb250ZW50LCBsb2MpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNSAvKiBJTlRFUlBPTEFUSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjb250ZW50OiBpc1N0cmluZyhjb250ZW50KVxyXG4gICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgZmFsc2UsIGxvYylcclxuICAgICAgICAgICAgOiBjb250ZW50XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihjaGlsZHJlbiwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNoaWxkcmVuXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncyA9IFtdLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY2FsbGVlLFxyXG4gICAgICAgIGFyZ3VtZW50czogYXJnc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCByZXR1cm5zID0gdW5kZWZpbmVkLCBuZXdsaW5lID0gZmFsc2UsIGlzU2xvdCA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE4IC8qIEpTX0ZVTkNUSU9OX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgIHJldHVybnMsXHJcbiAgICAgICAgbmV3bGluZSxcclxuICAgICAgICBpc1Nsb3QsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmUgPSB0cnVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgdGVzdCxcclxuICAgICAgICBjb25zZXF1ZW50LFxyXG4gICAgICAgIGFsdGVybmF0ZSxcclxuICAgICAgICBuZXdsaW5lLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDYWNoZUV4cHJlc3Npb24oaW5kZXgsIHZhbHVlLCBpc1ZOb2RlID0gZmFsc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBpbmRleCxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBpc1ZOb2RlLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVCbG9ja1N0YXRlbWVudChib2R5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIxIC8qIEpTX0JMT0NLX1NUQVRFTUVOVCAqLyxcclxuICAgICAgICBib2R5LFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUxpdGVyYWwoZWxlbWVudHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjIgLyogSlNfVEVNUExBVEVfTElURVJBTCAqLyxcclxuICAgICAgICBlbGVtZW50cyxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIzIC8qIEpTX0lGX1NUQVRFTUVOVCAqLyxcclxuICAgICAgICB0ZXN0LFxyXG4gICAgICAgIGNvbnNlcXVlbnQsXHJcbiAgICAgICAgYWx0ZXJuYXRlLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNCAvKiBKU19BU1NJR05NRU5UX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbGVmdCxcclxuICAgICAgICByaWdodCxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDI1IC8qIEpTX1NFUVVFTkNFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgZXhwcmVzc2lvbnMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJldHVyblN0YXRlbWVudChyZXR1cm5zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDI2IC8qIEpTX1JFVFVSTl9TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgcmV0dXJucyxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cblxuY29uc3QgaXNTdGF0aWNFeHAgPSAocCkgPT4gcC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmIHAuaXNTdGF0aWM7XHJcbmNvbnN0IGlzQnVpbHRJblR5cGUgPSAodGFnLCBleHBlY3RlZCkgPT4gdGFnID09PSBleHBlY3RlZCB8fCB0YWcgPT09IGh5cGhlbmF0ZShleHBlY3RlZCk7XHJcbmZ1bmN0aW9uIGlzQ29yZUNvbXBvbmVudCh0YWcpIHtcclxuICAgIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1RlbGVwb3J0JykpIHtcclxuICAgICAgICByZXR1cm4gVEVMRVBPUlQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1N1c3BlbnNlJykpIHtcclxuICAgICAgICByZXR1cm4gU1VTUEVOU0U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0tlZXBBbGl2ZScpKSB7XHJcbiAgICAgICAgcmV0dXJuIEtFRVBfQUxJVkU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0Jhc2VUcmFuc2l0aW9uJykpIHtcclxuICAgICAgICByZXR1cm4gQkFTRV9UUkFOU0lUSU9OO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IG5vbklkZW50aWZpZXJSRSA9IC9eXFxkfFteXFwkXFx3XS87XHJcbmNvbnN0IGlzU2ltcGxlSWRlbnRpZmllciA9IChuYW1lKSA9PiAhbm9uSWRlbnRpZmllclJFLnRlc3QobmFtZSk7XHJcbmNvbnN0IG1lbWJlckV4cFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxccypcXC5cXHMqW0EtWmEtel8kXVtcXHckXSp8XFxbW15cXF1dK1xcXSkqJC87XHJcbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbiA9IChwYXRoKSA9PiB7XHJcbiAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIG1lbWJlckV4cFJFLnRlc3QocGF0aC50cmltKCkpO1xyXG59O1xyXG5mdW5jdGlvbiBnZXRJbm5lclJhbmdlKGxvYywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IGxvYy5zb3VyY2Uuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcclxuICAgIGNvbnN0IG5ld0xvYyA9IHtcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgc3RhcnQ6IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShsb2Muc3RhcnQsIGxvYy5zb3VyY2UsIG9mZnNldCksXHJcbiAgICAgICAgZW5kOiBsb2MuZW5kXHJcbiAgICB9O1xyXG4gICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgbmV3TG9jLmVuZCA9IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShsb2Muc3RhcnQsIGxvYy5zb3VyY2UsIG9mZnNldCArIGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3TG9jO1xyXG59XHJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihleHRlbmQoe30sIHBvcyksIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG4vLyBhZHZhbmNlIGJ5IG11dGF0aW9uIHdpdGhvdXQgY2xvbmluZyAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLCBzaW5jZSB0aGlzXHJcbi8vIGdldHMgY2FsbGVkIGEgbG90IGluIHRoZSBwYXJzZXJcclxuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICBsZXQgbGluZXNDb3VudCA9IDA7XHJcbiAgICBsZXQgbGFzdE5ld0xpbmVQb3MgPSAtMTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDaGFyYWN0ZXJzOyBpKyspIHtcclxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaSkgPT09IDEwIC8qIG5ld2xpbmUgY2hhciBjb2RlICovKSB7XHJcbiAgICAgICAgICAgIGxpbmVzQ291bnQrKztcclxuICAgICAgICAgICAgbGFzdE5ld0xpbmVQb3MgPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvcy5vZmZzZXQgKz0gbnVtYmVyT2ZDaGFyYWN0ZXJzO1xyXG4gICAgcG9zLmxpbmUgKz0gbGluZXNDb3VudDtcclxuICAgIHBvcy5jb2x1bW4gPVxyXG4gICAgICAgIGxhc3ROZXdMaW5lUG9zID09PSAtMVxyXG4gICAgICAgICAgICA/IHBvcy5jb2x1bW4gKyBudW1iZXJPZkNoYXJhY3RlcnNcclxuICAgICAgICAgICAgOiBudW1iZXJPZkNoYXJhY3RlcnMgLSBsYXN0TmV3TGluZVBvcztcclxuICAgIHJldHVybiBwb3M7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCBgdW5leHBlY3RlZCBjb21waWxlciBjb25kaXRpb25gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kRGlyKG5vZGUsIG5hbWUsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgKGFsbG93RW1wdHkgfHwgcC5leHApICYmXHJcbiAgICAgICAgICAgIChpc1N0cmluZyhuYW1lKSA/IHAubmFtZSA9PT0gbmFtZSA6IG5hbWUudGVzdChwLm5hbWUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZFByb3Aobm9kZSwgbmFtZSwgZHluYW1pY09ubHkgPSBmYWxzZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY09ubHkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gbmFtZSAmJiAocC52YWx1ZSB8fCBhbGxvd0VtcHR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAgICAgKHAuZXhwIHx8IGFsbG93RW1wdHkpICYmXHJcbiAgICAgICAgICAgIGlzQmluZEtleShwLmFyZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQmluZEtleShhcmcsIG5hbWUpIHtcclxuICAgIHJldHVybiAhIShhcmcgJiYgaXNTdGF0aWNFeHAoYXJnKSAmJiBhcmcuY29udGVudCA9PT0gbmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgcC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAoIXAuYXJnIHx8IC8vIHYtYmluZD1cIm9ialwiXHJcbiAgICAgICAgICAgIHAuYXJnLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHwgLy8gdi1iaW5kOltfY3R4LmZvb11cclxuICAgICAgICAgICAgIXAuYXJnLmlzU3RhdGljKSAvLyB2LWJpbmQ6W2Zvb11cclxuICAgICk7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fCBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLztcclxufVxyXG5mdW5jdGlvbiBpc1ZTbG90KHApIHtcclxuICAgIHJldHVybiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3Nsb3QnO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGVtcGxhdGVOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiYgbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovKTtcclxufVxyXG5mdW5jdGlvbiBpc1Nsb3RPdXRsZXQobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMiAvKiBTTE9UICovO1xyXG59XHJcbmZ1bmN0aW9uIGluamVjdFByb3Aobm9kZSwgcHJvcCwgY29udGV4dCkge1xyXG4gICAgbGV0IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgIGNvbnN0IHByb3BzID0gbm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovID8gbm9kZS5wcm9wcyA6IG5vZGUuYXJndW1lbnRzWzJdO1xyXG4gICAgaWYgKHByb3BzID09IG51bGwgfHwgaXNTdHJpbmcocHJvcHMpKSB7XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgLy8gbWVyZ2VkIHByb3BzLi4uIGFkZCBvdXJzXHJcbiAgICAgICAgLy8gb25seSBpbmplY3Qga2V5IHRvIG9iamVjdCBsaXRlcmFsIGlmIGl0J3MgdGhlIGZpcnN0IGFyZ3VtZW50IHNvIHRoYXRcclxuICAgICAgICAvLyBpZiBkb2Vzbid0IG92ZXJyaWRlIHVzZXIgcHJvdmlkZWQga2V5c1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gcHJvcHMuYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoZmlyc3QpICYmIGZpcnN0LnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGZpcnN0LnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5jYWxsZWUgPT09IFRPX0hBTkRMRVJTKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjM2NlxyXG4gICAgICAgICAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmFyZ3VtZW50cy51bnNoaWZ0KGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgIXByb3BzV2l0aEluamVjdGlvbiAmJiAocHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBsZXQgYWxyZWFkeUV4aXN0cyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGNoZWNrIGV4aXN0aW5nIGtleSB0byBhdm9pZCBvdmVycmlkaW5nIHVzZXIgcHJvdmlkZWQga2V5c1xyXG4gICAgICAgIGlmIChwcm9wLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BLZXlOYW1lID0gcHJvcC5rZXkuY29udGVudDtcclxuICAgICAgICAgICAgYWxyZWFkeUV4aXN0cyA9IHByb3BzLnByb3BlcnRpZXMuc29tZShwID0+IHAua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgICAgIHAua2V5LmNvbnRlbnQgPT09IHByb3BLZXlOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhbHJlYWR5RXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggZXhwcmVzc2lvbiwgcmV0dXJuIGEgbWVyZ2VkIHJlcGxhY2VtZW50XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcclxuICAgICAgICAgICAgcHJvcHNcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICBub2RlLnByb3BzID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbm9kZS5hcmd1bWVudHNbMl0gPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9WYWxpZEFzc2V0SWQobmFtZSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIGBfJHt0eXBlfV8ke25hbWUucmVwbGFjZSgvW15cXHddL2csICdfJyl9YDtcclxufVxyXG4vLyBDaGVjayBpZiBhIG5vZGUgY29udGFpbnMgZXhwcmVzc2lvbnMgdGhhdCByZWZlcmVuY2UgY3VycmVudCBjb250ZXh0IHNjb3BlIGlkc1xyXG5mdW5jdGlvbiBoYXNTY29wZVJlZihub2RlLCBpZHMpIHtcclxuICAgIGlmICghbm9kZSB8fCBPYmplY3Qua2V5cyhpZHMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChoYXNTY29wZVJlZihwLmFyZywgaWRzKSB8fCBoYXNTY29wZVJlZihwLmV4cCwgaWRzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLnNvdXJjZSwgaWRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYnJhbmNoZXMuc29tZShiID0+IGhhc1Njb3BlUmVmKGIsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICBpZiAoaGFzU2NvcGVSZWYobm9kZS5jb25kaXRpb24sIGlkcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiAoIW5vZGUuaXNTdGF0aWMgJiZcclxuICAgICAgICAgICAgICAgIGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpICYmXHJcbiAgICAgICAgICAgICAgICAhIWlkc1tub2RlLmNvbnRlbnRdKTtcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGlzT2JqZWN0KGMpICYmIGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICByZXR1cm4gaGFzU2NvcGVSZWYobm9kZS5jb250ZW50LCBpZHMpO1xyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cblxuLy8gVGhlIGRlZmF1bHQgZGVjb2RlciBvbmx5IHByb3ZpZGVzIGVzY2FwZXMgZm9yIGNoYXJhY3RlcnMgcmVzZXJ2ZWQgYXMgcGFydCBvZlxyXG4vLyB0aGUgdGVtcGxhdGUgc3ludGF4LCBhbmQgaXMgb25seSB1c2VkIGlmIHRoZSBjdXN0b20gcmVuZGVyZXIgZGlkIG5vdCBwcm92aWRlXHJcbi8vIGEgcGxhdGZvcm0tc3BlY2lmaWMgZGVjb2Rlci5cclxuY29uc3QgZGVjb2RlUkUgPSAvJihndHxsdHxhbXB8YXBvc3xxdW90KTsvZztcclxuY29uc3QgZGVjb2RlTWFwID0ge1xyXG4gICAgZ3Q6ICc+JyxcclxuICAgIGx0OiAnPCcsXHJcbiAgICBhbXA6ICcmJyxcclxuICAgIGFwb3M6IFwiJ1wiLFxyXG4gICAgcXVvdDogJ1wiJ1xyXG59O1xyXG5jb25zdCBkZWZhdWx0UGFyc2VyT3B0aW9ucyA9IHtcclxuICAgIGRlbGltaXRlcnM6IFtge3tgLCBgfX1gXSxcclxuICAgIGdldE5hbWVzcGFjZTogKCkgPT4gMCAvKiBIVE1MICovLFxyXG4gICAgZ2V0VGV4dE1vZGU6ICgpID0+IDAgLyogREFUQSAqLyxcclxuICAgIGlzVm9pZFRhZzogTk8sXHJcbiAgICBpc1ByZVRhZzogTk8sXHJcbiAgICBpc0N1c3RvbUVsZW1lbnQ6IE5PLFxyXG4gICAgZGVjb2RlRW50aXRpZXM6IChyYXdUZXh0KSA9PiByYXdUZXh0LnJlcGxhY2UoZGVjb2RlUkUsIChfLCBwMSkgPT4gZGVjb2RlTWFwW3AxXSksXHJcbiAgICBvbkVycm9yOiBkZWZhdWx0T25FcnJvcixcclxuICAgIGNvbW1lbnRzOiBmYWxzZVxyXG59O1xyXG5mdW5jdGlvbiBiYXNlUGFyc2UoY29udGVudCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJvb3QocGFyc2VDaGlsZHJlbihjb250ZXh0LCAwIC8qIERBVEEgKi8sIFtdKSwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCByYXdPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0UGFyc2VyT3B0aW9ucyk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdPcHRpb25zKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHJhd09wdGlvbnNba2V5XSB8fCBkZWZhdWx0UGFyc2VyT3B0aW9uc1trZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIGNvbHVtbjogMSxcclxuICAgICAgICBsaW5lOiAxLFxyXG4gICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogY29udGVudCxcclxuICAgICAgICBzb3VyY2U6IGNvbnRlbnQsXHJcbiAgICAgICAgaW5QcmU6IGZhbHNlLFxyXG4gICAgICAgIGluVlByZTogZmFsc2VcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDaGlsZHJlbihjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgIGNvbnN0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBIVE1MICovO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcclxuICAgIHdoaWxlICghaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcclxuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovIHx8IG1vZGUgPT09IDEgLyogUkNEQVRBICovKSB7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgc3RhcnRzV2l0aChzLCBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVyc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIC8vICd7eydcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovICYmIHNbMF0gPT09ICc8Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RhZy1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICchJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNtYXJrdXAtZGVjbGFyYXRpb24tb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8IS0tJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFET0NUWVBFJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIERPQ1RZUEUgYnkgYSBsaW1pdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGgocywgJzwhW0NEQVRBWycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChucyAhPT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDExIC8qIElOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlbmQtdGFnLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMl0gPT09ICc+Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMyAvKiBYX0lOVkFMSURfRU5EX1RBRyAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogRW5kICovLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlRWxlbWVudChjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIxIC8qIFVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTIgLyogSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi8sIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlID0gcGFyc2VUZXh0KGNvbnRleHQsIG1vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHVzaE5vZGUobm9kZXMsIG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFdoaXRlc3BhY2UgbWFuYWdlbWVudCBmb3IgbW9yZSBlZmZpY2llbnQgb3V0cHV0XHJcbiAgICAvLyAoc2FtZSBhcyB2MiB3aGl0ZXNwYWNlOiAnY29uZGVuc2UnKVxyXG4gICAgbGV0IHJlbW92ZWRXaGl0ZXNwYWNlID0gZmFsc2U7XHJcbiAgICBpZiAobW9kZSAhPT0gMiAvKiBSQVdURVhUICovKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblByZSAmJiBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEvW15cXHRcXHJcXG5cXGYgXS8udGVzdChub2RlLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG5vZGVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlIHdoaXRlc3BhY2UgaXMgdGhlIGZpcnN0IG9yIGxhc3Qgbm9kZSwgb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGUgd2hpdGVzcGFjZSBpcyBhZGphY2VudCB0byBhIGNvbW1lbnQsIG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlIHdoaXRlc3BhY2UgaXMgYmV0d2VlbiB0d28gZWxlbWVudHMgQU5EIGNvbnRhaW5zIG5ld2xpbmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIHRoZSB3aGl0ZXNwYWNlIGlzIGlnbm9yZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYudHlwZSA9PT0gMyAvKiBDT01NRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gMyAvKiBDT01NRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9bXFxyXFxuXS8udGVzdChub2RlLmNvbnRlbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY29uZGVuc2VkIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2UgaW5zaWRlIHRoZSB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdG8gYSBzaW5nbGUgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmIF0rL2csICcgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWxzbyByZW1vdmUgY29tbWVudCBub2RlcyBpbiBwcm9kIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gMyAvKiBDT01NRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAhY29udGV4dC5vcHRpb25zLmNvbW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRleHQuaW5QcmUgJiYgcGFyZW50ICYmIGNvbnRleHQub3B0aW9ucy5pc1ByZVRhZyhwYXJlbnQudGFnKSkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgbGVhZGluZyBuZXdsaW5lIHBlciBodG1sIHNwZWNcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZ3JvdXBpbmctY29udGVudC5odG1sI3RoZS1wcmUtZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IG5vZGVzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3QgJiYgZmlyc3QudHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdC5jb250ZW50ID0gZmlyc3QuY29udGVudC5yZXBsYWNlKC9eXFxyP1xcbi8sICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdmVkV2hpdGVzcGFjZSA/IG5vZGVzLmZpbHRlcihCb29sZWFuKSA6IG5vZGVzO1xyXG59XHJcbmZ1bmN0aW9uIHB1c2hOb2RlKG5vZGVzLCBub2RlKSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICBjb25zdCBwcmV2ID0gbGFzdChub2Rlcyk7XHJcbiAgICAgICAgLy8gTWVyZ2UgaWYgYm90aCB0aGlzIGFuZCB0aGUgcHJldmlvdXMgbm9kZSBhcmUgdGV4dCBhbmQgdGhvc2UgYXJlXHJcbiAgICAgICAgLy8gY29uc2VjdXRpdmUuIFRoaXMgaGFwcGVucyBmb3IgY2FzZXMgbGlrZSBcImEgPCBiXCIuXHJcbiAgICAgICAgaWYgKHByZXYgJiZcclxuICAgICAgICAgICAgcHJldi50eXBlID09PSAyIC8qIFRFWFQgKi8gJiZcclxuICAgICAgICAgICAgcHJldi5sb2MuZW5kLm9mZnNldCA9PT0gbm9kZS5sb2Muc3RhcnQub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHByZXYuY29udGVudCArPSBub2RlLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIHByZXYubG9jLmVuZCA9IG5vZGUubG9jLmVuZDtcclxuICAgICAgICAgICAgcHJldi5sb2Muc291cmNlICs9IG5vZGUubG9jLnNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpIHtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCA5KTtcclxuICAgIGNvbnN0IG5vZGVzID0gcGFyc2VDaGlsZHJlbihjb250ZXh0LCAzIC8qIENEQVRBICovLCBhbmNlc3RvcnMpO1xyXG4gICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA2IC8qIEVPRl9JTl9DREFUQSAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDb21tZW50KGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICAvLyBSZWd1bGFyIGNvbW1lbnQuXHJcbiAgICBjb25zdCBtYXRjaCA9IC8tLShcXCEpPz4vLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSg0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoKTtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNyAvKiBFT0ZfSU5fQ09NTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobWF0Y2guaW5kZXggPD0gMykge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMCAvKiBBQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMCAvKiBJTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSg0LCBtYXRjaC5pbmRleCk7XHJcbiAgICAgICAgLy8gQWR2YW5jaW5nIHdpdGggcmVwb3J0aW5nIG5lc3RlZCBjb21tZW50cy5cclxuICAgICAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xyXG4gICAgICAgIGxldCBwcmV2SW5kZXggPSAxLCBuZXN0ZWRJbmRleCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKChuZXN0ZWRJbmRleCA9IHMuaW5kZXhPZignPCEtLScsIHByZXZJbmRleCkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbmVzdGVkSW5kZXggLSBwcmV2SW5kZXggKyAxKTtcclxuICAgICAgICAgICAgaWYgKG5lc3RlZEluZGV4ICsgNCA8IHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTYgLyogTkVTVEVEX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZJbmRleCA9IG5lc3RlZEluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gcHJldkluZGV4ICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDMgLyogQ09NTUVOVCAqLyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KSB7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGNvbnRlbnRTdGFydCA9IGNvbnRleHQuc291cmNlWzFdID09PSAnPycgPyAxIDogMjtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgY29uc3QgY2xvc2VJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoJz4nKTtcclxuICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZShjb250ZW50U3RhcnQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRlbnRTdGFydCwgY2xvc2VJbmRleCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNsb3NlSW5kZXggKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMyAvKiBDT01NRU5UICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRWxlbWVudChjb250ZXh0LCBhbmNlc3RvcnMpIHtcclxuICAgIC8vIFN0YXJ0IHRhZy5cclxuICAgIGNvbnN0IHdhc0luUHJlID0gY29udGV4dC5pblByZTtcclxuICAgIGNvbnN0IHdhc0luVlByZSA9IGNvbnRleHQuaW5WUHJlO1xyXG4gICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xyXG4gICAgY29uc3QgZWxlbWVudCA9IHBhcnNlVGFnKGNvbnRleHQsIDAgLyogU3RhcnQgKi8sIHBhcmVudCk7XHJcbiAgICBjb25zdCBpc1ByZUJvdW5kYXJ5ID0gY29udGV4dC5pblByZSAmJiAhd2FzSW5QcmU7XHJcbiAgICBjb25zdCBpc1ZQcmVCb3VuZGFyeSA9IGNvbnRleHQuaW5WUHJlICYmICF3YXNJblZQcmU7XHJcbiAgICBpZiAoZWxlbWVudC5pc1NlbGZDbG9zaW5nIHx8IGNvbnRleHQub3B0aW9ucy5pc1ZvaWRUYWcoZWxlbWVudC50YWcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBDaGlsZHJlbi5cclxuICAgIGFuY2VzdG9ycy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgY29uc3QgbW9kZSA9IGNvbnRleHQub3B0aW9ucy5nZXRUZXh0TW9kZShlbGVtZW50LCBwYXJlbnQpO1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycyk7XHJcbiAgICBhbmNlc3RvcnMucG9wKCk7XHJcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAvLyBFbmQgdGFnLlxyXG4gICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKGNvbnRleHQuc291cmNlLCBlbGVtZW50LnRhZykpIHtcclxuICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIEVuZCAqLywgcGFyZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNCAvKiBYX01JU1NJTkdfRU5EX1RBRyAqLywgMCwgZWxlbWVudC5sb2Muc3RhcnQpO1xyXG4gICAgICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDAgJiYgZWxlbWVudC50YWcudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIHN0YXJ0c1dpdGgoZmlyc3QubG9jLnNvdXJjZSwgJzwhLS0nKSkge1xyXG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDggLyogRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsZW1lbnQubG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLnN0YXJ0KTtcclxuICAgIGlmIChpc1ByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVlByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59XHJcbmNvbnN0IGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBpZixlbHNlLGVsc2UtaWYsZm9yLHNsb3RgKTtcclxuLyoqXHJcbiAqIFBhcnNlIGEgdGFnIChFLmcuIGA8ZGl2IGlkPWE+YCkgd2l0aCB0aGF0IHR5cGUgKHN0YXJ0IHRhZyBvciBlbmQgdGFnKS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVGFnKGNvbnRleHQsIHR5cGUsIHBhcmVudCkge1xyXG4gICAgLy8gVGFnIG9wZW4uXHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IG1hdGNoID0gL148XFwvPyhbYS16XVteXFx0XFxyXFxuXFxmIC8+XSopL2kuZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBjb25zdCB0YWcgPSBtYXRjaFsxXTtcclxuICAgIGNvbnN0IG5zID0gY29udGV4dC5vcHRpb25zLmdldE5hbWVzcGFjZSh0YWcsIHBhcmVudCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgc3RhdGUgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlLXBhcnNlIGF0dHJpYnV0ZXMgd2l0aCB2LXByZVxyXG4gICAgY29uc3QgY3Vyc29yID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY3VycmVudFNvdXJjZSA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgLy8gQXR0cmlidXRlcy5cclxuICAgIGxldCBwcm9wcyA9IHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKTtcclxuICAgIC8vIGNoZWNrIDxwcmU+IHRhZ1xyXG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5pc1ByZVRhZyh0YWcpKSB7XHJcbiAgICAgICAgY29udGV4dC5pblByZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayB2LXByZVxyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSAmJlxyXG4gICAgICAgIHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3ByZScpKSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSB0cnVlO1xyXG4gICAgICAgIC8vIHJlc2V0IGNvbnRleHRcclxuICAgICAgICBleHRlbmQoY29udGV4dCwgY3Vyc29yKTtcclxuICAgICAgICBjb250ZXh0LnNvdXJjZSA9IGN1cnJlbnRTb3VyY2U7XHJcbiAgICAgICAgLy8gcmUtcGFyc2UgYXR0cnMgYW5kIGZpbHRlciBvdXQgdi1wcmUgaXRzZWxmXHJcbiAgICAgICAgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkuZmlsdGVyKHAgPT4gcC5uYW1lICE9PSAndi1wcmUnKTtcclxuICAgIH1cclxuICAgIC8vIFRhZyBjbG9zZS5cclxuICAgIGxldCBpc1NlbGZDbG9zaW5nID0gZmFsc2U7XHJcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDkgLyogRU9GX0lOX1RBRyAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc1NlbGZDbG9zaW5nID0gc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+Jyk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovICYmIGlzU2VsZkNsb3NpbmcpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgaXNTZWxmQ2xvc2luZyA/IDIgOiAxKTtcclxuICAgIH1cclxuICAgIGxldCB0YWdUeXBlID0gMCAvKiBFTEVNRU5UICovO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcclxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgIW9wdGlvbnMuaXNDdXN0b21FbGVtZW50KHRhZykpIHtcclxuICAgICAgICBjb25zdCBoYXNWSXMgPSBwcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdpcycpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmlzTmF0aXZlVGFnICYmICFoYXNWSXMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlzTmF0aXZlVGFnKHRhZykpXHJcbiAgICAgICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc1ZJcyB8fFxyXG4gICAgICAgICAgICBpc0NvcmVDb21wb25lbnQodGFnKSB8fFxyXG4gICAgICAgICAgICAob3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQgJiYgb3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQodGFnKSkgfHxcclxuICAgICAgICAgICAgL15bQS1aXS8udGVzdCh0YWcpIHx8XHJcbiAgICAgICAgICAgIHRhZyA9PT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFnID09PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDIgLyogU0xPVCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFnID09PSAndGVtcGxhdGUnICYmXHJcbiAgICAgICAgICAgIHByb3BzLnNvbWUocCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgaXNTcGVjaWFsVGVtcGxhdGVEaXJlY3RpdmUocC5uYW1lKSk7XHJcbiAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgIHRhZ1R5cGUgPSAzIC8qIFRFTVBMQVRFICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMSAvKiBFTEVNRU5UICovLFxyXG4gICAgICAgIG5zLFxyXG4gICAgICAgIHRhZyxcclxuICAgICAgICB0YWdUeXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGlzU2VsZkNsb3NpbmcsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSxcclxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkIC8vIHRvIGJlIGNyZWF0ZWQgZHVyaW5nIHRyYW5zZm9ybSBwaGFzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSBbXTtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xyXG4gICAgd2hpbGUgKGNvbnRleHQuc291cmNlLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAhc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJz4nKSAmJlxyXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLz4nKSkge1xyXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLycpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovKTtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAzIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXR0ciA9IHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZU5hbWVzKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBTdGFydCAqLykge1xyXG4gICAgICAgICAgICBwcm9wcy5wdXNoKGF0dHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL15bXlxcdFxcclxcblxcZiAvPl0vLnRlc3QoY29udGV4dC5zb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNSAvKiBNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZShjb250ZXh0LCBuYW1lU2V0KSB7XHJcbiAgICAvLyBOYW1lLlxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBtYXRjaCA9IC9eW15cXHRcXHJcXG5cXGYgLz5dW15cXHRcXHJcXG5cXGYgLz49XSovLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgY29uc3QgbmFtZSA9IG1hdGNoWzBdO1xyXG4gICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIgLyogRFVQTElDQVRFX0FUVFJJQlVURSAqLyk7XHJcbiAgICB9XHJcbiAgICBuYW1lU2V0LmFkZChuYW1lKTtcclxuICAgIGlmIChuYW1lWzBdID09PSAnPScpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTkgLyogVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi8pO1xyXG4gICAgfVxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAvW1wiJzxdL2c7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gcGF0dGVybi5leGVjKG5hbWUpKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTcgLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fQVRUUklCVVRFX05BTUUgKi8sIG0uaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBuYW1lLmxlbmd0aCk7XHJcbiAgICAvLyBWYWx1ZVxyXG4gICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKC9eW1xcdFxcclxcblxcZiBdKj0vLnRlc3QoY29udGV4dC5zb3VyY2UpKSB7XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICB2YWx1ZSA9IHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTMgLyogTUlTU0lOR19BVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCk7XHJcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIC9eKHYtfDp8QHwjKS8udGVzdChuYW1lKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gLyg/Ol52LShbYS16MC05LV0rKSk/KD86KD86OnxeQHxeIykoXFxbW15cXF1dK1xcXXxbXlxcLl0rKSk/KC4rKT8kL2kuZXhlYyhuYW1lKTtcclxuICAgICAgICBjb25zdCBkaXJOYW1lID0gbWF0Y2hbMV0gfHxcclxuICAgICAgICAgICAgKHN0YXJ0c1dpdGgobmFtZSwgJzonKSA/ICdiaW5kJyA6IHN0YXJ0c1dpdGgobmFtZSwgJ0AnKSA/ICdvbicgOiAnc2xvdCcpO1xyXG4gICAgICAgIGxldCBhcmc7XHJcbiAgICAgICAgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2xvdCA9IGRpck5hbWUgPT09ICdzbG90JztcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuYW1lLmluZGV4T2YobWF0Y2hbMl0pO1xyXG4gICAgICAgICAgICBjb25zdCBsb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgZ2V0TmV3UG9zaXRpb24oY29udGV4dCwgc3RhcnQsIHN0YXJ0T2Zmc2V0KSwgZ2V0TmV3UG9zaXRpb24oY29udGV4dCwgc3RhcnQsIHN0YXJ0T2Zmc2V0ICsgbWF0Y2hbMl0ubGVuZ3RoICsgKChpc1Nsb3QgJiYgbWF0Y2hbM10pIHx8ICcnKS5sZW5ndGgpKTtcclxuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBtYXRjaFsyXTtcclxuICAgICAgICAgICAgbGV0IGlzU3RhdGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGNvbnRlbnQuc3RhcnRzV2l0aCgnWycpKSB7XHJcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZW50LmVuZHNXaXRoKCddJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjYgLyogWF9NSVNTSU5HX0RZTkFNSUNfRElSRUNUSVZFX0FSR1VNRU5UX0VORCAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHIoMSwgY29udGVudC5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICAgICAgICAgIC8vICMxMjQxIHNwZWNpYWwgY2FzZSBmb3Igdi1zbG90OiB2dWV0aWZ5IHJlbGllcyBleHRlbnNpdmVseSBvbiBzbG90XHJcbiAgICAgICAgICAgICAgICAvLyBuYW1lcyBjb250YWluaW5nIGRvdHMuIHYtc2xvdCBkb2Vzbid0IGhhdmUgYW55IG1vZGlmaWVycyBhbmQgVnVlIDIueFxyXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydHMgc3VjaCB1c2FnZSBzbyB3ZSBhcmUga2VlcGluZyBpdCBjb25zaXN0ZW50IHdpdGggMi54LlxyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBtYXRjaFszXSB8fCAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmcgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpY1xyXG4gICAgICAgICAgICAgICAgICAgID8gMyAvKiBDQU5fU1RSSU5HSUZZICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgICAgIGxvY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNRdW90ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVMb2MgPSB2YWx1ZS5sb2M7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0Lm9mZnNldCsrO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zdGFydC5jb2x1bW4rKztcclxuICAgICAgICAgICAgdmFsdWVMb2MuZW5kID0gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHZhbHVlTG9jLnN0YXJ0LCB2YWx1ZS5jb250ZW50KTtcclxuICAgICAgICAgICAgdmFsdWVMb2Muc291cmNlID0gdmFsdWVMb2Muc291cmNlLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogNyAvKiBESVJFQ1RJVkUgKi8sXHJcbiAgICAgICAgICAgIG5hbWU6IGRpck5hbWUsXHJcbiAgICAgICAgICAgIGV4cDogdmFsdWUgJiYge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAvLyBUcmVhdCBhcyBub24tY29uc3RhbnQgYnkgZGVmYXVsdC4gVGhpcyBjYW4gYmUgcG90ZW50aWFsbHkgc2V0IHRvXHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB2YWx1ZXMgYnkgYHRyYW5zZm9ybUV4cHJlc3Npb25gIHRvIG1ha2UgaXQgZWxpZ2libGUgZm9yIGhvaXN0aW5nLlxyXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgICAgIGxvYzogdmFsdWUubG9jXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFyZyxcclxuICAgICAgICAgICAgbW9kaWZpZXJzOiBtYXRjaFszXSA/IG1hdGNoWzNdLnN1YnN0cigxKS5zcGxpdCgnLicpIDogW10sXHJcbiAgICAgICAgICAgIGxvY1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDYgLyogQVRUUklCVVRFICovLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGNvbnN0IHF1b3RlID0gY29udGV4dC5zb3VyY2VbMF07XHJcbiAgICBjb25zdCBpc1F1b3RlZCA9IHF1b3RlID09PSBgXCJgIHx8IHF1b3RlID09PSBgJ2A7XHJcbiAgICBpZiAoaXNRdW90ZWQpIHtcclxuICAgICAgICAvLyBRdW90ZWQgdmFsdWUuXHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihxdW90ZSk7XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBVbnF1b3RlZFxyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiA+XSsvLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdW5leHBlY3RlZENoYXJzID0gL1tcIic8PWBdL2c7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gdW5leHBlY3RlZENoYXJzLmV4ZWMobWF0Y2hbMF0pKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTggLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFICovLCBtLmluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoLCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb250ZW50LCBpc1F1b3RlZCwgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVycztcclxuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKGNsb3NlLCBvcGVuLmxlbmd0aCk7XHJcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgb3Blbi5sZW5ndGgpO1xyXG4gICAgY29uc3QgaW5uZXJTdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGlubmVyRW5kID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgcmF3Q29udGVudExlbmd0aCA9IGNsb3NlSW5kZXggLSBvcGVuLmxlbmd0aDtcclxuICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCByYXdDb250ZW50TGVuZ3RoKTtcclxuICAgIGNvbnN0IHByZVRyaW1Db250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCByYXdDb250ZW50TGVuZ3RoLCBtb2RlKTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVUcmltQ29udGVudC50cmltKCk7XHJcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IHByZVRyaW1Db250ZW50LmluZGV4T2YoY29udGVudCk7XHJcbiAgICBpZiAoc3RhcnRPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyU3RhcnQsIHJhd0NvbnRlbnQsIHN0YXJ0T2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZE9mZnNldCA9IHJhd0NvbnRlbnRMZW5ndGggLSAocHJlVHJpbUNvbnRlbnQubGVuZ3RoIC0gY29udGVudC5sZW5ndGggLSBzdGFydE9mZnNldCk7XHJcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJFbmQsIHJhd0NvbnRlbnQsIGVuZE9mZnNldCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2UubGVuZ3RoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNSAvKiBJTlRFUlBPTEFUSU9OICovLFxyXG4gICAgICAgIGNvbnRlbnQ6IHtcclxuICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyBTZXQgYGlzQ29uc3RhbnRgIHRvIGZhbHNlIGJ5IGRlZmF1bHQgYW5kIHdpbGwgZGVjaWRlIGluIHRyYW5zZm9ybUV4cHJlc3Npb25cclxuICAgICAgICAgICAgY29uc3RUeXBlOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgaW5uZXJTdGFydCwgaW5uZXJFbmQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VUZXh0KGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IGVuZFRva2VucyA9IFsnPCcsIGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzWzBdXTtcclxuICAgIGlmIChtb2RlID09PSAzIC8qIENEQVRBICovKSB7XHJcbiAgICAgICAgZW5kVG9rZW5zLnB1c2goJ11dPicpO1xyXG4gICAgfVxyXG4gICAgbGV0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmRUb2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoZW5kVG9rZW5zW2ldLCAxKTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIGVuZEluZGV4ID4gaW5kZXgpIHtcclxuICAgICAgICAgICAgZW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCBtb2RlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGV4dCBkYXRhIHdpdGggYSBnaXZlbiBsZW5ndGggZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbi5cclxuICogVGhpcyB0cmFuc2xhdGVzIEhUTUwgZW50aXRpZXMgaW4gdGhlIHRleHQgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEoY29udGV4dCwgbGVuZ3RoLCBtb2RlKSB7XHJcbiAgICBjb25zdCByYXdUZXh0ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgbGVuZ3RoKTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBsZW5ndGgpO1xyXG4gICAgaWYgKG1vZGUgPT09IDIgLyogUkFXVEVYVCAqLyB8fFxyXG4gICAgICAgIG1vZGUgPT09IDMgLyogQ0RBVEEgKi8gfHxcclxuICAgICAgICByYXdUZXh0LmluZGV4T2YoJyYnKSA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gcmF3VGV4dDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIERBVEEgb3IgUkNEQVRBIGNvbnRhaW5pbmcgXCImXCJcIi4gRW50aXR5IGRlY29kaW5nIHJlcXVpcmVkLlxyXG4gICAgICAgIHJldHVybiBjb250ZXh0Lm9wdGlvbnMuZGVjb2RlRW50aXRpZXMocmF3VGV4dCwgbW9kZSA9PT0gNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEN1cnNvcihjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH0gPSBjb250ZXh0O1xyXG4gICAgcmV0dXJuIHsgY29sdW1uLCBsaW5lLCBvZmZzZXQgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQsIGVuZCkge1xyXG4gICAgZW5kID0gZW5kIHx8IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgZW5kLFxyXG4gICAgICAgIHNvdXJjZTogY29udGV4dC5vcmlnaW5hbFNvdXJjZS5zbGljZShzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGxhc3QoeHMpIHtcclxuICAgIHJldHVybiB4c1t4cy5sZW5ndGggLSAxXTtcclxufVxyXG5mdW5jdGlvbiBzdGFydHNXaXRoKHNvdXJjZSwgc2VhcmNoU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc291cmNlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlQnkoY29udGV4dCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSB7XHJcbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gY29udGV4dDtcclxuICAgIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihjb250ZXh0LCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbiAgICBjb250ZXh0LnNvdXJjZSA9IHNvdXJjZS5zbGljZShudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGFkdmFuY2VTcGFjZXMoY29udGV4dCkge1xyXG4gICAgY29uc3QgbWF0Y2ggPSAvXltcXHRcXHJcXG5cXGYgXSsvLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV3UG9zaXRpb24oY29udGV4dCwgc3RhcnQsIG51bWJlck9mQ2hhcmFjdGVycykge1xyXG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShzdGFydCwgY29udGV4dC5vcmlnaW5hbFNvdXJjZS5zbGljZShzdGFydC5vZmZzZXQsIG51bWJlck9mQ2hhcmFjdGVycyksIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuZnVuY3Rpb24gZW1pdEVycm9yKGNvbnRleHQsIGNvZGUsIG9mZnNldCwgbG9jID0gZ2V0Q3Vyc29yKGNvbnRleHQpKSB7XHJcbiAgICBpZiAob2Zmc2V0KSB7XHJcbiAgICAgICAgbG9jLm9mZnNldCArPSBvZmZzZXQ7XHJcbiAgICAgICAgbG9jLmNvbHVtbiArPSBvZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0Lm9wdGlvbnMub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIHtcclxuICAgICAgICBzdGFydDogbG9jLFxyXG4gICAgICAgIGVuZDogbG9jLFxyXG4gICAgICAgIHNvdXJjZTogJydcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiBpc0VuZChjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcclxuICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcclxuICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBEQVRBICovOlxyXG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnPC8nKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgYmFkIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYW5jZXN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHMsIGFuY2VzdG9yc1tpXS50YWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEgLyogUkNEQVRBICovOlxyXG4gICAgICAgIGNhc2UgMiAvKiBSQVdURVhUICovOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBzdGFydHNXaXRoRW5kVGFnT3BlbihzLCBwYXJlbnQudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMyAvKiBDREFUQSAqLzpcclxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJ11dPicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiAhcztcclxufVxyXG5mdW5jdGlvbiBzdGFydHNXaXRoRW5kVGFnT3Blbihzb3VyY2UsIHRhZykge1xyXG4gICAgcmV0dXJuIChzdGFydHNXaXRoKHNvdXJjZSwgJzwvJykgJiZcclxuICAgICAgICBzb3VyY2Uuc3Vic3RyKDIsIHRhZy5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHRhZy50b0xvd2VyQ2FzZSgpICYmXHJcbiAgICAgICAgL1tcXHRcXHJcXG5cXGYgLz5dLy50ZXN0KHNvdXJjZVsyICsgdGFnLmxlbmd0aF0gfHwgJz4nKSk7XHJcbn1cblxuZnVuY3Rpb24gaG9pc3RTdGF0aWMocm9vdCwgY29udGV4dCkge1xyXG4gICAgd2Fsayhyb290LCBjb250ZXh0LCBcclxuICAgIC8vIFJvb3Qgbm9kZSBpcyB1bmZvcnR1bmF0ZWx5IG5vbi1ob2lzdGFibGUgZHVlIHRvIHBvdGVudGlhbCBwYXJlbnRcclxuICAgIC8vIGZhbGx0aHJvdWdoIGF0dHJpYnV0ZXMuXHJcbiAgICBpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIHJvb3QuY2hpbGRyZW5bMF0pKTtcclxufVxyXG5mdW5jdGlvbiBpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIGNoaWxkKSB7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xyXG4gICAgcmV0dXJuIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICBjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAhaXNTbG90T3V0bGV0KGNoaWxkKSk7XHJcbn1cclxuZnVuY3Rpb24gd2Fsayhub2RlLCBjb250ZXh0LCBkb05vdEhvaXN0Tm9kZSA9IGZhbHNlKSB7XHJcbiAgICBsZXQgaGFzSG9pc3RlZE5vZGUgPSBmYWxzZTtcclxuICAgIC8vIFNvbWUgdHJhbnNmb3JtcywgZS5nLiB0cmFuc2Zvcm1Bc3NldFVybHMgZnJvbSBAdnVlL2NvbXBpbGVyLXNmYywgcmVwbGFjZXNcclxuICAgIC8vIHN0YXRpYyBiaW5kaW5ncyB3aXRoIGV4cHJlc3Npb25zLiBUaGVzZSBleHByZXNzaW9ucyBhcmUgZ3VhcmFudGVlZCB0byBiZVxyXG4gICAgLy8gY29uc3RhbnQgc28gdGhleSBhcmUgc3RpbGwgZWxpZ2libGUgZm9yIGhvaXN0aW5nLCBidXQgdGhleSBhcmUgb25seVxyXG4gICAgLy8gYXZhaWxhYmxlIGF0IHJ1bnRpbWUgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgZXZhbHVhdGVkIGFoZWFkIG9mIHRpbWUuXHJcbiAgICAvLyBUaGlzIGlzIG9ubHkgYSBjb25jZXJuIGZvciBwcmUtc3RyaW5naWZpY2F0aW9uICh2aWEgdHJhbnNmb3JtSG9pc3QgYnlcclxuICAgIC8vIEB2dWUvY29tcGlsZXItZG9tKSwgYnV0IGRvaW5nIGl0IGhlcmUgYWxsb3dzIHVzIHRvIHBlcmZvcm0gb25seSBvbmUgZnVsbFxyXG4gICAgLy8gd2FsayBvZiB0aGUgQVNUIGFuZCBhbGxvdyBgc3RyaW5naWZ5U3RhdGljYCB0byBzdG9wIHdhbGtpbmcgYXMgc29vbiBhcyBpdHNcclxuICAgIC8vIHN0cmluZ2ZpY2lhdGlvbiB0aHJlc2hvbGQgaXMgbWV0LlxyXG4gICAgbGV0IGNhblN0cmluZ2lmeSA9IHRydWU7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBub2RlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgLy8gb25seSBwbGFpbiBlbGVtZW50cyAmIHRleHQgY2FsbHMgYXJlIGVsaWdpYmxlIGZvciBob2lzdGluZy5cclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIGNoaWxkLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBjb25zdGFudFR5cGUgPSBkb05vdEhvaXN0Tm9kZVxyXG4gICAgICAgICAgICAgICAgPyAwIC8qIE5PVF9DT05TVEFOVCAqL1xyXG4gICAgICAgICAgICAgICAgOiBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID4gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPCAzIC8qIENBTl9TVFJJTkdJRlkgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5TdHJpbmdpZnkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPj0gMiAvKiBDQU5fSE9JU1QgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZS5wYXRjaEZsYWcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSAvKiBIT0lTVEVEICovICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogSE9JU1RFRCAqL2AgOiBgYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUgPSBjb250ZXh0LmhvaXN0KGNoaWxkLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNIb2lzdGVkTm9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBjb250YWluIGR5bmFtaWMgY2hpbGRyZW4sIGJ1dCBpdHMgcHJvcHMgbWF5IGJlIGVsaWdpYmxlIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gaG9pc3RpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFmbGFnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDUxMiAvKiBORUVEX1BBVENIICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDEgLyogVEVYVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID49XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUucHJvcHMgPSBjb250ZXh0LmhvaXN0KHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMiAvKiBURVhUX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBnZXRDb25zdGFudFR5cGUoY2hpbGQuY29udGVudCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA8IDMgLyogQ0FOX1NUUklOR0lGWSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblN0cmluZ2lmeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID49IDIgLyogQ0FOX0hPSVNUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUgPSBjb250ZXh0LmhvaXN0KGNoaWxkLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNIb2lzdGVkTm9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FsayBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICB3YWxrKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBob2lzdCB2LWZvciBzaW5nbGUgY2hpbGQgYmVjYXVzZSBpdCBoYXMgdG8gYmUgYSBibG9ja1xyXG4gICAgICAgICAgICB3YWxrKGNoaWxkLCBjb250ZXh0LCBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA5IC8qIElGICovKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBob2lzdCB2LWlmIHNpbmdsZSBjaGlsZCBiZWNhdXNlIGl0IGhhcyB0byBiZSBhIGJsb2NrXHJcbiAgICAgICAgICAgICAgICB3YWxrKGNoaWxkLmJyYW5jaGVzW2ldLCBjb250ZXh0LCBjaGlsZC5icmFuY2hlc1tpXS5jaGlsZHJlbi5sZW5ndGggPT09IDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNhblN0cmluZ2lmeSAmJiBoYXNIb2lzdGVkTm9kZSAmJiBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KSB7XHJcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1Ib2lzdChjaGlsZHJlbiwgY29udGV4dCwgbm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29uc3RhbnRDYWNoZSB9ID0gY29udGV4dDtcclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgIT09IDAgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNvbnN0YW50Q2FjaGUuZ2V0KG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSAhPT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBnZXRQYXRjaEZsYWcoY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoIWZsYWcpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBpdHNlbGYgaGFzIG5vIHBhdGNoIGZsYWcuIEhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBjaGVjazpcclxuICAgICAgICAgICAgICAgIC8vIDEuIEV2ZW4gZm9yIGEgbm9kZSB3aXRoIG5vIHBhdGNoIGZsYWcsIGl0IGlzIHBvc3NpYmxlIGZvciBpdCB0byBjb250YWluXHJcbiAgICAgICAgICAgICAgICAvLyBub24taG9pc3RhYmxlIGV4cHJlc3Npb25zIHRoYXQgcmVmZXJzIHRvIHNjb3BlIHZhcmlhYmxlcywgZS5nLiBjb21waWxlclxyXG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0ZWQga2V5cyBvciBjYWNoZWQgZXZlbnQgaGFuZGxlcnMuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGNvZGVnZW5Ob2RlJ3MgcHJvcHMgdG8gYmUgc3VyZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFByb3BzVHlwZSA9IGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIE5PVF9DT05TVEFOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gZ2VuZXJhdGVkUHJvcHNUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMi4gaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY2hpbGRyZW5baV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDMuIGlmIHRoZSB0eXBlIGlzIG5vdCBhbHJlYWR5IENBTl9TS0lQX1BBVENIIHdoaWNoIGlzIHRoZSBsb3dlc3Qgbm9uLTBcclxuICAgICAgICAgICAgICAgIC8vIHR5cGUsIGNoZWNrIGlmIGFueSBvZiB0aGUgcHJvcHMgY2FuIGNhdXNlIHRoZSB0eXBlIHRvIGJlIGxvd2VyZWRcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBza2lwIGNhbl9wYXRjaCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCBieSB0aGUgYWJzZW5jZSBvZiBhXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRjaEZsYWcuXHJcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVHlwZSA+IDEgLyogQ0FOX1NLSVBfUEFUQ0ggKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ2JpbmQnICYmIHAuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKHAuZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gZXhwVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc3ZnL2ZvcmVpZ25PYmplY3QgY291bGQgYmUgYmxvY2sgaGVyZSwgaG93ZXZlciBpZiB0aGV5IGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RhdGljIHRoZW4gdGhleSBkb24ndCBuZWVkIHRvIGJlIGJsb2NrcyBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vXHJcbiAgICAgICAgICAgICAgICAvLyBuZXN0ZWQgdXBkYXRlcy5cclxuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuaXNCbG9jayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCByZXR1cm5UeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnN0VHlwZTtcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSB8fCBpc1N5bWJvbChjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgY29uc3QgcHJvcHMgPSBnZXROb2RlUHJvcHMobm9kZSk7XHJcbiAgICBpZiAocHJvcHMgJiYgcHJvcHMudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IHByb3BzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGtleVR5cGUgPSBnZXRDb25zdGFudFR5cGUoa2V5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGtleVR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBrZXlUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxufVxyXG5mdW5jdGlvbiBnZXROb2RlUHJvcHMobm9kZSkge1xyXG4gICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xyXG4gICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICByZXR1cm4gY29kZWdlbk5vZGUucHJvcHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGF0Y2hGbGFnKG5vZGUpIHtcclxuICAgIGNvbnN0IGZsYWcgPSBub2RlLnBhdGNoRmxhZztcclxuICAgIHJldHVybiBmbGFnID8gcGFyc2VJbnQoZmxhZywgMTApIDogdW5kZWZpbmVkO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgeyBmaWxlbmFtZSA9ICcnLCBwcmVmaXhJZGVudGlmaWVycyA9IGZhbHNlLCBob2lzdFN0YXRpYyA9IGZhbHNlLCBjYWNoZUhhbmRsZXJzID0gZmFsc2UsIG5vZGVUcmFuc2Zvcm1zID0gW10sIGRpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7fSwgdHJhbnNmb3JtSG9pc3QgPSBudWxsLCBpc0J1aWx0SW5Db21wb25lbnQgPSBOT09QLCBpc0N1c3RvbUVsZW1lbnQgPSBOT09QLCBleHByZXNzaW9uUGx1Z2lucyA9IFtdLCBzY29wZUlkID0gbnVsbCwgc3NyID0gZmFsc2UsIHNzckNzc1ZhcnMgPSBgYCwgYmluZGluZ01ldGFkYXRhID0gRU1QVFlfT0JKLCBpbmxpbmUgPSBmYWxzZSwgaXNUUyA9IGZhbHNlLCBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IgfSkge1xyXG4gICAgY29uc3QgbmFtZU1hdGNoID0gZmlsZW5hbWUucmVwbGFjZSgvXFw/LiokLywgJycpLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgIC8vIG9wdGlvbnNcclxuICAgICAgICBzZWxmTmFtZTogbmFtZU1hdGNoICYmIGNhcGl0YWxpemUoY2FtZWxpemUkMShuYW1lTWF0Y2hbMV0pKSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBob2lzdFN0YXRpYyxcclxuICAgICAgICBjYWNoZUhhbmRsZXJzLFxyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgdHJhbnNmb3JtSG9pc3QsXHJcbiAgICAgICAgaXNCdWlsdEluQ29tcG9uZW50LFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICBleHByZXNzaW9uUGx1Z2lucyxcclxuICAgICAgICBzY29wZUlkLFxyXG4gICAgICAgIHNzcixcclxuICAgICAgICBzc3JDc3NWYXJzLFxyXG4gICAgICAgIGJpbmRpbmdNZXRhZGF0YSxcclxuICAgICAgICBpbmxpbmUsXHJcbiAgICAgICAgaXNUUyxcclxuICAgICAgICBvbkVycm9yLFxyXG4gICAgICAgIC8vIHN0YXRlXHJcbiAgICAgICAgcm9vdCxcclxuICAgICAgICBoZWxwZXJzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgY29tcG9uZW50czogbmV3IFNldCgpLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IG5ldyBTZXQoKSxcclxuICAgICAgICBob2lzdHM6IFtdLFxyXG4gICAgICAgIGltcG9ydHM6IFtdLFxyXG4gICAgICAgIGNvbnN0YW50Q2FjaGU6IG5ldyBNYXAoKSxcclxuICAgICAgICB0ZW1wczogMCxcclxuICAgICAgICBjYWNoZWQ6IDAsXHJcbiAgICAgICAgaWRlbnRpZmllcnM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgICAgc2NvcGVzOiB7XHJcbiAgICAgICAgICAgIHZGb3I6IDAsXHJcbiAgICAgICAgICAgIHZTbG90OiAwLFxyXG4gICAgICAgICAgICB2UHJlOiAwLFxyXG4gICAgICAgICAgICB2T25jZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFyZW50OiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnROb2RlOiByb290LFxyXG4gICAgICAgIGNoaWxkSW5kZXg6IDAsXHJcbiAgICAgICAgLy8gbWV0aG9kc1xyXG4gICAgICAgIGhlbHBlcihuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5hZGQobmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGVscGVyU3RyaW5nKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBfJHtoZWxwZXJOYW1lTWFwW2NvbnRleHQuaGVscGVyKG5hbWUpXX1gO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVwbGFjZU5vZGUobm9kZSkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIGJlaW5nIHJlcGxhY2VkIGlzIGFscmVhZHkgcmVtb3ZlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXBsYWNlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnBhcmVudC5jaGlsZHJlbltjb250ZXh0LmNoaWxkSW5kZXhdID0gY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVOb2RlKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY29udGV4dC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbGlzdCA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBub2RlXHJcbiAgICAgICAgICAgICAgICA/IGxpc3QuaW5kZXhPZihub2RlKVxyXG4gICAgICAgICAgICAgICAgOiBjb250ZXh0LmN1cnJlbnROb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjb250ZXh0LmNoaWxkSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiByZW1vdmFsSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vZGUgYmVpbmcgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiBjdXJyZW50IHBhcmVudGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSBjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IG5vZGUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNpYmxpbmcgbm9kZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5jaGlsZEluZGV4ID4gcmVtb3ZhbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jaGlsZEluZGV4LS07XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHJlbW92YWxJbmRleCwgMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk5vZGVSZW1vdmVkOiAoKSA9PiB7IH0sXHJcbiAgICAgICAgYWRkSWRlbnRpZmllcnMoZXhwKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVJZGVudGlmaWVycyhleHApIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhvaXN0KGV4cCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhvaXN0cy5wdXNoKGV4cCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfaG9pc3RlZF8ke2NvbnRleHQuaG9pc3RzLmxlbmd0aH1gLCBmYWxzZSwgZXhwLmxvYywgMiAvKiBDQU5fSE9JU1QgKi8pO1xyXG4gICAgICAgICAgICBpZGVudGlmaWVyLmhvaXN0ZWQgPSBleHA7XHJcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FjaGUoZXhwLCBpc1ZOb2RlID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbigrK2NvbnRleHQuY2FjaGVkLCBleHAsIGlzVk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm0ocm9vdCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgb3B0aW9ucyk7XHJcbiAgICB0cmF2ZXJzZU5vZGUocm9vdCwgY29udGV4dCk7XHJcbiAgICBpZiAob3B0aW9ucy5ob2lzdFN0YXRpYykge1xyXG4gICAgICAgIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvcHRpb25zLnNzcikge1xyXG4gICAgICAgIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLy8gZmluYWxpemUgbWV0YSBpbmZvcm1hdGlvblxyXG4gICAgcm9vdC5oZWxwZXJzID0gWy4uLmNvbnRleHQuaGVscGVyc107XHJcbiAgICByb290LmNvbXBvbmVudHMgPSBbLi4uY29udGV4dC5jb21wb25lbnRzXTtcclxuICAgIHJvb3QuZGlyZWN0aXZlcyA9IFsuLi5jb250ZXh0LmRpcmVjdGl2ZXNdO1xyXG4gICAgcm9vdC5pbXBvcnRzID0gY29udGV4dC5pbXBvcnRzO1xyXG4gICAgcm9vdC5ob2lzdHMgPSBjb250ZXh0LmhvaXN0cztcclxuICAgIHJvb3QudGVtcHMgPSBjb250ZXh0LnRlbXBzO1xyXG4gICAgcm9vdC5jYWNoZWQgPSBjb250ZXh0LmNhY2hlZDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAvLyBpZiB0aGUgc2luZ2xlIGNoaWxkIGlzIGFuIGVsZW1lbnQsIHR1cm4gaXQgaW50byBhIGJsb2NrLlxyXG4gICAgICAgIGlmIChpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIGNoaWxkKSAmJiBjaGlsZC5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgZWxlbWVudCByb290IGlzIG5ldmVyIGhvaXN0ZWQgc28gY29kZWdlbk5vZGUgd2lsbCBuZXZlciBiZVxyXG4gICAgICAgICAgICAvLyBTaW1wbGVFeHByZXNzaW9uTm9kZVxyXG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuaXNCbG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBoZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICBoZWxwZXIoQ1JFQVRFX0JMT0NLKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY29kZWdlbk5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAtIHNpbmdsZSA8c2xvdC8+LCBJZk5vZGUsIEZvck5vZGU6IGFscmVhZHkgYmxvY2tzLlxyXG4gICAgICAgICAgICAvLyAtIHNpbmdsZSB0ZXh0IG5vZGU6IGFsd2F5cyBwYXRjaGVkLlxyXG4gICAgICAgICAgICAvLyByb290IGNvZGVnZW4gZmFsbHMgdGhyb3VnaCB2aWEgZ2VuTm9kZSgpXHJcbiAgICAgICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgLy8gcm9vdCBoYXMgbXVsdGlwbGUgbm9kZXMgLSByZXR1cm4gYSBmcmFnbWVudCBibG9jay5cclxuICAgICAgICBsZXQgcGF0Y2hGbGFnID0gNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovO1xyXG4gICAgICAgIGxldCBwYXRjaEZsYWdUZXh0ID0gUGF0Y2hGbGFnTmFtZXNbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXTtcclxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxyXG4gICAgICAgIC8vIHRoZSByZXN0IGJlaW5nIGNvbW1lbnRzXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBjaGlsZHJlbi5maWx0ZXIoYyA9PiBjLnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovO1xyXG4gICAgICAgICAgICBwYXRjaEZsYWdUZXh0ICs9IGAsICR7UGF0Y2hGbGFnTmFtZXNbMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqL119YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCB1bmRlZmluZWQsIHJvb3QuY2hpbGRyZW4sIHBhdGNoRmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7cGF0Y2hGbGFnVGV4dH0gKi9gIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIDtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZUNoaWxkcmVuKHBhcmVudCwgY29udGV4dCkge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgY29uc3Qgbm9kZVJlbW92ZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgaS0tO1xyXG4gICAgfTtcclxuICAgIGZvciAoOyBpIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29udGV4dC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgY29udGV4dC5jaGlsZEluZGV4ID0gaTtcclxuICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQgPSBub2RlUmVtb3ZlZDtcclxuICAgICAgICB0cmF2ZXJzZU5vZGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgIC8vIGFwcGx5IHRyYW5zZm9ybSBwbHVnaW5zXHJcbiAgICBjb25zdCB7IG5vZGVUcmFuc2Zvcm1zIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgZXhpdEZucyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9uRXhpdCA9IG5vZGVUcmFuc2Zvcm1zW2ldKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChvbkV4aXQpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkob25FeGl0KSkge1xyXG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKC4uLm9uRXhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgLy8gbm9kZSB3YXMgcmVtb3ZlZFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBub2RlIG1heSBoYXZlIGJlZW4gcmVwbGFjZWRcclxuICAgICAgICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDMgLyogQ09NTUVOVCAqLzpcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzcikge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0IGltcG9ydCBmb3IgdGhlIENvbW1lbnQgc3ltYm9sLCB3aGljaCBpcyBuZWVkZWQgZm9yIGNyZWF0aW5nXHJcbiAgICAgICAgICAgICAgICAvLyBjb21tZW50IG5vZGVzIHdpdGggYGNyZWF0ZVZOb2RlYFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoQ1JFQVRFX0NPTU1FTlQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHRyYXZlcnNlLCBidXQgd2UgbmVlZCB0byBpbmplY3QgdG9TdHJpbmcgaGVscGVyXHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKFRPX0RJU1BMQVlfU1RSSU5HKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBmb3IgY29udGFpbmVyIHR5cGVzLCBmdXJ0aGVyIHRyYXZlcnNlIGRvd253YXJkc1xyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmJyYW5jaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5icmFuY2hlc1tpXSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgY2FzZSAwIC8qIFJPT1QgKi86XHJcbiAgICAgICAgICAgIHRyYXZlcnNlQ2hpbGRyZW4obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgLy8gZXhpdCB0cmFuc2Zvcm1zXHJcbiAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgIGxldCBpID0gZXhpdEZucy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgZXhpdEZuc1tpXSgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0obmFtZSwgZm4pIHtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBpc1N0cmluZyhuYW1lKVxyXG4gICAgICAgID8gKG4pID0+IG4gPT09IG5hbWVcclxuICAgICAgICA6IChuKSA9PiBuYW1lLnRlc3Qobik7XHJcbiAgICByZXR1cm4gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gbm9kZTtcclxuICAgICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmUgdHJhbnNmb3JtcyBhcmUgbm90IGNvbmNlcm5lZCB3aXRoIHNsb3RzXHJcbiAgICAgICAgICAgIC8vIGFzIHRoZXkgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSBpbiB2U2xvdC50c1xyXG4gICAgICAgICAgICBpZiAobm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovICYmIHByb3BzLnNvbWUoaXNWU2xvdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBleGl0Rm5zID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIG1hdGNoZXMocHJvcC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBhcmUgcmVtb3ZlZCB0byBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cclxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHdlIHJlbW92ZSB0aGVtICpiZWZvcmUqIGFwcGx5aW5nIHNvIHRoYXQgaXQgY2FuIGZ1cnRoZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmF2ZXJzZSBpdHNlbGYgaW4gY2FzZSBpdCBtb3ZlcyB0aGUgbm9kZSBhcm91bmRcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IGZuKG5vZGUsIHByb3AsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkV4aXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaChvbkV4aXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBleGl0Rm5zO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuY29uc3QgUFVSRV9BTk5PVEFUSU9OID0gYC8qI19fUFVSRV9fKi9gO1xyXG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIHsgbW9kZSA9ICdmdW5jdGlvbicsIHByZWZpeElkZW50aWZpZXJzID0gbW9kZSA9PT0gJ21vZHVsZScsIHNvdXJjZU1hcCA9IGZhbHNlLCBmaWxlbmFtZSA9IGB0ZW1wbGF0ZS52dWUuaHRtbGAsIHNjb3BlSWQgPSBudWxsLCBvcHRpbWl6ZUltcG9ydHMgPSBmYWxzZSwgcnVudGltZUdsb2JhbE5hbWUgPSBgVnVlYCwgcnVudGltZU1vZHVsZU5hbWUgPSBgdnVlYCwgc3NyID0gZmFsc2UgfSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICBtb2RlLFxyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxyXG4gICAgICAgIHNvdXJjZU1hcCxcclxuICAgICAgICBmaWxlbmFtZSxcclxuICAgICAgICBzY29wZUlkLFxyXG4gICAgICAgIG9wdGltaXplSW1wb3J0cyxcclxuICAgICAgICBydW50aW1lR2xvYmFsTmFtZSxcclxuICAgICAgICBydW50aW1lTW9kdWxlTmFtZSxcclxuICAgICAgICBzc3IsXHJcbiAgICAgICAgc291cmNlOiBhc3QubG9jLnNvdXJjZSxcclxuICAgICAgICBjb2RlOiBgYCxcclxuICAgICAgICBjb2x1bW46IDEsXHJcbiAgICAgICAgbGluZTogMSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgaW5kZW50TGV2ZWw6IDAsXHJcbiAgICAgICAgcHVyZTogZmFsc2UsXHJcbiAgICAgICAgbWFwOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaGVscGVyKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBba2V5XX1gO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVzaChjb2RlLCBub2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY29kZSArPSBjb2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5kZW50KCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCsrY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWluZGVudCh3aXRob3V0TmV3TGluZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0TmV3TGluZSkge1xyXG4gICAgICAgICAgICAgICAgLS1jb250ZXh0LmluZGVudExldmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3bGluZSgtLWNvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXdsaW5lKCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKGNvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBuZXdsaW5lKG4pIHtcclxuICAgICAgICBjb250ZXh0LnB1c2goJ1xcbicgKyBgICBgLnJlcGVhdChuKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgb3B0aW9ucyk7XHJcbiAgICBpZiAob3B0aW9ucy5vbkNvbnRleHRDcmVhdGVkKVxyXG4gICAgICAgIG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZChjb250ZXh0KTtcclxuICAgIGNvbnN0IHsgbW9kZSwgcHVzaCwgcHJlZml4SWRlbnRpZmllcnMsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUsIHNjb3BlSWQsIHNzciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGhhc0hlbHBlcnMgPSBhc3QuaGVscGVycy5sZW5ndGggPiAwO1xyXG4gICAgY29uc3QgdXNlV2l0aEJsb2NrID0gIXByZWZpeElkZW50aWZpZXJzICYmIG1vZGUgIT09ICdtb2R1bGUnO1xyXG4gICAgLy8gcHJlYW1ibGVzXHJcbiAgICAvLyBpbiBzZXR1cCgpIGlubGluZSBtb2RlLCB0aGUgcHJlYW1ibGUgaXMgZ2VuZXJhdGVkIGluIGEgc3ViIGNvbnRleHRcclxuICAgIC8vIGFuZCByZXR1cm5lZCBzZXBhcmF0ZWx5LlxyXG4gICAgY29uc3QgcHJlYW1ibGVDb250ZXh0ID0gY29udGV4dDtcclxuICAgIHtcclxuICAgICAgICBnZW5GdW5jdGlvblByZWFtYmxlKGFzdCwgcHJlYW1ibGVDb250ZXh0KTtcclxuICAgIH1cclxuICAgIC8vIGVudGVyIHJlbmRlciBmdW5jdGlvblxyXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gc3NyID8gYHNzclJlbmRlcmAgOiBgcmVuZGVyYDtcclxuICAgIGNvbnN0IGFyZ3MgPSBzc3IgPyBbJ19jdHgnLCAnX3B1c2gnLCAnX3BhcmVudCcsICdfYXR0cnMnXSA6IFsnX2N0eCcsICdfY2FjaGUnXTtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFyZ3Muam9pbignLCAnKTtcclxuICAgIHtcclxuICAgICAgICBwdXNoKGBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oJHtzaWduYXR1cmV9KSB7YCk7XHJcbiAgICB9XHJcbiAgICBpbmRlbnQoKTtcclxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgICAgICBwdXNoKGB3aXRoIChfY3R4KSB7YCk7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICAgICAgLy8gZnVuY3Rpb24gbW9kZSBjb25zdCBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIGluc2lkZSB3aXRoIGJsb2NrXHJcbiAgICAgICAgLy8gYWxzbyB0aGV5IHNob3VsZCBiZSByZW5hbWVkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHVzZXIgcHJvcGVydGllc1xyXG4gICAgICAgIGlmIChoYXNIZWxwZXJzKSB7XHJcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHthc3QuaGVscGVyc1xyXG4gICAgICAgICAgICAgICAgLm1hcChzID0+IGAke2hlbHBlck5hbWVNYXBbc119OiBfJHtoZWxwZXJOYW1lTWFwW3NdfWApXHJcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gfSA9IF9WdWVgKTtcclxuICAgICAgICAgICAgcHVzaChgXFxuYCk7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBnZW5lcmF0ZSBhc3NldCByZXNvbHV0aW9uIHN0YXRlbWVudHNcclxuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBnZW5Bc3NldHMoYXN0LmNvbXBvbmVudHMsICdjb21wb25lbnQnLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGgpIHtcclxuICAgICAgICBnZW5Bc3NldHMoYXN0LmRpcmVjdGl2ZXMsICdkaXJlY3RpdmUnLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICBwdXNoKGBsZXQgYCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudGVtcHM7IGkrKykge1xyXG4gICAgICAgICAgICBwdXNoKGAke2kgPiAwID8gYCwgYCA6IGBgfV90ZW1wJHtpfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGggfHwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcykge1xyXG4gICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIC8vIGdlbmVyYXRlIHRoZSBWTm9kZSB0cmVlIGV4cHJlc3Npb25cclxuICAgIGlmICghc3NyKSB7XHJcbiAgICAgICAgcHVzaChgcmV0dXJuIGApO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgIGdlbk5vZGUoYXN0LmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYG51bGxgKTtcclxuICAgIH1cclxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGRlaW5kZW50KCk7XHJcbiAgICBwdXNoKGB9YCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFzdCxcclxuICAgICAgICBjb2RlOiBjb250ZXh0LmNvZGUsXHJcbiAgICAgICAgcHJlYW1ibGU6IGBgLFxyXG4gICAgICAgIC8vIFNvdXJjZU1hcEdlbmVyYXRvciBkb2VzIGhhdmUgdG9KU09OKCkgbWV0aG9kIGJ1dCBpdCdzIG5vdCBpbiB0aGUgdHlwZXNcclxuICAgICAgICBtYXA6IGNvbnRleHQubWFwID8gY29udGV4dC5tYXAudG9KU09OKCkgOiB1bmRlZmluZWRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgc3NyLCBwcmVmaXhJZGVudGlmaWVycywgcHVzaCwgbmV3bGluZSwgcnVudGltZU1vZHVsZU5hbWUsIHJ1bnRpbWVHbG9iYWxOYW1lIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgVnVlQmluZGluZyA9IHJ1bnRpbWVHbG9iYWxOYW1lO1xyXG4gICAgY29uc3QgYWxpYXNIZWxwZXIgPSAocykgPT4gYCR7aGVscGVyTmFtZU1hcFtzXX06IF8ke2hlbHBlck5hbWVNYXBbc119YDtcclxuICAgIC8vIEdlbmVyYXRlIGNvbnN0IGRlY2xhcmF0aW9uIGZvciBoZWxwZXJzXHJcbiAgICAvLyBJbiBwcmVmaXggbW9kZSwgd2UgcGxhY2UgdGhlIGNvbnN0IGRlY2xhcmF0aW9uIGF0IHRvcCBzbyBpdCdzIGRvbmVcclxuICAgIC8vIG9ubHkgb25jZTsgQnV0IGlmIHdlIG5vdCBwcmVmaXhpbmcsIHdlIHBsYWNlIHRoZSBkZWNsYXJhdGlvbiBpbnNpZGUgdGhlXHJcbiAgICAvLyB3aXRoIGJsb2NrIHNvIGl0IGRvZXNuJ3QgaW5jdXIgdGhlIGBpbmAgY2hlY2sgY29zdCBmb3IgZXZlcnkgaGVscGVyIGFjY2Vzcy5cclxuICAgIGlmIChhc3QuaGVscGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBcIndpdGhcIiBtb2RlLlxyXG4gICAgICAgICAgICAvLyBzYXZlIFZ1ZSBpbiBhIHNlcGFyYXRlIHZhcmlhYmxlIHRvIGF2b2lkIGNvbGxpc2lvblxyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfVnVlID0gJHtWdWVCaW5kaW5nfVxcbmApO1xyXG4gICAgICAgICAgICAvLyBpbiBcIndpdGhcIiBtb2RlLCBoZWxwZXJzIGFyZSBkZWNsYXJlZCBpbnNpZGUgdGhlIHdpdGggYmxvY2sgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gaGFzIGNoZWNrIGNvc3QsIGJ1dCBob2lzdHMgYXJlIGxpZnRlZCBvdXQgb2YgdGhlIGZ1bmN0aW9uIC0gd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBwcm92aWRlIHRoZSBoZWxwZXIgaGVyZS5cclxuICAgICAgICAgICAgaWYgKGFzdC5ob2lzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0aWNIZWxwZXJzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9WTk9ERSxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfQ09NTUVOVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVEVYVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfU1RBVElDXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihoZWxwZXIgPT4gYXN0LmhlbHBlcnMuaW5jbHVkZXMoaGVscGVyKSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFsaWFzSGVscGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgcHVzaChgY29uc3QgeyAke3N0YXRpY0hlbHBlcnN9IH0gPSBfVnVlXFxuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZW5Ib2lzdHMoYXN0LmhvaXN0cywgY29udGV4dCk7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBwdXNoKGByZXR1cm4gYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXNzZXRzKGFzc2V0cywgdHlwZSwgeyBoZWxwZXIsIHB1c2gsIG5ld2xpbmUgfSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZXIgPSBoZWxwZXIodHlwZSA9PT0gJ2NvbXBvbmVudCcgPyBSRVNPTFZFX0NPTVBPTkVOVCA6IFJFU09MVkVfRElSRUNUSVZFKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBhc3NldHNbaV07XHJcbiAgICAgICAgcHVzaChgY29uc3QgJHt0b1ZhbGlkQXNzZXRJZChpZCwgdHlwZSl9ID0gJHtyZXNvbHZlcn0oJHtKU09OLnN0cmluZ2lmeShpZCl9KWApO1xyXG4gICAgICAgIGlmIChpIDwgYXNzZXRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Ib2lzdHMoaG9pc3RzLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWhvaXN0cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LnB1cmUgPSB0cnVlO1xyXG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lLCBoZWxwZXIsIHNjb3BlSWQsIG1vZGUgfSA9IGNvbnRleHQ7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBob2lzdHMuZm9yRWFjaCgoZXhwLCBpKSA9PiB7XHJcbiAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfaG9pc3RlZF8ke2kgKyAxfSA9IGApO1xyXG4gICAgICAgICAgICBnZW5Ob2RlKGV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnRleHQucHVyZSA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dCQxKG4pIHtcclxuICAgIHJldHVybiAoaXNTdHJpbmcobikgfHxcclxuICAgICAgICBuLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDIgLyogVEVYVCAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGVMaXN0QXNBcnJheShub2RlcywgY29udGV4dCkge1xyXG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IG5vZGVzLmxlbmd0aCA+IDMgfHxcclxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiYgbm9kZXMuc29tZShuID0+IGlzQXJyYXkobikgfHwgIWlzVGV4dCQxKG4pKSk7XHJcbiAgICBjb250ZXh0LnB1c2goYFtgKTtcclxuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5pbmRlbnQoKTtcclxuICAgIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzKTtcclxuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5kZWluZGVudCgpO1xyXG4gICAgY29udGV4dC5wdXNoKGBdYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMgPSBmYWxzZSwgY29tbWEgPSB0cnVlKSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgICAgICBwdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdGlsaW5lcykge1xyXG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgIGNvbnRleHQucHVzaChub2RlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTeW1ib2wobm9kZSkpIHtcclxuICAgICAgICBjb250ZXh0LnB1c2goY29udGV4dC5oZWxwZXIobm9kZSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGFzc2VydChub2RlLmNvZGVnZW5Ob2RlICE9IG51bGwsIGBDb2RlZ2VuIG5vZGUgaXMgbWlzc2luZyBmb3IgZWxlbWVudC9pZi9mb3Igbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuYCk7XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZS5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgICAgICBnZW5UZXh0KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgICAgICBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEyIC8qIFRFWFRfQ0FMTCAqLzpcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTMgLyogVk5PREVfQ0FMTCAqLzpcclxuICAgICAgICAgICAgZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE4IC8qIEpTX0ZVTkNUSU9OX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5Db25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBTU1Igb25seSB0eXBlc1xyXG4gICAgICAgIGNhc2UgMjEgLyogSlNfQkxPQ0tfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjMgLyogSlNfSUZfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI0IC8qIEpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI2IC8qIEpTX1JFVFVSTl9TVEFURU1FTlQgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIC8vIG5vb3BcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5oYW5kbGVkIGNvZGVnZW4gbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBleGhhdXN0IGFsbCBwb3NzaWJsZSB0eXBlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGhhdXN0aXZlQ2hlY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQucHVzaChKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29udGVudCwgaXNTdGF0aWMgfSA9IG5vZGU7XHJcbiAgICBjb250ZXh0LnB1c2goaXNTdGF0aWMgPyBKU09OLnN0cmluZ2lmeShjb250ZW50KSA6IGNvbnRlbnQsIG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAocHVyZSlcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICBwdXNoKGAke2hlbHBlcihUT19ESVNQTEFZX1NUUklORyl9KGApO1xyXG4gICAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkV4cHJlc3Npb25Bc1Byb3BlcnR5S2V5KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIHB1c2goYFtgKTtcclxuICAgICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgXWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS5pc1N0YXRpYykge1xyXG4gICAgICAgIC8vIG9ubHkgcXVvdGUga2V5cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudClcclxuICAgICAgICAgICAgPyBub2RlLmNvbnRlbnRcclxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpO1xyXG4gICAgICAgIHB1c2godGV4dCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdXNoKGBbJHtub2RlLmNvbnRlbnR9XWAsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoQ1JFQVRFX0NPTU1FTlQpfSgke0pTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCl9KWAsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlblZOb2RlQ2FsbChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBkaXJlY3RpdmVzLCBpc0Jsb2NrLCBkaXNhYmxlVHJhY2tpbmcgfSA9IG5vZGU7XHJcbiAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgIHB1c2goaGVscGVyKFdJVEhfRElSRUNUSVZFUykgKyBgKGApO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgICBwdXNoKGAoJHtoZWxwZXIoT1BFTl9CTE9DSyl9KCR7ZGlzYWJsZVRyYWNraW5nID8gYHRydWVgIDogYGB9KSwgYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIHB1c2goaGVscGVyKGlzQmxvY2sgPyBDUkVBVEVfQkxPQ0sgOiBDUkVBVEVfVk5PREUpICsgYChgLCBub2RlKTtcclxuICAgIGdlbk5vZGVMaXN0KGdlbk51bGxhYmxlQXJncyhbdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzXSksIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG4gICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgICBwdXNoKGApYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgIHB1c2goYCwgYCk7XHJcbiAgICAgICAgZ2VuTm9kZShkaXJlY3RpdmVzLCBjb250ZXh0KTtcclxuICAgICAgICBwdXNoKGApYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuTnVsbGFibGVBcmdzKGFyZ3MpIHtcclxuICAgIGxldCBpID0gYXJncy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbaV0gIT0gbnVsbClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJncy5zbGljZSgwLCBpICsgMSkubWFwKGFyZyA9PiBhcmcgfHwgYG51bGxgKTtcclxufVxyXG4vLyBKYXZhU2NyaXB0XHJcbmZ1bmN0aW9uIGdlbkNhbGxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgY2FsbGVlID0gaXNTdHJpbmcobm9kZS5jYWxsZWUpID8gbm9kZS5jYWxsZWUgOiBoZWxwZXIobm9kZS5jYWxsZWUpO1xyXG4gICAgaWYgKHB1cmUpIHtcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICB9XHJcbiAgICBwdXNoKGNhbGxlZSArIGAoYCwgbm9kZSk7XHJcbiAgICBnZW5Ob2RlTGlzdChub2RlLmFyZ3VtZW50cywgY29udGV4dCk7XHJcbiAgICBwdXNoKGApYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IG5vZGU7XHJcbiAgICBpZiAoIXByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHVzaChge31gLCBub2RlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBtdWx0aWxpbmVzID0gcHJvcGVydGllcy5sZW5ndGggPiAxIHx8XHJcbiAgICAgICAgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpICYmXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc29tZShwID0+IHAudmFsdWUudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykpO1xyXG4gICAgcHVzaChtdWx0aWxpbmVzID8gYHtgIDogYHsgYCk7XHJcbiAgICBtdWx0aWxpbmVzICYmIGluZGVudCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIC8vIGtleVxyXG4gICAgICAgIGdlbkV4cHJlc3Npb25Bc1Byb3BlcnR5S2V5KGtleSwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgOiBgKTtcclxuICAgICAgICAvLyB2YWx1ZVxyXG4gICAgICAgIGdlbk5vZGUodmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIC8vIHdpbGwgb25seSByZWFjaCB0aGlzIGlmIGl0J3MgbXVsdGlsaW5lc1xyXG4gICAgICAgICAgICBwdXNoKGAsYCk7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtdWx0aWxpbmVzICYmIGRlaW5kZW50KCk7XHJcbiAgICBwdXNoKG11bHRpbGluZXMgPyBgfWAgOiBgIH1gKTtcclxufVxyXG5mdW5jdGlvbiBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUuZWxlbWVudHMsIGNvbnRleHQpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQsIHNjb3BlSWQsIG1vZGUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHBhcmFtcywgcmV0dXJucywgYm9keSwgbmV3bGluZSwgaXNTbG90IH0gPSBub2RlO1xyXG4gICAgaWYgKGlzU2xvdCkge1xyXG4gICAgICAgIHB1c2goYF8ke2hlbHBlck5hbWVNYXBbV0lUSF9DVFhdfShgKTtcclxuICAgIH1cclxuICAgIHB1c2goYChgLCBub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHBhcmFtcykpIHtcclxuICAgICAgICBnZW5Ob2RlTGlzdChwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgZ2VuTm9kZShwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKSA9PiBgKTtcclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBwdXNoKGB7YCk7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmV0dXJucykge1xyXG4gICAgICAgIGlmIChuZXdsaW5lKSB7XHJcbiAgICAgICAgICAgIHB1c2goYHJldHVybiBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmV0dXJucykpIHtcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KHJldHVybnMsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShyZXR1cm5zLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChib2R5KSB7XHJcbiAgICAgICAgZ2VuTm9kZShib2R5LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICBwdXNoKGApYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBuZXdsaW5lOiBuZWVkTmV3bGluZSB9ID0gbm9kZTtcclxuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIGlmICh0ZXN0LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBjb25zdCBuZWVkc1BhcmVucyA9ICFpc1NpbXBsZUlkZW50aWZpZXIodGVzdC5jb250ZW50KTtcclxuICAgICAgICBuZWVkc1BhcmVucyAmJiBwdXNoKGAoYCk7XHJcbiAgICAgICAgZ2VuRXhwcmVzc2lvbih0ZXN0LCBjb250ZXh0KTtcclxuICAgICAgICBuZWVkc1BhcmVucyAmJiBwdXNoKGApYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdXNoKGAoYCk7XHJcbiAgICAgICAgZ2VuTm9kZSh0ZXN0LCBjb250ZXh0KTtcclxuICAgICAgICBwdXNoKGApYCk7XHJcbiAgICB9XHJcbiAgICBuZWVkTmV3bGluZSAmJiBpbmRlbnQoKTtcclxuICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcclxuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcclxuICAgIHB1c2goYD8gYCk7XHJcbiAgICBnZW5Ob2RlKGNvbnNlcXVlbnQsIGNvbnRleHQpO1xyXG4gICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xyXG4gICAgbmVlZE5ld2xpbmUgJiYgbmV3bGluZSgpO1xyXG4gICAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xyXG4gICAgcHVzaChgOiBgKTtcclxuICAgIGNvbnN0IGlzTmVzdGVkID0gYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi87XHJcbiAgICBpZiAoIWlzTmVzdGVkKSB7XHJcbiAgICAgICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xyXG4gICAgfVxyXG4gICAgZ2VuTm9kZShhbHRlcm5hdGUsIGNvbnRleHQpO1xyXG4gICAgaWYgKCFpc05lc3RlZCkge1xyXG4gICAgICAgIGNvbnRleHQuaW5kZW50TGV2ZWwtLTtcclxuICAgIH1cclxuICAgIG5lZWROZXdsaW5lICYmIGRlaW5kZW50KHRydWUgLyogd2l0aG91dCBuZXdsaW5lICovKTtcclxufVxyXG5mdW5jdGlvbiBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBwdXNoKGBfY2FjaGVbJHtub2RlLmluZGV4fV0gfHwgKGApO1xyXG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xyXG4gICAgICAgIGluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYCR7aGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyl9KC0xKSxgKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGBfY2FjaGVbJHtub2RlLmluZGV4fV0gPSBgKTtcclxuICAgIGdlbk5vZGUobm9kZS52YWx1ZSwgY29udGV4dCk7XHJcbiAgICBpZiAobm9kZS5pc1ZOb2RlKSB7XHJcbiAgICAgICAgcHVzaChgLGApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgxKSxgKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dYCk7XHJcbiAgICAgICAgZGVpbmRlbnQoKTtcclxuICAgIH1cclxuICAgIHB1c2goYClgKTtcclxufVxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxyXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXHJcbmNvbnN0IHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgK1xyXG4gICAgKCdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xyXG4gICAgICAgICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXHJcbiAgICAgICAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMsdHlwZW9mLHZvaWQnKVxyXG4gICAgICAgIC5zcGxpdCgnLCcpXHJcbiAgICAgICAgLmpvaW4oJ1xcXFxifFxcXFxiJykgK1xyXG4gICAgJ1xcXFxiJyk7XHJcbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcclxuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xyXG4vKipcclxuICogVmFsaWRhdGUgYSBub24tcHJlZml4ZWQgZXhwcmVzc2lvbi5cclxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCB3aGVuIHVzaW5nIHRoZSBpbi1icm93c2VyIHJ1bnRpbWUgY29tcGlsZXIgc2luY2UgaXRcclxuICogZG9lc24ndCBwcmVmaXggZXhwcmVzc2lvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIGFzUGFyYW1zID0gZmFsc2UsIGFzUmF3U3RhdGVtZW50cyA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBleHAgPSBub2RlLmNvbnRlbnQ7XHJcbiAgICAvLyBlbXB0eSBleHByZXNzaW9ucyBhcmUgdmFsaWRhdGVkIHBlci1kaXJlY3RpdmUgc2luY2Ugc29tZSBkaXJlY3RpdmVzXHJcbiAgICAvLyBkbyBhbGxvdyBlbXB0eSBleHByZXNzaW9ucy5cclxuICAgIGlmICghZXhwLnRyaW0oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgbmV3IEZ1bmN0aW9uKGFzUmF3U3RhdGVtZW50c1xyXG4gICAgICAgICAgICA/IGAgJHtleHB9IGBcclxuICAgICAgICAgICAgOiBgcmV0dXJuICR7YXNQYXJhbXMgPyBgKCR7ZXhwfSkgPT4ge31gIDogYCgke2V4cH0pYH1gKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBlLm1lc3NhZ2U7XHJcbiAgICAgICAgY29uc3Qga2V5d29yZE1hdGNoID0gZXhwXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKVxyXG4gICAgICAgICAgICAubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XHJcbiAgICAgICAgaWYgKGtleXdvcmRNYXRjaCkge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiR7a2V5d29yZE1hdGNoWzBdfVwiYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDMgLyogWF9JTlZBTElEX0VYUFJFU1NJT04gKi8sIG5vZGUubG9jLCB1bmRlZmluZWQsIG1lc3NhZ2UpKTtcclxuICAgIH1cclxufVxuXG5jb25zdCB0cmFuc2Zvcm1FeHByZXNzaW9uID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLykge1xyXG4gICAgICAgIG5vZGUuY29udGVudCA9IHByb2Nlc3NFeHByZXNzaW9uKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgIC8vIGhhbmRsZSBkaXJlY3RpdmVzIG9uIGVsZW1lbnRcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGlyID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgLy8gZG8gbm90IHByb2Nlc3MgZm9yIHYtb24gJiB2LWZvciBzaW5jZSB0aGV5IGFyZSBzcGVjaWFsIGhhbmRsZWRcclxuICAgICAgICAgICAgaWYgKGRpci50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBkaXIubmFtZSAhPT0gJ2ZvcicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cCA9IGRpci5leHA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBkaXIuYXJnO1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHByb2Nlc3MgZXhwIGlmIHRoaXMgaXMgdi1vbjphcmcgLSB3ZSBuZWVkIHNwZWNpYWwgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgIC8vIGZvciB3cmFwcGluZyBpbmxpbmUgc3RhdGVtZW50cy5cclxuICAgICAgICAgICAgICAgIGlmIChleHAgJiZcclxuICAgICAgICAgICAgICAgICAgICBleHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICEoZGlyLm5hbWUgPT09ICdvbicgJiYgYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpci5leHAgPSBwcm9jZXNzRXhwcmVzc2lvbihleHAsIGNvbnRleHQsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNsb3QgYXJncyBtdXN0IGJlIHByb2Nlc3NlZCBhcyBmdW5jdGlvbiBwYXJhbXNcclxuICAgICAgICAgICAgICAgICAgICBkaXIubmFtZSA9PT0gJ3Nsb3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgIWFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpci5hcmcgPSBwcm9jZXNzRXhwcmVzc2lvbihhcmcsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vLyBJbXBvcnRhbnQ6IHNpbmNlIHRoaXMgZnVuY3Rpb24gdXNlcyBOb2RlLmpzIG9ubHkgZGVwZW5kZW5jaWVzLCBpdCBzaG91bGRcclxuLy8gYWx3YXlzIGJlIHVzZWQgd2l0aCBhIGxlYWRpbmcgIXRydWUgY2hlY2sgc28gdGhhdCBpdCBjYW4gYmVcclxuLy8gdHJlZS1zaGFrZW4gZnJvbSB0aGUgYnJvd3NlciBidWlsZC5cclxuZnVuY3Rpb24gcHJvY2Vzc0V4cHJlc3Npb24obm9kZSwgY29udGV4dCwgXHJcbi8vIHNvbWUgZXhwcmVzc2lvbnMgbGlrZSB2LXNsb3QgcHJvcHMgJiB2LWZvciBhbGlhc2VzIHNob3VsZCBiZSBwYXJzZWQgYXNcclxuLy8gZnVuY3Rpb24gcGFyYW1zXHJcbmFzUGFyYW1zID0gZmFsc2UsIFxyXG4vLyB2LW9uIGhhbmRsZXIgdmFsdWVzIG1heSBjb250YWluIG11bHRpcGxlIHN0YXRlbWVudHNcclxuYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UpIHtcclxuICAgIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbXBsZSBpbi1icm93c2VyIHZhbGlkYXRpb24gKHNhbWUgbG9naWMgaW4gMi54KVxyXG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIGFzUGFyYW1zLCBhc1Jhd1N0YXRlbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxufVxuXG5jb25zdCB0cmFuc2Zvcm1JZiA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oL14oaWZ8ZWxzZXxlbHNlLWlmKSQvLCAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XHJcbiAgICByZXR1cm4gcHJvY2Vzc0lmKG5vZGUsIGRpciwgY29udGV4dCwgKGlmTm9kZSwgYnJhbmNoLCBpc1Jvb3QpID0+IHtcclxuICAgICAgICAvLyAjMTU4NzogV2UgbmVlZCB0byBkeW5hbWljYWxseSBpbmNyZW1lbnQgdGhlIGtleSBiYXNlZCBvbiB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vIG5vZGUncyBzaWJsaW5nIG5vZGVzLCBzaW5jZSBjaGFpbmVkIHYtaWYvZWxzZSBicmFuY2hlcyBhcmVcclxuICAgICAgICAvLyByZW5kZXJlZCBhdCB0aGUgc2FtZSBkZXB0aFxyXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgbGV0IGkgPSBzaWJsaW5ncy5pbmRleE9mKGlmTm9kZSk7XHJcbiAgICAgICAgbGV0IGtleSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGktLSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy50eXBlID09PSA5IC8qIElGICovKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgKz0gc2libGluZy5icmFuY2hlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXhpdCBjYWxsYmFjay4gQ29tcGxldGUgdGhlIGNvZGVnZW5Ob2RlIHdoZW4gYWxsIGNoaWxkcmVuIGhhdmUgYmVlblxyXG4gICAgICAgIC8vIHRyYW5zZm9ybWVkLlxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgIGlmTm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCB0aGlzIGJyYW5jaCdzIGNvZGVnZW4gbm9kZSB0byB0aGUgdi1pZiByb290LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q29uZGl0aW9uID0gZ2V0UGFyZW50Q29uZGl0aW9uKGlmTm9kZS5jb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25kaXRpb24uYWx0ZXJuYXRlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXkgKyBpZk5vZGUuYnJhbmNoZXMubGVuZ3RoIC0gMSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn0pO1xyXG4vLyB0YXJnZXQtYWdub3N0aWMgdHJhbnNmb3JtIHVzZWQgZm9yIGJvdGggQ2xpZW50IGFuZCBTU1JcclxuZnVuY3Rpb24gcHJvY2Vzc0lmKG5vZGUsIGRpciwgY29udGV4dCwgcHJvY2Vzc0NvZGVnZW4pIHtcclxuICAgIGlmIChkaXIubmFtZSAhPT0gJ2Vsc2UnICYmXHJcbiAgICAgICAgKCFkaXIuZXhwIHx8ICFkaXIuZXhwLmNvbnRlbnQudHJpbSgpKSkge1xyXG4gICAgICAgIGNvbnN0IGxvYyA9IGRpci5leHAgPyBkaXIuZXhwLmxvYyA6IG5vZGUubG9jO1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI3IC8qIFhfVl9JRl9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgZGlyLmV4cCA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSAmJiBkaXIuZXhwKSB7XHJcbiAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihkaXIuZXhwLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChkaXIubmFtZSA9PT0gJ2lmJykge1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XHJcbiAgICAgICAgY29uc3QgaWZOb2RlID0ge1xyXG4gICAgICAgICAgICB0eXBlOiA5IC8qIElGICovLFxyXG4gICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxyXG4gICAgICAgICAgICBicmFuY2hlczogW2JyYW5jaF1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnRleHQucmVwbGFjZU5vZGUoaWZOb2RlKTtcclxuICAgICAgICBpZiAocHJvY2Vzc0NvZGVnZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NDb2RlZ2VuKGlmTm9kZSwgYnJhbmNoLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBsb2NhdGUgdGhlIGFkamFjZW50IHYtaWZcclxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGNvbW1lbnRzID0gW107XHJcbiAgICAgICAgbGV0IGkgPSBzaWJsaW5ncy5pbmRleE9mKG5vZGUpO1xyXG4gICAgICAgIHdoaWxlIChpLS0gPj0gLTEpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNpYmxpbmcgJiYgc2libGluZy50eXBlID09PSAzIC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbW1lbnRzLnVuc2hpZnQoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJlxyXG4gICAgICAgICAgICAgICAgc2libGluZy50eXBlID09PSAyIC8qIFRFWFQgKi8gJiZcclxuICAgICAgICAgICAgICAgICFzaWJsaW5nLmNvbnRlbnQudHJpbSgpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy50eXBlID09PSA5IC8qIElGICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBub2RlIHRvIHRoZSBpZiBub2RlJ3MgYnJhbmNoZXNcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29tbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoLmNoaWxkcmVuID0gWy4uLmNvbW1lbnRzLCAuLi5icmFuY2guY2hpbGRyZW5dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdXNlciBpcyBmb3JjaW5nIHNhbWUga2V5IG9uIGRpZmZlcmVudCBicmFuY2hlc1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGJyYW5jaC51c2VyS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlcy5mb3JFYWNoKCh7IHVzZXJLZXkgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZUtleSh1c2VyS2V5LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjggLyogWF9WX0lGX1NBTUVfS0VZICovLCBicmFuY2gudXNlcktleS5sb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlcy5wdXNoKGJyYW5jaCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihzaWJsaW5nLCBicmFuY2gsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBicmFuY2ggd2FzIHJlbW92ZWQsIGl0IHdpbGwgbm90IGJlIHRyYXZlcnNlZC5cclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byB0cmF2ZXJzZSBoZXJlLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKGJyYW5jaCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjYWxsIG9uIGV4aXRcclxuICAgICAgICAgICAgICAgIGlmIChvbkV4aXQpXHJcbiAgICAgICAgICAgICAgICAgICAgb25FeGl0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgY3VycmVudE5vZGUgYWZ0ZXIgdHJhdmVyc2FsIHRvIGluZGljYXRlIHRoaXNcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjkgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIG5vZGUubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxMCAvKiBJRl9CUkFOQ0ggKi8sXHJcbiAgICAgICAgbG9jOiBub2RlLmxvYyxcclxuICAgICAgICBjb25kaXRpb246IGRpci5uYW1lID09PSAnZWxzZScgPyB1bmRlZmluZWQgOiBkaXIuZXhwLFxyXG4gICAgICAgIGNoaWxkcmVuOiBub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8gJiYgIWZpbmREaXIobm9kZSwgJ2ZvcicpXHJcbiAgICAgICAgICAgID8gbm9kZS5jaGlsZHJlblxyXG4gICAgICAgICAgICA6IFtub2RlXSxcclxuICAgICAgICB1c2VyS2V5OiBmaW5kUHJvcChub2RlLCBga2V5YClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xyXG4gICAgaWYgKGJyYW5jaC5jb25kaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKGJyYW5jaC5jb25kaXRpb24sIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCksIFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBwYXNzIGluIGFzQmxvY2s6IHRydWUgc28gdGhhdCB0aGUgY29tbWVudCBub2RlIGNhbGxcclxuICAgICAgICAvLyBjbG9zZXMgdGhlIGN1cnJlbnQgYmxvY2suXHJcbiAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX0NPTU1FTlQpLCBbXHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdcInYtaWZcIicgOiAnXCJcIicsXHJcbiAgICAgICAgICAgICd0cnVlJ1xyXG4gICAgICAgIF0pKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBrZXlQcm9wZXJ0eSA9IGNyZWF0ZU9iamVjdFByb3BlcnR5KGBrZXlgLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAke2tleUluZGV4fWAsIGZhbHNlLCBsb2NTdHViLCAyIC8qIENBTl9IT0lTVCAqLykpO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gYnJhbmNoO1xyXG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBmaXJzdENoaWxkLnR5cGUgIT09IDEgLyogRUxFTUVOVCAqLztcclxuICAgIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBmaXJzdENoaWxkLnR5cGUgPT09IDExIC8qIEZPUiAqLykge1xyXG4gICAgICAgICAgICAvLyBvcHRpbWl6ZSBhd2F5IG5lc3RlZCBmcmFnbWVudHMgd2hlbiBjaGlsZCBpcyBhIEZvck5vZGVcclxuICAgICAgICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZmlyc3RDaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaW5qZWN0UHJvcCh2bm9kZUNhbGwsIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZub2RlQ2FsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSwgY2hpbGRyZW4sIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLyArXHJcbiAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXX0gKi9gXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgYnJhbmNoLmxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZmlyc3RDaGlsZFxyXG4gICAgICAgICAgICAuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgLy8gQ2hhbmdlIGNyZWF0ZVZOb2RlIHRvIGNyZWF0ZUJsb2NrLlxyXG4gICAgICAgIGlmICh2bm9kZUNhbGwudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICB2bm9kZUNhbGwuaXNCbG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgaGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCBicmFuY2gga2V5XHJcbiAgICAgICAgaW5qZWN0UHJvcCh2bm9kZUNhbGwsIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZUtleShhLCBiKSB7XHJcbiAgICBpZiAoIWEgfHwgYS50eXBlICE9PSBiLnR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoYS50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgIGlmIChhLnZhbHVlLmNvbnRlbnQgIT09IGIudmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0aXZlXHJcbiAgICAgICAgY29uc3QgZXhwID0gYS5leHA7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoRXhwID0gYi5leHA7XHJcbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSBicmFuY2hFeHAudHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHAudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAoZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHxcclxuICAgICAgICAgICAgICAgIGV4cC5jb250ZW50ICE9PSBicmFuY2hFeHAuY29udGVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhcmVudENvbmRpdGlvbihub2RlKSB7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmFsdGVybmF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtRm9yID0gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSgnZm9yJywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgICByZXR1cm4gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIGZvck5vZGUgPT4ge1xyXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbG9vcCByZW5kZXIgZnVuY3Rpb24gZXhwcmVzc2lvbiBub3csIGFuZCBhZGQgdGhlXHJcbiAgICAgICAgLy8gaXRlcmF0b3Igb24gZXhpdCBhZnRlciBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIHRyYXZlcnNlZFxyXG4gICAgICAgIGNvbnN0IHJlbmRlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGhlbHBlcihSRU5ERVJfTElTVCksIFtcclxuICAgICAgICAgICAgZm9yTm9kZS5zb3VyY2VcclxuICAgICAgICBdKTtcclxuICAgICAgICBjb25zdCBrZXlQcm9wID0gZmluZFByb3Aobm9kZSwgYGtleWApO1xyXG4gICAgICAgIGNvbnN0IGtleVByb3BlcnR5ID0ga2V5UHJvcFxyXG4gICAgICAgICAgICA/IGNyZWF0ZU9iamVjdFByb3BlcnR5KGBrZXlgLCBrZXlQcm9wLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oa2V5UHJvcC52YWx1ZS5jb250ZW50LCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgOiBrZXlQcm9wLmV4cClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGlzU3RhYmxlRnJhZ21lbnQgPSBmb3JOb2RlLnNvdXJjZS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlLmNvbnN0VHlwZSA+IDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50RmxhZyA9IGlzU3RhYmxlRnJhZ21lbnRcclxuICAgICAgICAgICAgPyA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9cclxuICAgICAgICAgICAgOiBrZXlQcm9wXHJcbiAgICAgICAgICAgICAgICA/IDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqL1xyXG4gICAgICAgICAgICAgICAgOiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLztcclxuICAgICAgICBmb3JOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcmVuZGVyRXhwLCBmcmFnbWVudEZsYWcgK1xyXG4gICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzW2ZyYWdtZW50RmxhZ119ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUgLyogaXNCbG9jayAqLywgIWlzU3RhYmxlRnJhZ21lbnQgLyogZGlzYWJsZVRyYWNraW5nICovLCBub2RlLmxvYyk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgLy8gZmluaXNoIHRoZSBjb2RlZ2VuIG5vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXHJcbiAgICAgICAgICAgIGxldCBjaGlsZEJsb2NrO1xyXG4gICAgICAgICAgICBjb25zdCBpc1RlbXBsYXRlID0gaXNUZW1wbGF0ZU5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGZvck5vZGU7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIDx0ZW1wbGF0ZSB2LWZvcj4ga2V5IHBsYWNlbWVudFxyXG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSkgJiYgaXNUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBmaW5kUHJvcChjLCAna2V5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMyIC8qIFhfVl9GT1JfVEVNUExBVEVfS0VZX1BMQUNFTUVOVCAqLywga2V5LmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBuZWVkRnJhZ21lbnRXcmFwcGVyID0gY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGNoaWxkcmVuWzBdLnR5cGUgIT09IDEgLyogRUxFTUVOVCAqLztcclxuICAgICAgICAgICAgY29uc3Qgc2xvdE91dGxldCA9IGlzU2xvdE91dGxldChub2RlKVxyXG4gICAgICAgICAgICAgICAgPyBub2RlXHJcbiAgICAgICAgICAgICAgICA6IGlzVGVtcGxhdGUgJiZcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzU2xvdE91dGxldChub2RlLmNoaWxkcmVuWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZS5jaGlsZHJlblswXSAvLyBhcGktZXh0cmFjdG9yIHNvbWVob3cgZmFpbHMgdG8gaW5mZXIgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKHNsb3RPdXRsZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIDxzbG90IHYtZm9yPVwiLi4uXCI+IG9yIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IHNsb3RPdXRsZXQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZSAmJiBrZXlQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiIDprZXk9XCIuLi5cIj48c2xvdC8+PC90ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGluamVjdCB0aGUga2V5IHRvIHRoZSByZW5kZXJTbG90KCkgY2FsbC5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJvcHMgZm9yIHJlbmRlclNsb3QgaXMgcGFzc2VkIGFzIHRoZSAzcmQgYXJndW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZEZyYWdtZW50V3JhcHBlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+IHdpdGggdGV4dCBvciBtdWx0aS1lbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGdlbmVyYXRlIGEgZnJhZ21lbnQgYmxvY2sgZm9yIGVhY2ggbG9vcFxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBrZXlQcm9wZXJ0eSA/IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW2tleVByb3BlcnR5XSkgOiB1bmRlZmluZWQsIG5vZGUuY2hpbGRyZW4sIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLyArXHJcbiAgICAgICAgICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dfSAqL2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBlbGVtZW50IHYtZm9yLiBEaXJlY3RseSB1c2UgdGhlIGNoaWxkJ3MgY29kZWdlbk5vZGVcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBtYXJrIGl0IGFzIGEgYmxvY2suXHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY2hpbGRyZW5bMF1cclxuICAgICAgICAgICAgICAgICAgICAuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZSAmJiBrZXlQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jay5pc0Jsb2NrID0gIWlzU3RhYmxlRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVuZGVyRXhwLmFyZ3VtZW50cy5wdXNoKGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKGZvck5vZGUucGFyc2VSZXN1bHQpLCBjaGlsZEJsb2NrLCB0cnVlIC8qIGZvcmNlIG5ld2xpbmUgKi8pKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn0pO1xyXG4vLyB0YXJnZXQtYWdub3N0aWMgdHJhbnNmb3JtIHVzZWQgZm9yIGJvdGggQ2xpZW50IGFuZCBTU1JcclxuZnVuY3Rpb24gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICBpZiAoIWRpci5leHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBYX1ZfRk9SX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbihcclxuICAgIC8vIGNhbiBvbmx5IGJlIHNpbXBsZSBleHByZXNzaW9uIGJlY2F1c2UgdkZvciB0cmFuc2Zvcm0gaXMgYXBwbGllZFxyXG4gICAgLy8gYmVmb3JlIGV4cHJlc3Npb24gdHJhbnNmb3JtLlxyXG4gICAgZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzEgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzLCBzY29wZXMgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHNvdXJjZSwgdmFsdWUsIGtleSwgaW5kZXggfSA9IHBhcnNlUmVzdWx0O1xyXG4gICAgY29uc3QgZm9yTm9kZSA9IHtcclxuICAgICAgICB0eXBlOiAxMSAvKiBGT1IgKi8sXHJcbiAgICAgICAgbG9jOiBkaXIubG9jLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICB2YWx1ZUFsaWFzOiB2YWx1ZSxcclxuICAgICAgICBrZXlBbGlhczoga2V5LFxyXG4gICAgICAgIG9iamVjdEluZGV4QWxpYXM6IGluZGV4LFxyXG4gICAgICAgIHBhcnNlUmVzdWx0LFxyXG4gICAgICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlTm9kZShub2RlKSA/IG5vZGUuY2hpbGRyZW4gOiBbbm9kZV1cclxuICAgIH07XHJcbiAgICBjb250ZXh0LnJlcGxhY2VOb2RlKGZvck5vZGUpO1xyXG4gICAgLy8gYm9va2tlZXBpbmdcclxuICAgIHNjb3Blcy52Rm9yKys7XHJcbiAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihmb3JOb2RlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgc2NvcGVzLnZGb3ItLTtcclxuICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICBvbkV4aXQoKTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcclxuLy8gVGhpcyByZWdleCBkb2Vzbid0IGNvdmVyIHRoZSBjYXNlIGlmIGtleSBvciBpbmRleCBhbGlhc2VzIGhhdmUgZGVzdHJ1Y3R1cmluZyxcclxuLy8gYnV0IHRob3NlIGRvIG5vdCBtYWtlIHNlbnNlIGluIHRoZSBmaXJzdCBwbGFjZSwgc28gdGhpcyB3b3JrcyBpbiBwcmFjdGljZS5cclxuY29uc3QgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcclxuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcclxuZnVuY3Rpb24gcGFyc2VGb3JFeHByZXNzaW9uKGlucHV0LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBsb2MgPSBpbnB1dC5sb2M7XHJcbiAgICBjb25zdCBleHAgPSBpbnB1dC5jb250ZW50O1xyXG4gICAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcclxuICAgIGlmICghaW5NYXRjaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjb25zdCBbLCBMSFMsIFJIU10gPSBpbk1hdGNoO1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHNvdXJjZTogY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgUkhTLnRyaW0oKSwgZXhwLmluZGV4T2YoUkhTLCBMSFMubGVuZ3RoKSksXHJcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcclxuICAgICAgICBpbmRleDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuc291cmNlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGxldCB2YWx1ZUNvbnRlbnQgPSBMSFMudHJpbSgpXHJcbiAgICAgICAgLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpXHJcbiAgICAgICAgLnRyaW0oKTtcclxuICAgIGNvbnN0IHRyaW1tZWRPZmZzZXQgPSBMSFMuaW5kZXhPZih2YWx1ZUNvbnRlbnQpO1xyXG4gICAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IHZhbHVlQ29udGVudC5tYXRjaChmb3JJdGVyYXRvclJFKTtcclxuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XHJcbiAgICAgICAgdmFsdWVDb250ZW50ID0gdmFsdWVDb250ZW50LnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcclxuICAgICAgICBjb25zdCBrZXlDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XHJcbiAgICAgICAgbGV0IGtleU9mZnNldDtcclxuICAgICAgICBpZiAoa2V5Q29udGVudCkge1xyXG4gICAgICAgICAgICBrZXlPZmZzZXQgPSBleHAuaW5kZXhPZihrZXlDb250ZW50LCB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBrZXlDb250ZW50LCBrZXlPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LmtleSwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXhDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGluZGV4Q29udGVudCwgZXhwLmluZGV4T2YoaW5kZXhDb250ZW50LCByZXN1bHQua2V5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlPZmZzZXQgKyBrZXlDb250ZW50Lmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIDogdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LmluZGV4LCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh2YWx1ZUNvbnRlbnQpIHtcclxuICAgICAgICByZXN1bHQudmFsdWUgPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCB2YWx1ZUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC52YWx1ZSwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBbGlhc0V4cHJlc3Npb24ocmFuZ2UsIGNvbnRlbnQsIG9mZnNldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgZmFsc2UsIGdldElubmVyUmFuZ2UocmFuZ2UsIG9mZnNldCwgY29udGVudC5sZW5ndGgpKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JMb29wUGFyYW1zKHsgdmFsdWUsIGtleSwgaW5kZXggfSkge1xyXG4gICAgY29uc3QgcGFyYW1zID0gW107XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBwYXJhbXMucHVzaCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfYCwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLnB1c2goa2V5KTtcclxuICAgIH1cclxuICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9fYCwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLnB1c2goaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxufVxuXG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB1bmRlZmluZWRgLCBmYWxzZSk7XHJcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0OlxyXG4vLyAxLiBUcmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IHByZWZpeGVkXHJcbi8vICAgIGJ5IHRyYW5zZm9ybUV4cHJlc3Npb24uIFRoaXMgaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoXHJcbi8vICAgIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfS5cclxuLy8gMi4gVHJhY2sgdi1zbG90IGRlcHRocyBzbyB0aGF0IHdlIGtub3cgYSBzbG90IGlzIGluc2lkZSBhbm90aGVyIHNsb3QuXHJcbi8vICAgIE5vdGUgdGhlIGV4aXQgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgYmVmb3JlIGJ1aWxkU2xvdHMoKSBvbiB0aGUgc2FtZSBub2RlLFxyXG4vLyAgICBzbyBvbmx5IG5lc3RlZCBzbG90cyBzZWUgcG9zaXRpdmUgbnVtYmVycy5cclxuY29uc3QgdHJhY2tTbG90U2NvcGVzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIChub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLykpIHtcclxuICAgICAgICAvLyBXZSBhcmUgb25seSBjaGVja2luZyBub24tZW1wdHkgdi1zbG90IGhlcmVcclxuICAgICAgICAvLyBzaW5jZSB3ZSBvbmx5IGNhcmUgYWJvdXQgc2xvdHMgdGhhdCBpbnRyb2R1Y2Ugc2NvcGUgdmFyaWFibGVzLlxyXG4gICAgICAgIGNvbnN0IHZTbG90ID0gZmluZERpcihub2RlLCAnc2xvdCcpO1xyXG4gICAgICAgIGlmICh2U2xvdCkge1xyXG4gICAgICAgICAgICB2U2xvdC5leHA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90Kys7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdC0tO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLy8gQSBOb2RlVHJhbnNmb3JtIHRoYXQgdHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgd2l0aCB2LWZvci5cclxuLy8gVGhpcyB0cmFuc2Zvcm0gaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfVxyXG5jb25zdCB0cmFja1ZGb3JTbG90U2NvcGVzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGxldCB2Rm9yO1xyXG4gICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpICYmXHJcbiAgICAgICAgbm9kZS5wcm9wcy5zb21lKGlzVlNsb3QpICYmXHJcbiAgICAgICAgKHZGb3IgPSBmaW5kRGlyKG5vZGUsICdmb3InKSkpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSAodkZvci5wYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCkpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwga2V5LCBpbmRleCB9ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdmFsdWUgJiYgYWRkSWRlbnRpZmllcnModmFsdWUpO1xyXG4gICAgICAgICAgICBrZXkgJiYgYWRkSWRlbnRpZmllcnMoa2V5KTtcclxuICAgICAgICAgICAgaW5kZXggJiYgYWRkSWRlbnRpZmllcnMoaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgJiYgcmVtb3ZlSWRlbnRpZmllcnModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAga2V5ICYmIHJlbW92ZUlkZW50aWZpZXJzKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCAmJiByZW1vdmVJZGVudGlmaWVycyhpbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBidWlsZENsaWVudFNsb3RGbiA9IChwcm9wcywgY2hpbGRyZW4sIGxvYykgPT4gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHByb3BzLCBjaGlsZHJlbiwgZmFsc2UgLyogbmV3bGluZSAqLywgdHJ1ZSAvKiBpc1Nsb3QgKi8sIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdLmxvYyA6IGxvYyk7XHJcbi8vIEluc3RlYWQgb2YgYmVpbmcgYSBEaXJlY3RpdmVUcmFuc2Zvcm0sIHYtc2xvdCBwcm9jZXNzaW5nIGlzIGNhbGxlZCBkdXJpbmdcclxuLy8gdHJhbnNmb3JtRWxlbWVudCB0byBidWlsZCB0aGUgc2xvdHMgb2JqZWN0IGZvciBhIGNvbXBvbmVudC5cclxuZnVuY3Rpb24gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0LCBidWlsZFNsb3RGbiA9IGJ1aWxkQ2xpZW50U2xvdEZuKSB7XHJcbiAgICBjb250ZXh0LmhlbHBlcihXSVRIX0NUWCk7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBsb2MgfSA9IG5vZGU7XHJcbiAgICBjb25zdCBzbG90c1Byb3BlcnRpZXMgPSBbXTtcclxuICAgIGNvbnN0IGR5bmFtaWNTbG90cyA9IFtdO1xyXG4gICAgY29uc3QgYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5ID0gKHByb3BzLCBjaGlsZHJlbikgPT4gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGRlZmF1bHRgLCBidWlsZFNsb3RGbihwcm9wcywgY2hpbGRyZW4sIGxvYykpO1xyXG4gICAgLy8gSWYgdGhlIHNsb3QgaXMgaW5zaWRlIGEgdi1mb3Igb3IgYW5vdGhlciB2LXNsb3QsIGZvcmNlIGl0IHRvIGJlIGR5bmFtaWNcclxuICAgIC8vIHNpbmNlIGl0IGxpa2VseSB1c2VzIGEgc2NvcGUgdmFyaWFibGUuXHJcbiAgICBsZXQgaGFzRHluYW1pY1Nsb3RzID0gY29udGV4dC5zY29wZXMudlNsb3QgPiAwIHx8IGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwO1xyXG4gICAgLy8gMS4gQ2hlY2sgZm9yIHNsb3Qgd2l0aCBzbG90UHJvcHMgb24gY29tcG9uZW50IGl0c2VsZi5cclxuICAgIC8vICAgIDxDb21wIHYtc2xvdD1cInsgcHJvcCB9XCIvPlxyXG4gICAgY29uc3Qgb25Db21wb25lbnRTbG90ID0gZmluZERpcihub2RlLCAnc2xvdCcsIHRydWUpO1xyXG4gICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgIGNvbnN0IHsgYXJnLCBleHAgfSA9IG9uQ29tcG9uZW50U2xvdDtcclxuICAgICAgICBpZiAoYXJnICYmICFpc1N0YXRpY0V4cChhcmcpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGFyZyB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdkZWZhdWx0JywgdHJ1ZSksIGJ1aWxkU2xvdEZuKGV4cCwgY2hpbGRyZW4sIGxvYykpKTtcclxuICAgIH1cclxuICAgIC8vIDIuIEl0ZXJhdGUgdGhyb3VnaCBjaGlsZHJlbiBhbmQgY2hlY2sgZm9yIHRlbXBsYXRlIHNsb3RzXHJcbiAgICAvLyAgICA8dGVtcGxhdGUgdi1zbG90OmZvbz1cInsgcHJvcCB9XCI+XHJcbiAgICBsZXQgaGFzVGVtcGxhdGVTbG90cyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc05hbWVkRGVmYXVsdFNsb3QgPSBmYWxzZTtcclxuICAgIGNvbnN0IGltcGxpY2l0RGVmYXVsdENoaWxkcmVuID0gW107XHJcbiAgICBjb25zdCBzZWVuU2xvdE5hbWVzID0gbmV3IFNldCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNsb3RFbGVtZW50ID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgbGV0IHNsb3REaXI7XHJcbiAgICAgICAgaWYgKCFpc1RlbXBsYXRlTm9kZShzbG90RWxlbWVudCkgfHxcclxuICAgICAgICAgICAgIShzbG90RGlyID0gZmluZERpcihzbG90RWxlbWVudCwgJ3Nsb3QnLCB0cnVlKSkpIHtcclxuICAgICAgICAgICAgLy8gbm90IGEgPHRlbXBsYXRlIHYtc2xvdD4sIHNraXAuXHJcbiAgICAgICAgICAgIGlmIChzbG90RWxlbWVudC50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnB1c2goc2xvdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgaGFzIG9uLWNvbXBvbmVudCBzbG90IC0gdGhpcyBpcyBpbmNvcnJlY3QgdXNhZ2UuXHJcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM2IC8qIFhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0UgKi8sIHNsb3REaXIubG9jKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNUZW1wbGF0ZVNsb3RzID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzbG90Q2hpbGRyZW4sIGxvYzogc2xvdExvYyB9ID0gc2xvdEVsZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgeyBhcmc6IHNsb3ROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgZGVmYXVsdGAsIHRydWUpLCBleHA6IHNsb3RQcm9wcywgbG9jOiBkaXJMb2MgfSA9IHNsb3REaXI7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgbmFtZSBpcyBkeW5hbWljLlxyXG4gICAgICAgIGxldCBzdGF0aWNTbG90TmFtZTtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoc2xvdE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHN0YXRpY1Nsb3ROYW1lID0gc2xvdE5hbWUgPyBzbG90TmFtZS5jb250ZW50IDogYGRlZmF1bHRgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2xvdEZ1bmN0aW9uID0gYnVpbGRTbG90Rm4oc2xvdFByb3BzLCBzbG90Q2hpbGRyZW4sIHNsb3RMb2MpO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc2xvdCBpcyBjb25kaXRpb25hbCAodi1pZi92LWZvcilcclxuICAgICAgICBsZXQgdklmO1xyXG4gICAgICAgIGxldCB2RWxzZTtcclxuICAgICAgICBsZXQgdkZvcjtcclxuICAgICAgICBpZiAoKHZJZiA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdpZicpKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odklmLmV4cCwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgZGVmYXVsdEZhbGxiYWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh2RWxzZSA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIC9eZWxzZSgtaWYpPyQvLCB0cnVlIC8qIGFsbG93RW1wdHkgKi8pKSkge1xyXG4gICAgICAgICAgICAvLyBmaW5kIGFkamFjZW50IHYtaWZcclxuICAgICAgICAgICAgbGV0IGogPSBpO1xyXG4gICAgICAgICAgICBsZXQgcHJldjtcclxuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXYgJiYgaXNUZW1wbGF0ZU5vZGUocHJldikgJiYgZmluZERpcihwcmV2LCAnaWYnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCB0aGlzIHNsb3QgdG8gcHJldmlvdXMgY29uZGl0aW9uYWxcclxuICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb25hbCA9IGR5bmFtaWNTbG90c1tkeW5hbWljU2xvdHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29uZGl0aW9uYWwuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmFsdGVybmF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsLmFsdGVybmF0ZSA9IHZFbHNlLmV4cFxyXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHZFbHNlLmV4cCwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgZGVmYXVsdEZhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIDogYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI5IC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCB2RWxzZS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodkZvciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdmb3InKSkpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB2Rm9yLnBhcnNlUmVzdWx0IHx8XHJcbiAgICAgICAgICAgICAgICBwYXJzZUZvckV4cHJlc3Npb24odkZvci5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgZHluYW1pYyBzbG90cyBhcyBhbiBhcnJheSBhbmQgYWRkIGl0IHRvIHRoZSBjcmVhdGVTbG90KClcclxuICAgICAgICAgICAgICAgIC8vIGFyZ3MuIFRoZSBydW50aW1lIGtub3dzIGhvdyB0byBoYW5kbGUgaXQgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LnNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhwYXJzZVJlc3VsdCksIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLylcclxuICAgICAgICAgICAgICAgIF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMxIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIHZGb3IubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGR1cGxpY2F0ZSBzdGF0aWMgbmFtZXNcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VlblNsb3ROYW1lcy5oYXMoc3RhdGljU2xvdE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzcgLyogWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi8sIGRpckxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VlblNsb3ROYW1lcy5hZGQoc3RhdGljU2xvdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNOYW1lZERlZmF1bHRTbG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICBpZiAoIWhhc1RlbXBsYXRlU2xvdHMpIHtcclxuICAgICAgICAgICAgLy8gaW1wbGljaXQgZGVmYXVsdCBzbG90IChvbiBjb21wb25lbnQpXHJcbiAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSh1bmRlZmluZWQsIGNoaWxkcmVuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG1peGVkIHdpdGggbmFtZWQgc2xvdHMpXHJcbiAgICAgICAgICAgIGlmIChoYXNOYW1lZERlZmF1bHRTbG90KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzOCAvKiBYX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqLywgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW5bMF0ubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2xvdEZsYWcgPSBoYXNEeW5hbWljU2xvdHNcclxuICAgICAgICA/IDIgLyogRFlOQU1JQyAqL1xyXG4gICAgICAgIDogaGFzRm9yd2FyZGVkU2xvdHMobm9kZS5jaGlsZHJlbilcclxuICAgICAgICAgICAgPyAzIC8qIEZPUldBUkRFRCAqL1xyXG4gICAgICAgICAgICA6IDEgLyogU1RBQkxFICovO1xyXG4gICAgbGV0IHNsb3RzID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihzbG90c1Byb3BlcnRpZXMuY29uY2F0KGNyZWF0ZU9iamVjdFByb3BlcnR5KGBfYCwgXHJcbiAgICAvLyAyID0gY29tcGlsZWQgYnV0IGR5bmFtaWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uLCBidXQgbXVzdCBydW4gZGlmZlxyXG4gICAgLy8gMSA9IGNvbXBpbGVkIGFuZCBzdGF0aWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uIEFORCBkaWZmIGFzIG9wdGltaXplZFxyXG4gICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihzbG90RmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7c2xvdEZsYWdzVGV4dFtzbG90RmxhZ119ICovYCA6IGBgKSwgZmFsc2UpKSksIGxvYyk7XHJcbiAgICBpZiAoZHluYW1pY1Nsb3RzLmxlbmd0aCkge1xyXG4gICAgICAgIHNsb3RzID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1NMT1RTKSwgW1xyXG4gICAgICAgICAgICBzbG90cyxcclxuICAgICAgICAgICAgY3JlYXRlQXJyYXlFeHByZXNzaW9uKGR5bmFtaWNTbG90cylcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgaGFzRHluYW1pY1Nsb3RzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY1Nsb3QobmFtZSwgZm4pIHtcclxuICAgIHJldHVybiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShgbmFtZWAsIG5hbWUpLFxyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBmbmAsIGZuKVxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGRyZW4pIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ1R5cGUgPT09IDIgLyogU0xPVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgKGNoaWxkLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbi8vIHNvbWUgZGlyZWN0aXZlIHRyYW5zZm9ybXMgKGUuZy4gdi1tb2RlbCkgbWF5IHJldHVybiBhIHN5bWJvbCBmb3IgcnVudGltZVxyXG4vLyBpbXBvcnQsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgYSByZXNvbHZlRGlyZWN0aXZlIGNhbGwuXHJcbmNvbnN0IGRpcmVjdGl2ZUltcG9ydE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIGdlbmVyYXRlIGEgSmF2YVNjcmlwdCBBU1QgZm9yIHRoaXMgZWxlbWVudCdzIGNvZGVnZW5cclxuY29uc3QgdHJhbnNmb3JtRWxlbWVudCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAoIShub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIChub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBwZXJmb3JtIHRoZSB3b3JrIG9uIGV4aXQsIGFmdGVyIGFsbCBjaGlsZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cclxuICAgIC8vIHByb2Nlc3NlZCBhbmQgbWVyZ2VkLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBvc3RUcmFuc2Zvcm1FbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHsgdGFnLCBwcm9wcyB9ID0gbm9kZTtcclxuICAgICAgICBjb25zdCBpc0NvbXBvbmVudCA9IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgLy8gVGhlIGdvYWwgb2YgdGhlIHRyYW5zZm9ybSBpcyB0byBjcmVhdGUgYSBjb2RlZ2VuTm9kZSBpbXBsZW1lbnRpbmcgdGhlXHJcbiAgICAgICAgLy8gVk5vZGVDYWxsIGludGVyZmFjZS5cclxuICAgICAgICBjb25zdCB2bm9kZVRhZyA9IGlzQ29tcG9uZW50XHJcbiAgICAgICAgICAgID8gcmVzb2x2ZUNvbXBvbmVudFR5cGUobm9kZSwgY29udGV4dClcclxuICAgICAgICAgICAgOiBgXCIke3RhZ31cImA7XHJcbiAgICAgICAgY29uc3QgaXNEeW5hbWljQ29tcG9uZW50ID0gaXNPYmplY3Qodm5vZGVUYWcpICYmIHZub2RlVGFnLmNhbGxlZSA9PT0gUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVDtcclxuICAgICAgICBsZXQgdm5vZGVQcm9wcztcclxuICAgICAgICBsZXQgdm5vZGVDaGlsZHJlbjtcclxuICAgICAgICBsZXQgdm5vZGVQYXRjaEZsYWc7XHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgbGV0IHZub2RlRHluYW1pY1Byb3BzO1xyXG4gICAgICAgIGxldCBkeW5hbWljUHJvcE5hbWVzO1xyXG4gICAgICAgIGxldCB2bm9kZURpcmVjdGl2ZXM7XHJcbiAgICAgICAgbGV0IHNob3VsZFVzZUJsb2NrID0gXHJcbiAgICAgICAgLy8gZHluYW1pYyBjb21wb25lbnQgbWF5IHJlc29sdmUgdG8gcGxhaW4gZWxlbWVudHNcclxuICAgICAgICBpc0R5bmFtaWNDb21wb25lbnQgfHxcclxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFRFTEVQT1JUIHx8XHJcbiAgICAgICAgICAgIHZub2RlVGFnID09PSBTVVNQRU5TRSB8fFxyXG4gICAgICAgICAgICAoIWlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICAvLyA8c3ZnPiBhbmQgPGZvcmVpZ25PYmplY3Q+IG11c3QgYmUgZm9yY2VkIGludG8gYmxvY2tzIHNvIHRoYXQgYmxvY2tcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgaW5zaWRlIGdldCBwcm9wZXIgaXNTVkcgZmxhZyBhdCBydW50aW1lLiAoIzYzOSwgIzY0MylcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGVjaG5pY2FsbHkgd2ViLXNwZWNpZmljLCBidXQgc3BsaXR0aW5nIHRoZSBsb2dpYyBvdXQgb2YgY29yZVxyXG4gICAgICAgICAgICAgICAgLy8gbGVhZHMgdG8gdG9vIG11Y2ggdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cclxuICAgICAgICAgICAgICAgICh0YWcgPT09ICdzdmcnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnID09PSAnZm9yZWlnbk9iamVjdCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgZmluZFByb3Aobm9kZSwgJ2tleScsIHRydWUpKSk7XHJcbiAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wc0J1aWxkUmVzdWx0ID0gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdm5vZGVQcm9wcyA9IHByb3BzQnVpbGRSZXN1bHQucHJvcHM7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IHByb3BzQnVpbGRSZXN1bHQucGF0Y2hGbGFnO1xyXG4gICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzID0gcHJvcHNCdWlsZFJlc3VsdC5keW5hbWljUHJvcE5hbWVzO1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gcHJvcHNCdWlsZFJlc3VsdC5kaXJlY3RpdmVzO1xyXG4gICAgICAgICAgICB2bm9kZURpcmVjdGl2ZXMgPVxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpcmVjdGl2ZXMubWFwKGRpciA9PiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodm5vZGVUYWcgPT09IEtFRVBfQUxJVkUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIGEgYnVpbHQtaW4gY29tcG9uZW50LCB3ZSBjb21waWxlIEtlZXBBbGl2ZSB3aXRoIHJhdyBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBzbG90IGZ1bmN0aW9ucyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGluc2lkZSBUcmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBvciBvdGhlciBUcmFuc2l0aW9uLXdyYXBwaW5nIEhPQ3MuXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIHdpdGggYmxvY2sgb3B0aW1pemF0aW9ucywgd2UgbmVlZCB0bzpcclxuICAgICAgICAgICAgICAgIC8vIDEuIEZvcmNlIGtlZXAtYWxpdmUgaW50byBhIGJsb2NrLiBUaGlzIGF2b2lkcyBpdHMgY2hpbGRyZW4gYmVpbmdcclxuICAgICAgICAgICAgICAgIC8vICAgIGNvbGxlY3RlZCBieSBhIHBhcmVudCBibG9jay5cclxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIDIuIEZvcmNlIGtlZXAtYWxpdmUgdG8gYWx3YXlzIGJlIHVwZGF0ZWQsIHNpbmNlIGl0IHVzZXMgcmF3IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDQgLyogWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEJ1aWxkQXNTbG90cyA9IGlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCBpcyBub3QgYSByZWFsIGNvbXBvbmVudCBhbmQgaGFzIGRlZGljYXRlZCBydW50aW1lIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gVEVMRVBPUlQgJiZcclxuICAgICAgICAgICAgICAgIC8vIGV4cGxhaW5lZCBhYm92ZS5cclxuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBLRUVQX0FMSVZFO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkQnVpbGRBc1Nsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNsb3RzLCBoYXNEeW5hbWljU2xvdHMgfSA9IGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1Nsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB2bm9kZVRhZyAhPT0gVEVMRVBPUlQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZC50eXBlO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGR5bmFtaWMgdGV4dCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1RleHRDaGlsZCA9IHR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLztcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMSAvKiBURVhUICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcGFzcyBkaXJlY3RseSBpZiB0aGUgb25seSBjaGlsZCBpcyBhIHRleHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gKHBsYWluIC8gaW50ZXJwb2xhdGlvbiAvIGV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCB8fCB0eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhdGNoRmxhZyAmIGR5bmFtaWNQcm9wTmFtZXNcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBmbGFncyAobmVnYXRpdmUgYW5kIG11dHVhbGx5IGV4Y2x1c2l2ZSlcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtQYXRjaEZsYWdOYW1lc1twYXRjaEZsYWddfSAqL2A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBiaXR3aXNlIGZsYWdzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhZ05hbWVzID0gT2JqZWN0LmtleXMoUGF0Y2hGbGFnTmFtZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG4gPT4gbiA+IDAgJiYgcGF0Y2hGbGFnICYgbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChuID0+IFBhdGNoRmxhZ05hbWVzW25dKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihgLCBgKTtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtmbGFnTmFtZXN9ICovYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlUGF0Y2hGbGFnID0gU3RyaW5nKHBhdGNoRmxhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMgJiYgZHluYW1pY1Byb3BOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlRHluYW1pY1Byb3BzID0gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhkeW5hbWljUHJvcE5hbWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIHZub2RlVGFnLCB2bm9kZVByb3BzLCB2bm9kZUNoaWxkcmVuLCB2bm9kZVBhdGNoRmxhZywgdm5vZGVEeW5hbWljUHJvcHMsIHZub2RlRGlyZWN0aXZlcywgISFzaG91bGRVc2VCbG9jaywgZmFsc2UgLyogZGlzYWJsZVRyYWNraW5nICovLCBub2RlLmxvYyk7XHJcbiAgICB9O1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0LCBzc3IgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgeyB0YWcgfSA9IG5vZGU7XHJcbiAgICAvLyAxLiBkeW5hbWljIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaXNQcm9wID0gbm9kZS50YWcgPT09ICdjb21wb25lbnQnID8gZmluZFByb3Aobm9kZSwgJ2lzJykgOiBmaW5kRGlyKG5vZGUsICdpcycpO1xyXG4gICAgaWYgKGlzUHJvcCkge1xyXG4gICAgICAgIGNvbnN0IGV4cCA9IGlzUHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqL1xyXG4gICAgICAgICAgICA/IGlzUHJvcC52YWx1ZSAmJiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGlzUHJvcC52YWx1ZS5jb250ZW50LCB0cnVlKVxyXG4gICAgICAgICAgICA6IGlzUHJvcC5leHA7XHJcbiAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCksIFtcclxuICAgICAgICAgICAgICAgIGV4cFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAyLiBidWlsdC1pbiBjb21wb25lbnRzIChUZWxlcG9ydCwgVHJhbnNpdGlvbiwgS2VlcEFsaXZlLCBTdXNwZW5zZS4uLilcclxuICAgIGNvbnN0IGJ1aWx0SW4gPSBpc0NvcmVDb21wb25lbnQodGFnKSB8fCBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpO1xyXG4gICAgaWYgKGJ1aWx0SW4pIHtcclxuICAgICAgICAvLyBidWlsdC1pbnMgYXJlIHNpbXBseSBmYWxsdGhyb3VnaHMgLyBoYXZlIHNwZWNpYWwgaGFuZGxpbmcgZHVyaW5nIHNzclxyXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gaW1wb3J0IHRoZWlyIHJ1bnRpbWUgZXF1aXZhbGVudHNcclxuICAgICAgICBpZiAoIXNzcilcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoYnVpbHRJbik7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWx0SW47XHJcbiAgICB9XHJcbiAgICAvLyA1LiB1c2VyIGNvbXBvbmVudCAocmVzb2x2ZSlcclxuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfQ09NUE9ORU5UKTtcclxuICAgIGNvbnRleHQuY29tcG9uZW50cy5hZGQodGFnKTtcclxuICAgIHJldHVybiB0b1ZhbGlkQXNzZXRJZCh0YWcsIGBjb21wb25lbnRgKTtcclxufVxyXG5mdW5jdGlvbiBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIHByb3BzID0gbm9kZS5wcm9wcywgc3NyID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgdGFnLCBsb2M6IGVsZW1lbnRMb2MgfSA9IG5vZGU7XHJcbiAgICBjb25zdCBpc0NvbXBvbmVudCA9IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICBsZXQgcHJvcGVydGllcyA9IFtdO1xyXG4gICAgY29uc3QgbWVyZ2VBcmdzID0gW107XHJcbiAgICBjb25zdCBydW50aW1lRGlyZWN0aXZlcyA9IFtdO1xyXG4gICAgLy8gcGF0Y2hGbGFnIGFuYWx5c2lzXHJcbiAgICBsZXQgcGF0Y2hGbGFnID0gMDtcclxuICAgIGxldCBoYXNSZWYgPSBmYWxzZTtcclxuICAgIGxldCBoYXNDbGFzc0JpbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBoYXNTdHlsZUJpbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBoYXNEeW5hbWljS2V5cyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc1Zub2RlSG9vayA9IGZhbHNlO1xyXG4gICAgY29uc3QgZHluYW1pY1Byb3BOYW1lcyA9IFtdO1xyXG4gICAgY29uc3QgYW5hbHl6ZVBhdGNoRmxhZyA9ICh7IGtleSwgdmFsdWUgfSkgPT4ge1xyXG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBrZXkuY29udGVudDtcclxuICAgICAgICAgICAgY29uc3QgaXNFdmVudEhhbmRsZXIgPSBpc09uKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICBpc0V2ZW50SGFuZGxlciAmJlxyXG4gICAgICAgICAgICAgICAgLy8gb21pdCB0aGUgZmxhZyBmb3IgY2xpY2sgaGFuZGxlcnMgYmVjYXVzZSBoeWRyYXRpb24gZ2l2ZXMgY2xpY2tcclxuICAgICAgICAgICAgICAgIC8vIGRlZGljYXRlZCBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbmNsaWNrJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gb21pdCB2LW1vZGVsIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnb25VcGRhdGU6bW9kZWxWYWx1ZScgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgb25Wbm9kZVhYWCBob29rc1xyXG4gICAgICAgICAgICAgICAgIWlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0V2ZW50SGFuZGxlciAmJiBpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzVm5vZGVIb29rID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgKCh2YWx1ZS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCkgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBpcyBhIGNhY2hlZCBoYW5kbGVyIG9yIGhhcyBjb25zdGFudCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xyXG4gICAgICAgICAgICAgICAgaGFzUmVmID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnICYmICFpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaGFzQ2xhc3NCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnICYmICFpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaGFzU3R5bGVCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lICE9PSAna2V5JyAmJiAhZHluYW1pY1Byb3BOYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY1Byb3BOYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBzdGF0aWMgYXR0cmlidXRlXHJcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbG9jLCBuYW1lLCB2YWx1ZSB9ID0gcHJvcDtcclxuICAgICAgICAgICAgbGV0IGlzU3RhdGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyZWYnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNSZWYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgOmlzIG9uIDxjb21wb25lbnQ+XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaXMnICYmIHRhZyA9PT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKG5hbWUsIHRydWUsIGdldElubmVyUmFuZ2UobG9jLCAwLCBuYW1lLmxlbmd0aCkpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHZhbHVlID8gdmFsdWUuY29udGVudCA6ICcnLCBpc1N0YXRpYywgdmFsdWUgPyB2YWx1ZS5sb2MgOiBsb2MpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzXHJcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJnLCBleHAsIGxvYyB9ID0gcHJvcDtcclxuICAgICAgICAgICAgY29uc3QgaXNCaW5kID0gbmFtZSA9PT0gJ2JpbmQnO1xyXG4gICAgICAgICAgICBjb25zdCBpc09uID0gbmFtZSA9PT0gJ29uJztcclxuICAgICAgICAgICAgLy8gc2tpcCB2LXNsb3QgLSBpdCBpcyBoYW5kbGVkIGJ5IGl0cyBkZWRpY2F0ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzkgLyogWF9WX1NMT1RfTUlTUExBQ0VEICovLCBsb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1vbmNlIC0gaXQgaXMgaGFuZGxlZCBieSBpdHMgZGVkaWNhdGVkIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdvbmNlJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCB2LWlzIGFuZCA6aXMgb24gPGNvbXBvbmVudD5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgfHxcclxuICAgICAgICAgICAgICAgIChpc0JpbmQgJiYgdGFnID09PSAnY29tcG9uZW50JyAmJiBpc0JpbmRLZXkoYXJnLCAnaXMnKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1vbiBpbiBTU1IgY29tcGlsYXRpb25cclxuICAgICAgICAgICAgaWYgKGlzT24gJiYgc3NyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHYtYmluZCBhbmQgdi1vbiB3aXRoIG5vIGFyZ3VtZW50XHJcbiAgICAgICAgICAgIGlmICghYXJnICYmIChpc0JpbmQgfHwgaXNPbikpIHtcclxuICAgICAgICAgICAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChleHApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmluZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChleHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1vbj1cIm9ialwiIC0+IHRvSGFuZGxlcnMob2JqKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IGNvbnRleHQuaGVscGVyKFRPX0hBTkRMRVJTKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2V4cF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoaXNCaW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMzMgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDM0IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZVRyYW5zZm9ybSA9IGNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGFzIGJ1aWx0LWluIGRpcmVjdGl2ZSB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBuZWVkUnVudGltZSB9ID0gZGlyZWN0aXZlVHJhbnNmb3JtKHByb3AsIG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgIXNzciAmJiBwcm9wcy5mb3JFYWNoKGFuYWx5emVQYXRjaEZsYWcpO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKC4uLnByb3BzKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZWVkUnVudGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ltYm9sKG5lZWRSdW50aW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVJbXBvcnRNYXAuc2V0KHByb3AsIG5lZWRSdW50aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBidWlsdC1pbiB0cmFuc2Zvcm0sIHRoaXMgaXMgYSB1c2VyIGN1c3RvbSBkaXJlY3RpdmUuXHJcbiAgICAgICAgICAgICAgICBydW50aW1lRGlyZWN0aXZlcy5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHByb3BzRXhwcmVzc2lvbiA9IHVuZGVmaW5lZDtcclxuICAgIC8vIGhhcyB2LWJpbmQ9XCJvYmplY3RcIiBvciB2LW9uPVwib2JqZWN0XCIsIHdyYXAgd2l0aCBtZXJnZVByb3BzXHJcbiAgICBpZiAobWVyZ2VBcmdzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmdlQXJncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgbWVyZ2VBcmdzLCBlbGVtZW50TG9jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBub3RoaW5nIGVsc2UgLSBubyBuZWVkIGZvciBhIG1lcmdlUHJvcHMgY2FsbFxyXG4gICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBtZXJnZUFyZ3NbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpO1xyXG4gICAgfVxyXG4gICAgLy8gcGF0Y2hGbGFnIGFuYWx5c2lzXHJcbiAgICBpZiAoaGFzRHluYW1pY0tleXMpIHtcclxuICAgICAgICBwYXRjaEZsYWcgfD0gMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChoYXNDbGFzc0JpbmRpbmcpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIgLyogQ0xBU1MgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNTdHlsZUJpbmRpbmcpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDQgLyogU1RZTEUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gOCAvKiBQUk9QUyAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZykge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChwYXRjaEZsYWcgPT09IDAgfHwgcGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykgJiZcclxuICAgICAgICAoaGFzUmVmIHx8IGhhc1Zub2RlSG9vayB8fCBydW50aW1lRGlyZWN0aXZlcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSA1MTIgLyogTkVFRF9QQVRDSCAqLztcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IHByb3BzRXhwcmVzc2lvbixcclxuICAgICAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BOYW1lc1xyXG4gICAgfTtcclxufVxyXG4vLyBEZWR1cGUgcHJvcHMgaW4gYW4gb2JqZWN0IGxpdGVyYWwuXHJcbi8vIExpdGVyYWwgZHVwbGljYXRlZCBhdHRyaWJ1dGVzIHdvdWxkIGhhdmUgYmVlbiB3YXJuZWQgZHVyaW5nIHRoZSBwYXJzZSBwaGFzZSxcclxuLy8gaG93ZXZlciwgaXQncyBwb3NzaWJsZSB0byBlbmNvdW50ZXIgZHVwbGljYXRlZCBgb25YWFhgIGhhbmRsZXJzIHdpdGggZGlmZmVyZW50XHJcbi8vIG1vZGlmaWVycy4gV2UgYWxzbyBuZWVkIHRvIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBjbGFzcyAvIHN0eWxlIGF0dHJpYnV0ZXMuXHJcbi8vIC0gb25YWFggaGFuZGxlcnMgLyBzdHlsZTogbWVyZ2UgaW50byBhcnJheVxyXG4vLyAtIGNsYXNzOiBtZXJnZSBpbnRvIHNpbmdsZSBleHByZXNzaW9uIHdpdGggY29uY2F0ZW5hdGlvblxyXG5mdW5jdGlvbiBkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcclxuICAgIGNvbnN0IGtub3duUHJvcHMgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBkZWR1cGVkID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAvLyBkeW5hbWljIGtleXMgYXJlIGFsd2F5cyBhbGxvd2VkXHJcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyB8fCAhcHJvcC5rZXkuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBrbm93blByb3BzLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScgfHwgbmFtZSA9PT0gJ2NsYXNzJyB8fCBuYW1lLnN0YXJ0c1dpdGgoJ29uJykpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlQXNBcnJheShleGlzdGluZywgcHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBkdXBsaWNhdGUsIHNob3VsZCBoYXZlIGVtaXR0ZWQgZXJyb3IgZHVyaW5nIHBhcnNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBrbm93blByb3BzLnNldChuYW1lLCBwcm9wKTtcclxuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWR1cGVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcclxuICAgIGlmIChleGlzdGluZy52YWx1ZS50eXBlID09PSAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleGlzdGluZy52YWx1ZSA9IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSwgZXhpc3RpbmcubG9jKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBkaXJBcmdzID0gW107XHJcbiAgICBjb25zdCBydW50aW1lID0gZGlyZWN0aXZlSW1wb3J0TWFwLmdldChkaXIpO1xyXG4gICAgaWYgKHJ1bnRpbWUpIHtcclxuICAgICAgICAvLyBidWlsdC1pbiBkaXJlY3RpdmUgd2l0aCBydW50aW1lXHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGNvbnRleHQuaGVscGVyU3RyaW5nKHJ1bnRpbWUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaW5qZWN0IHN0YXRlbWVudCBmb3IgcmVzb2x2aW5nIGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0RJUkVDVElWRSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlcy5hZGQoZGlyLm5hbWUpO1xyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2MgfSA9IGRpcjtcclxuICAgIGlmIChkaXIuZXhwKVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuZXhwKTtcclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuYXJnKTtcclxuICAgIH1cclxuICAgIGlmIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzKS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoIWRpci5hcmcpIHtcclxuICAgICAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRydWVFeHByZXNzaW9uID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gICAgICAgIGRpckFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRpci5tb2RpZmllcnMubWFwKG1vZGlmaWVyID0+IGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyLCB0cnVlRXhwcmVzc2lvbikpLCBsb2MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyQXJncywgZGlyLmxvYyk7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhwcm9wcykge1xyXG4gICAgbGV0IHByb3BzTmFtZXNTdHJpbmcgPSBgW2A7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkocHJvcHNbaV0pO1xyXG4gICAgICAgIGlmIChpIDwgbCAtIDEpXHJcbiAgICAgICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gJywgJztcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wc05hbWVzU3RyaW5nICsgYF1gO1xyXG59XG5cbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxyXG4gICAgOiB7fTtcclxuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xuXG5jb25zdCB0cmFuc2Zvcm1TbG90T3V0bGV0ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChpc1Nsb3RPdXRsZXQobm9kZSkpIHtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCBsb2MgfSA9IG5vZGU7XHJcbiAgICAgICAgY29uc3QgeyBzbG90TmFtZSwgc2xvdFByb3BzIH0gPSBwcm9jZXNzU2xvdE91dGxldChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBjb25zdCBzbG90QXJncyA9IFtcclxuICAgICAgICAgICAgY29udGV4dC5wcmVmaXhJZGVudGlmaWVycyA/IGBfY3R4LiRzbG90c2AgOiBgJHNsb3RzYCxcclxuICAgICAgICAgICAgc2xvdE5hbWVcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChzbG90UHJvcHMpIHtcclxuICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChzbG90UHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghc2xvdFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBzbG90QXJncy5wdXNoKGB7fWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFtdLCBjaGlsZHJlbiwgZmFsc2UsIGZhbHNlLCBsb2MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9TTE9UKSwgc2xvdEFyZ3MsIGxvYyk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGxldCBzbG90TmFtZSA9IGBcImRlZmF1bHRcImA7XHJcbiAgICBsZXQgc2xvdFByb3BzID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3Qgbm9uTmFtZVByb3BzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBpZiAocC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ25hbWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBKU09OLnN0cmluZ2lmeShwLnZhbHVlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5uYW1lID0gY2FtZWxpemUocC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBub25OYW1lUHJvcHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmIGlzQmluZEtleShwLmFyZywgJ25hbWUnKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuZXhwKVxyXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gcC5leHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgcC5hcmcgJiYgaXNTdGF0aWNFeHAocC5hcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5hcmcuY29udGVudCA9IGNhbWVsaXplKHAuYXJnLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9uTmFtZVByb3BzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCB7IHByb3BzLCBkaXJlY3RpdmVzIH0gPSBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIG5vbk5hbWVQcm9wcyk7XHJcbiAgICAgICAgc2xvdFByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM1IC8qIFhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovLCBkaXJlY3RpdmVzWzBdLmxvYykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2xvdE5hbWUsXHJcbiAgICAgICAgc2xvdFByb3BzXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeXFxzKmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQsIGF1Z21lbnRvcikgPT4ge1xyXG4gICAgY29uc3QgeyBsb2MsIG1vZGlmaWVycywgYXJnIH0gPSBkaXI7XHJcbiAgICBpZiAoIWRpci5leHAgJiYgIW1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNCAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnROYW1lO1xyXG4gICAgaWYgKGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBjb25zdCByYXdOYW1lID0gYXJnLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIC8vIGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzLCBhdXRvIGNvbnZlcnQgaXQgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbih0b0hhbmRsZXJLZXkoY2FtZWxpemUkMShyYXdOYW1lKSksIHRydWUsIGFyZy5sb2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gIzIzODhcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAke2NvbnRleHQuaGVscGVyU3RyaW5nKFRPX0hBTkRMRVJfS0VZKX0oYCxcclxuICAgICAgICAgICAgICAgIGFyZyxcclxuICAgICAgICAgICAgICAgIGApYFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBhbHJlYWR5IGEgY29tcG91bmQgZXhwcmVzc2lvbi5cclxuICAgICAgICBldmVudE5hbWUgPSBhcmc7XHJcbiAgICAgICAgZXZlbnROYW1lLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgKTtcclxuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4ucHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgLy8gaGFuZGxlciBwcm9jZXNzaW5nXHJcbiAgICBsZXQgZXhwID0gZGlyLmV4cDtcclxuICAgIGlmIChleHAgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xyXG4gICAgICAgIGV4cCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGxldCBzaG91bGRDYWNoZSA9IGNvbnRleHQuY2FjaGVIYW5kbGVycyAmJiAhZXhwO1xyXG4gICAgaWYgKGV4cCkge1xyXG4gICAgICAgIGNvbnN0IGlzTWVtYmVyRXhwID0gaXNNZW1iZXJFeHByZXNzaW9uKGV4cC5jb250ZW50KTtcclxuICAgICAgICBjb25zdCBpc0lubGluZVN0YXRlbWVudCA9ICEoaXNNZW1iZXJFeHAgfHwgZm5FeHBSRS50ZXN0KGV4cC5jb250ZW50KSk7XHJcbiAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID0gZXhwLmNvbnRlbnQuaW5jbHVkZXMoYDtgKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihleHAsIGNvbnRleHQsIGZhbHNlLCBoYXNNdWx0aXBsZVN0YXRlbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNJbmxpbmVTdGF0ZW1lbnQgfHwgKHNob3VsZENhY2hlICYmIGlzTWVtYmVyRXhwKSkge1xyXG4gICAgICAgICAgICAvLyB3cmFwIGlubGluZSBzdGF0ZW1lbnQgaW4gYSBmdW5jdGlvbiBleHByZXNzaW9uXHJcbiAgICAgICAgICAgIGV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgICAgICBgJHtpc0lubGluZVN0YXRlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgID8gYCRldmVudGBcclxuICAgICAgICAgICAgICAgICAgICA6IGAke2BgfSguLi5hcmdzKWB9ID0+ICR7aGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYHtgIDogYChgfWAsXHJcbiAgICAgICAgICAgICAgICBleHAsXHJcbiAgICAgICAgICAgICAgICBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPyBgfWAgOiBgKWBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHJldCA9IHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAoKSA9PiB7fWAsIGZhbHNlLCBsb2MpKVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbiAgICAvLyBhcHBseSBleHRlbmRlZCBjb21waWxlciBhdWdtZW50b3JcclxuICAgIGlmIChhdWdtZW50b3IpIHtcclxuICAgICAgICByZXQgPSBhdWdtZW50b3IocmV0KTtcclxuICAgIH1cclxuICAgIGlmIChzaG91bGRDYWNoZSkge1xyXG4gICAgICAgIC8vIGNhY2hlIGhhbmRsZXJzIHNvIHRoYXQgaXQncyBhbHdheXMgdGhlIHNhbWUgaGFuZGxlciBiZWluZyBwYXNzZWQgZG93bi5cclxuICAgICAgICAvLyB0aGlzIGF2b2lkcyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIHdoZW4gdXNlcnMgdXNlIGlubGluZSBoYW5kbGVycyBvblxyXG4gICAgICAgIC8vIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0LnByb3BzWzBdLnZhbHVlID0gY29udGV4dC5jYWNoZShyZXQucHJvcHNbMF0udmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufTtcblxuLy8gdi1iaW5kIHdpdGhvdXQgYXJnIGlzIGhhbmRsZWQgZGlyZWN0bHkgaW4gLi90cmFuc2Zvcm1FbGVtZW50cy50cyBkdWUgdG8gaXQgYWZmZWN0aW5nXHJcbi8vIGNvZGVnZW4gZm9yIHRoZSBlbnRpcmUgcHJvcHMgb2JqZWN0LiBUaGlzIHRyYW5zZm9ybSBoZXJlIGlzIG9ubHkgZm9yIHYtYmluZFxyXG4vLyAqd2l0aCogYXJncy5cclxuY29uc3QgdHJhbnNmb3JtQmluZCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBtb2RpZmllcnMsIGxvYyB9ID0gZGlyO1xyXG4gICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgIGlmIChhcmcudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAoYCk7XHJcbiAgICAgICAgYXJnLmNoaWxkcmVuLnB1c2goYCkgfHwgXCJcImApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgIGFyZy5jb250ZW50ID0gYCR7YXJnLmNvbnRlbnR9IHx8IFwiXCJgO1xyXG4gICAgfVxyXG4gICAgLy8gLnByb3AgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBkdWUgdG8gbmV3IHBhdGNoIGJlaGF2aW9yXHJcbiAgICAvLyAuc3luYyBpcyByZXBsYWNlZCBieSB2LW1vZGVsOmFyZ1xyXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xyXG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICBhcmcuY29udGVudCA9IGNhbWVsaXplJDEoYXJnLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KCR7YXJnLmNvbnRlbnR9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKENBTUVMSVpFKX0oYCk7XHJcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFleHAgfHxcclxuICAgICAgICAoZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgIWV4cC5jb250ZW50LnRyaW0oKSkpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMyAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSwgbG9jKSldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGV4cCldXHJcbiAgICB9O1xyXG59O1xuXG4vLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGFuZCBleHByZXNzaW9ucyBpbnRvIGEgc2luZ2xlIGV4cHJlc3Npb25cclxuLy8gZS5nLiA8ZGl2PmFiYyB7eyBkIH19IHt7IGUgfX08L2Rpdj4gc2hvdWxkIGhhdmUgYSBzaW5nbGUgZXhwcmVzc2lvbiBub2RlIGFzIGNoaWxkLlxyXG5jb25zdCB0cmFuc2Zvcm1UZXh0ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDAgLyogUk9PVCAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxMSAvKiBGT1IgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEwIC8qIElGX0JSQU5DSCAqLykge1xyXG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIHRyYW5zZm9ybSBvbiBub2RlIGV4aXQgc28gdGhhdCBhbGwgZXhwcmVzc2lvbnMgaGF2ZSBhbHJlYWR5XHJcbiAgICAgICAgLy8gYmVlbiBwcm9jZXNzZWQuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbGV0IGhhc1RleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RleHQoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGNoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gY2hpbGRyZW5baV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBjaGlsZC5sb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbY2hpbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZSBpbnRvIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIuY2hpbGRyZW4ucHVzaChgICsgYCwgbmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFoYXNUZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIHRleHQgY2hpbGQsIGxlYXZlIGl0XHJcbiAgICAgICAgICAgICAgICAvLyBhcy1pcyBzaW5jZSB0aGUgcnVudGltZSBoYXMgZGVkaWNhdGVkIGZhc3QgcGF0aCBmb3IgdGhpcyBieSBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBjb21wb25lbnQgcm9vdCBpdCdzIGFsd2F5cyBub3JtYWxpemVkIGFueXdheS5cclxuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAobm9kZS50eXBlID09PSAwIC8qIFJPT1QgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLykpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZS1jb252ZXJ0IHRleHQgbm9kZXMgaW50byBjcmVhdGVUZXh0Vk5vZGUodGV4dCkgY2FsbHMgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gcnVudGltZSBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dChjaGlsZCkgfHwgY2hpbGQudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbEFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVUZXh0Vk5vZGUgZGVmYXVsdHMgdG8gc2luZ2xlIHdoaXRlc3BhY2UsIHNvIGlmIGl0IGlzIGFcclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3BhY2UgdGhlIGNvZGUgY291bGQgYmUgYW4gZW1wdHkgY2FsbCB0byBzYXZlIGJ5dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAyIC8qIFRFWFQgKi8gfHwgY2hpbGQuY29udGVudCAhPT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGR5bmFtaWMgdGV4dCB3aXRoIGZsYWcgc28gaXQgZ2V0cyBwYXRjaGVkIGluc2lkZSBhIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKDEgLyogVEVYVCAqLyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzEgLyogVEVYVCAqL119ICovYCA6IGBgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAxMiAvKiBURVhUX0NBTEwgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGNoaWxkLmxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGU6IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9URVhUKSwgY2FsbEFyZ3MpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xyXG5jb25zdCB0cmFuc2Zvcm1PbmNlID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBmaW5kRGlyKG5vZGUsICdvbmNlJywgdHJ1ZSkpIHtcclxuICAgICAgICBpZiAoc2Vlbi5oYXMobm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZChub2RlKTtcclxuICAgICAgICBjb250ZXh0LmhlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjdXIuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGN1ci5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuY2FjaGUoY3VyLmNvZGVnZW5Ob2RlLCB0cnVlIC8qIGlzVk5vZGUgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgYXJnIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQwIC8qIFhfVl9NT0RFTF9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXdFeHAgPSBleHAubG9jLnNvdXJjZTtcclxuICAgIGNvbnN0IGV4cFN0cmluZyA9IGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovID8gZXhwLmNvbnRlbnQgOiByYXdFeHA7XHJcbiAgICAvLyBpbSBTRkMgPHNjcmlwdCBzZXR1cD4gaW5saW5lIG1vZGUsIHRoZSBleHAgbWF5IGhhdmUgYmVlbiB0cmFuc2Zvcm1lZCBpbnRvXHJcbiAgICAvLyBfdW5yZWYoZXhwKVxyXG4gICAgY29udGV4dC5iaW5kaW5nTWV0YWRhdGFbcmF3RXhwXTtcclxuICAgIGNvbnN0IG1heWJlUmVmID0gIXRydWUgICAgLyogU0VUVVBfQ09OU1QgKi87XHJcbiAgICBpZiAoIWlzTWVtYmVyRXhwcmVzc2lvbihleHBTdHJpbmcpICYmICFtYXliZVJlZikge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQxIC8qIFhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZXhwLmxvYykpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcE5hbWUgPSBhcmcgPyBhcmcgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdtb2RlbFZhbHVlJywgdHJ1ZSk7XHJcbiAgICBjb25zdCBldmVudE5hbWUgPSBhcmdcclxuICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcclxuICAgICAgICAgICAgPyBgb25VcGRhdGU6JHthcmcuY29udGVudH1gXHJcbiAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFsnXCJvblVwZGF0ZTpcIiArICcsIGFyZ10pXHJcbiAgICAgICAgOiBgb25VcGRhdGU6bW9kZWxWYWx1ZWA7XHJcbiAgICBsZXQgYXNzaWdubWVudEV4cDtcclxuICAgIGNvbnN0IGV2ZW50QXJnID0gY29udGV4dC5pc1RTID8gYCgkZXZlbnQ6IGFueSlgIDogYCRldmVudGA7XHJcbiAgICB7XHJcbiAgICAgICAgYXNzaWdubWVudEV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgIGAke2V2ZW50QXJnfSA9PiAoYCxcclxuICAgICAgICAgICAgZXhwLFxyXG4gICAgICAgICAgICBgID0gJGV2ZW50KWBcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BzID0gW1xyXG4gICAgICAgIC8vIG1vZGVsVmFsdWU6IGZvb1xyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KHByb3BOYW1lLCBkaXIuZXhwKSxcclxuICAgICAgICAvLyBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjogJGV2ZW50ID0+IChmb28gPSAkZXZlbnQpXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoZXZlbnROYW1lLCBhc3NpZ25tZW50RXhwKVxyXG4gICAgXTtcclxuICAgIC8vIG1vZGVsTW9kaWZpZXJzOiB7IGZvbzogdHJ1ZSwgXCJiYXItYmF6XCI6IHRydWUgfVxyXG4gICAgaWYgKGRpci5tb2RpZmllcnMubGVuZ3RoICYmIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzXHJcbiAgICAgICAgICAgIC5tYXAobSA9PiAoaXNTaW1wbGVJZGVudGlmaWVyKG0pID8gbSA6IEpTT04uc3RyaW5naWZ5KG0pKSArIGA6IHRydWVgKVxyXG4gICAgICAgICAgICAuam9pbihgLCBgKTtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBhcmdcclxuICAgICAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXHJcbiAgICAgICAgICAgICAgICA/IGAke2FyZy5jb250ZW50fU1vZGlmaWVyc2BcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFthcmcsICcgKyBcIk1vZGlmaWVyc1wiJ10pXHJcbiAgICAgICAgICAgIDogYG1vZGVsTW9kaWZpZXJzYDtcclxuICAgICAgICBwcm9wcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyc0tleSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgeyAke21vZGlmaWVyc30gfWAsIGZhbHNlLCBkaXIubG9jLCAyIC8qIENBTl9IT0lTVCAqLykpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcyhwcm9wcyk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzID0gW10pIHtcclxuICAgIHJldHVybiB7IHByb3BzIH07XHJcbn1cblxuZnVuY3Rpb24gZ2V0QmFzZVRyYW5zZm9ybVByZXNldChwcmVmaXhJZGVudGlmaWVycykge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9uY2UsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUlmLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1Gb3IsXHJcbiAgICAgICAgICAgIC4uLigocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IFt0cmFuc2Zvcm1FeHByZXNzaW9uXVxyXG4gICAgICAgICAgICAgICAgICAgIDogW10pLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1TbG90T3V0bGV0LFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1FbGVtZW50LFxyXG4gICAgICAgICAgICB0cmFja1Nsb3RTY29wZXMsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVRleHRcclxuICAgICAgICBdLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb246IHRyYW5zZm9ybU9uLFxyXG4gICAgICAgICAgICBiaW5kOiB0cmFuc2Zvcm1CaW5kLFxyXG4gICAgICAgICAgICBtb2RlbDogdHJhbnNmb3JtTW9kZWxcclxuICAgICAgICB9XHJcbiAgICBdO1xyXG59XHJcbi8vIHdlIG5hbWUgaXQgYGJhc2VDb21waWxlYCBzbyB0aGF0IGhpZ2hlciBvcmRlciBjb21waWxlcnMgbGlrZVxyXG4vLyBAdnVlL2NvbXBpbGVyLWRvbSBjYW4gZXhwb3J0IGBjb21waWxlYCB3aGlsZSByZS1leHBvcnRpbmcgZXZlcnl0aGluZyBlbHNlLlxyXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xyXG4gICAgY29uc3QgaXNNb2R1bGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnbW9kdWxlJztcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeElkZW50aWZpZXJzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NSAvKiBYX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTW9kdWxlTW9kZSkge1xyXG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDYgLyogWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcHJlZml4SWRlbnRpZmllcnMgPSAhdHJ1ZSA7XHJcbiAgICBpZiAob3B0aW9ucy5jYWNoZUhhbmRsZXJzKSB7XHJcbiAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ3IC8qIFhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5zY29wZUlkICYmICFpc01vZHVsZU1vZGUpIHtcclxuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDggLyogWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhc3QgPSBpc1N0cmluZyh0ZW1wbGF0ZSkgPyBiYXNlUGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIDogdGVtcGxhdGU7XHJcbiAgICBjb25zdCBbbm9kZVRyYW5zZm9ybXMsIGRpcmVjdGl2ZVRyYW5zZm9ybXNdID0gZ2V0QmFzZVRyYW5zZm9ybVByZXNldCgpO1xyXG4gICAgdHJhbnNmb3JtKGFzdCwgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAgICAgLi4ubm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdKSAvLyB1c2VyIHRyYW5zZm9ybXNcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgZGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9IC8vIHVzZXIgdHJhbnNmb3Jtc1xyXG4gICAgICAgIClcclxuICAgIH0pKTtcclxuICAgIHJldHVybiBnZW5lcmF0ZShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzXHJcbiAgICB9KSk7XHJcbn1cblxuY29uc3Qgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSA9ICgpID0+ICh7IHByb3BzOiBbXSB9KTtcblxuZXhwb3J0IHsgQkFTRV9UUkFOU0lUSU9OLCBDQU1FTElaRSwgQ0FQSVRBTElaRSwgQ1JFQVRFX0JMT0NLLCBDUkVBVEVfQ09NTUVOVCwgQ1JFQVRFX1NMT1RTLCBDUkVBVEVfU1RBVElDLCBDUkVBVEVfVEVYVCwgQ1JFQVRFX1ZOT0RFLCBGUkFHTUVOVCwgSVNfUkVGLCBLRUVQX0FMSVZFLCBNRVJHRV9QUk9QUywgT1BFTl9CTE9DSywgUE9QX1NDT1BFX0lELCBQVVNIX1NDT1BFX0lELCBSRU5ERVJfTElTVCwgUkVOREVSX1NMT1QsIFJFU09MVkVfQ09NUE9ORU5ULCBSRVNPTFZFX0RJUkVDVElWRSwgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCwgU0VUX0JMT0NLX1RSQUNLSU5HLCBTVVNQRU5TRSwgVEVMRVBPUlQsIFRPX0RJU1BMQVlfU1RSSU5HLCBUT19IQU5ETEVSUywgVE9fSEFORExFUl9LRVksIFVOUkVGLCBXSVRIX0NUWCwgV0lUSF9ESVJFQ1RJVkVTLCBXSVRIX1NDT1BFX0lELCBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUsIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbiwgYXNzZXJ0LCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlLCBidWlsZFByb3BzLCBidWlsZFNsb3RzLCBjcmVhdGVBcnJheUV4cHJlc3Npb24sIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uLCBjcmVhdGVCbG9ja1N0YXRlbWVudCwgY3JlYXRlQ2FjaGVFeHByZXNzaW9uLCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24sIGNyZWF0ZUZvckxvb3BQYXJhbXMsIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiwgY3JlYXRlSWZTdGF0ZW1lbnQsIGNyZWF0ZUludGVycG9sYXRpb24sIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24sIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQsIGNyZWF0ZVJvb3QsIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbiwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSwgY3JlYXRlVGVtcGxhdGVMaXRlcmFsLCBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0LCBjcmVhdGVWTm9kZUNhbGwsIGZpbmREaXIsIGZpbmRQcm9wLCBnZW5lcmF0ZSwgZ2V0QmFzZVRyYW5zZm9ybVByZXNldCwgZ2V0SW5uZXJSYW5nZSwgaGFzRHluYW1pY0tleVZCaW5kLCBoYXNTY29wZVJlZiwgaGVscGVyTmFtZU1hcCwgaW5qZWN0UHJvcCwgaXNCaW5kS2V5LCBpc0J1aWx0SW5UeXBlLCBpc0NvcmVDb21wb25lbnQsIGlzTWVtYmVyRXhwcmVzc2lvbiwgaXNTaW1wbGVJZGVudGlmaWVyLCBpc1Nsb3RPdXRsZXQsIGlzU3RhdGljRXhwLCBpc1RlbXBsYXRlTm9kZSwgaXNUZXh0LCBpc1ZTbG90LCBsb2NTdHViLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBwcm9jZXNzRXhwcmVzc2lvbiwgcHJvY2Vzc0ZvciwgcHJvY2Vzc0lmLCBwcm9jZXNzU2xvdE91dGxldCwgcmVnaXN0ZXJSdW50aW1lSGVscGVycywgcmVzb2x2ZUNvbXBvbmVudFR5cGUsIHRvVmFsaWRBc3NldElkLCB0cmFja1Nsb3RTY29wZXMsIHRyYWNrVkZvclNsb3RTY29wZXMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtQmluZCwgdHJhbnNmb3JtRWxlbWVudCwgdHJhbnNmb3JtRXhwcmVzc2lvbiwgdHJhbnNmb3JtTW9kZWwsIHRyYW5zZm9ybU9uLCB0cmF2ZXJzZU5vZGUgfTtcbiIsImltcG9ydCB7IHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIGlzQnVpbHRJblR5cGUsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgVE9fRElTUExBWV9TVFJJTkcsIHRyYW5zZm9ybU1vZGVsIGFzIHRyYW5zZm9ybU1vZGVsJDEsIGZpbmRQcm9wLCBoYXNEeW5hbWljS2V5VkJpbmQsIHRyYW5zZm9ybU9uIGFzIHRyYW5zZm9ybU9uJDEsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgaXNTdGF0aWNFeHAsIG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sIGJhc2VDb21waWxlLCBiYXNlUGFyc2UgfSBmcm9tICdAdnVlL2NvbXBpbGVyLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcbmltcG9ydCB7IGlzVm9pZFRhZywgaXNIVE1MVGFnLCBpc1NWR1RhZywgbWFrZU1hcCwgcGFyc2VTdHJpbmdTdHlsZSwgY2FwaXRhbGl6ZSwgZXh0ZW5kIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBWX01PREVMX1JBRElPID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxSYWRpb2AgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfQ0hFQ0tCT1ggPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbENoZWNrYm94YCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9URVhUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxUZXh0YCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9TRUxFQ1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFNlbGVjdGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfRFlOQU1JQyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsRHluYW1pY2AgOiBgYCk7XHJcbmNvbnN0IFZfT05fV0lUSF9NT0RJRklFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZPbk1vZGlmaWVyc0d1YXJkYCA6IGBgKTtcclxuY29uc3QgVl9PTl9XSVRIX0tFWVMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZPbktleXNHdWFyZGAgOiBgYCk7XHJcbmNvbnN0IFZfU0hPVyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdlNob3dgIDogYGApO1xyXG5jb25zdCBUUkFOU0lUSU9OID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uYCA6IGBgKTtcclxuY29uc3QgVFJBTlNJVElPTl9HUk9VUCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVHJhbnNpdGlvbkdyb3VwYCA6IGBgKTtcclxucmVnaXN0ZXJSdW50aW1lSGVscGVycyh7XHJcbiAgICBbVl9NT0RFTF9SQURJT106IGB2TW9kZWxSYWRpb2AsXHJcbiAgICBbVl9NT0RFTF9DSEVDS0JPWF06IGB2TW9kZWxDaGVja2JveGAsXHJcbiAgICBbVl9NT0RFTF9URVhUXTogYHZNb2RlbFRleHRgLFxyXG4gICAgW1ZfTU9ERUxfU0VMRUNUXTogYHZNb2RlbFNlbGVjdGAsXHJcbiAgICBbVl9NT0RFTF9EWU5BTUlDXTogYHZNb2RlbER5bmFtaWNgLFxyXG4gICAgW1ZfT05fV0lUSF9NT0RJRklFUlNdOiBgd2l0aE1vZGlmaWVyc2AsXHJcbiAgICBbVl9PTl9XSVRIX0tFWVNdOiBgd2l0aEtleXNgLFxyXG4gICAgW1ZfU0hPV106IGB2U2hvd2AsXHJcbiAgICBbVFJBTlNJVElPTl06IGBUcmFuc2l0aW9uYCxcclxuICAgIFtUUkFOU0lUSU9OX0dST1VQXTogYFRyYW5zaXRpb25Hcm91cGBcclxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5sZXQgZGVjb2RlcjtcclxuZnVuY3Rpb24gZGVjb2RlSHRtbEJyb3dzZXIocmF3KSB7XHJcbiAgICAoZGVjb2RlciB8fCAoZGVjb2RlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSkuaW5uZXJIVE1MID0gcmF3O1xyXG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnQ7XHJcbn1cblxuY29uc3QgaXNSYXdUZXh0Q29udGFpbmVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzdHlsZSxpZnJhbWUsc2NyaXB0LG5vc2NyaXB0JywgdHJ1ZSk7XHJcbmNvbnN0IHBhcnNlck9wdGlvbnMgPSB7XHJcbiAgICBpc1ZvaWRUYWcsXHJcbiAgICBpc05hdGl2ZVRhZzogdGFnID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXHJcbiAgICBpc1ByZVRhZzogdGFnID0+IHRhZyA9PT0gJ3ByZScsXHJcbiAgICBkZWNvZGVFbnRpdGllczogZGVjb2RlSHRtbEJyb3dzZXIgLFxyXG4gICAgaXNCdWlsdEluQ29tcG9uZW50OiAodGFnKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbmApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgYFRyYW5zaXRpb25Hcm91cGApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OX0dST1VQO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjdHJlZS1jb25zdHJ1Y3Rpb24tZGlzcGF0Y2hlclxyXG4gICAgZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KSB7XHJcbiAgICAgICAgbGV0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBIVE1MICovO1xyXG4gICAgICAgIGlmIChwYXJlbnQgJiYgbnMgPT09IDIgLyogTUFUSF9NTCAqLykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2Fubm90YXRpb24teG1sJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTVkcgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnByb3BzLnNvbWUoYSA9PiBhLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYS5uYW1lID09PSAnZW5jb2RpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYS52YWx1ZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGEudmFsdWUuY29udGVudCA9PT0gJ3RleHQvaHRtbCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS52YWx1ZS5jb250ZW50ID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoL15tKD86W2lvbnNdfHRleHQpJC8udGVzdChwYXJlbnQudGFnKSAmJlxyXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWdseXBoJyAmJlxyXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWFsaWdubWFyaycpIHtcclxuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCAmJiBucyA9PT0gMSAvKiBTVkcgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC50YWcgPT09ICdmb3JlaWduT2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnRhZyA9PT0gJ2Rlc2MnIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobnMgPT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU1ZHICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogTUFUSF9NTCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnM7XHJcbiAgICB9LFxyXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3BhcnNpbmctaHRtbC1mcmFnbWVudHNcclxuICAgIGdldFRleHRNb2RlKHsgdGFnLCBucyB9KSB7XHJcbiAgICAgICAgaWYgKG5zID09PSAwIC8qIEhUTUwgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJyB8fCB0YWcgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFJDREFUQSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNSYXdUZXh0Q29udGFpbmVyKHRhZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFJBV1RFWFQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDAgLyogREFUQSAqLztcclxuICAgIH1cclxufTtcblxuLy8gUGFyc2UgaW5saW5lIENTUyBzdHJpbmdzIGZvciBzdGF0aWMgc3R5bGUgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdC5cclxuLy8gVGhpcyBpcyBhIE5vZGVUcmFuc2Zvcm0gc2luY2UgaXQgd29ya3Mgb24gdGhlIHN0YXRpYyBgc3R5bGVgIGF0dHJpYnV0ZSBhbmRcclxuLy8gY29udmVydHMgaXQgaW50byBhIGR5bmFtaWMgZXF1aXZhbGVudDpcclxuLy8gc3R5bGU9XCJjb2xvcjogcmVkXCIgLT4gOnN0eWxlPSd7IFwiY29sb3JcIjogXCJyZWRcIiB9J1xyXG4vLyBJdCBpcyB0aGVuIHByb2Nlc3NlZCBieSBgdHJhbnNmb3JtRWxlbWVudGAgYW5kIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWRcclxuLy8gcHJvcHMuXHJcbmNvbnN0IHRyYW5zZm9ybVN0eWxlID0gbm9kZSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICBub2RlLnByb3BzLmZvckVhY2goKHAsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiYgcC5uYW1lID09PSAnc3R5bGUnICYmIHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcCB3aXRoIGFuIGV4cHJlc3Npb24gbm9kZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wc1tpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIERJUkVDVElWRSAqLyxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYmluZGAsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBzdHlsZWAsIHRydWUsIHAubG9jKSxcclxuICAgICAgICAgICAgICAgICAgICBleHA6IHBhcnNlSW5saW5lQ1NTKHAudmFsdWUuY29udGVudCwgcC5sb2MpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jOiBwLmxvY1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBwYXJzZUlubGluZUNTUyA9IChjc3NUZXh0LCBsb2MpID0+IHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksIGZhbHNlLCBsb2MsIDMgLyogQ0FOX1NUUklOR0lGWSAqLyk7XHJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSA/IERPTUVycm9yTWVzc2FnZXMgOiB1bmRlZmluZWQpO1xyXG59XHJcbmNvbnN0IERPTUVycm9yTWVzc2FnZXMgPSB7XHJcbiAgICBbNDkgLyogWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqL106IGB2LWh0bWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTAgLyogWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqL106IGB2LWh0bWwgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXHJcbiAgICBbNTEgLyogWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqL106IGB2LXRleHQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTIgLyogWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqL106IGB2LXRleHQgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXHJcbiAgICBbNTMgLyogWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbiBvbmx5IGJlIHVzZWQgb24gPGlucHV0PiwgPHRleHRhcmVhPiBhbmQgPHNlbGVjdD4gZWxlbWVudHMuYCxcclxuICAgIFs1NCAvKiBYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIHBsYWluIGVsZW1lbnRzLmAsXHJcbiAgICBbNTUgLyogWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIGZpbGUgaW5wdXRzIHNpbmNlIHRoZXkgYXJlIHJlYWQtb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLFxyXG4gICAgWzU2IC8qIFhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRSAqL106IGBVbm5lY2Vzc2FyeSB2YWx1ZSBiaW5kaW5nIHVzZWQgYWxvbmdzaWRlIHYtbW9kZWwuIEl0IHdpbGwgaW50ZXJmZXJlIHdpdGggdi1tb2RlbCdzIGJlaGF2aW9yLmAsXHJcbiAgICBbNTcgLyogWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqL106IGB2LXNob3cgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTggLyogWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPFRyYW5zaXRpb24+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudCBvciBjb21wb25lbnQuYCxcclxuICAgIFs1OSAvKiBYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovXTogYFRhZ3Mgd2l0aCBzaWRlIGVmZmVjdCAoPHNjcmlwdD4gYW5kIDxzdHlsZT4pIGFyZSBpZ25vcmVkIGluIGNsaWVudCBjb21wb25lbnQgdGVtcGxhdGVzLmBcclxufTtcblxuY29uc3QgdHJhbnNmb3JtVkh0bWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDQ5IC8qIFhfVl9IVE1MX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTAgLyogWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBpbm5lckhUTUxgLCB0cnVlLCBsb2MpLCBleHAgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSkpXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtVlRleHQgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUxIC8qIFhfVl9URVhUX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTIgLyogWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0ZXh0Q29udGVudGAsIHRydWUpLCBleHBcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXJTdHJpbmcoVE9fRElTUExBWV9TVFJJTkcpLCBbZXhwXSwgbG9jKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IGJhc2VSZXN1bHQgPSB0cmFuc2Zvcm1Nb2RlbCQxKGRpciwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAvLyBiYXNlIHRyYW5zZm9ybSBoYXMgZXJyb3JzIE9SIGNvbXBvbmVudCB2LW1vZGVsIChvbmx5IG5lZWQgcHJvcHMpXHJcbiAgICBpZiAoIWJhc2VSZXN1bHQucHJvcHMubGVuZ3RoIHx8IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxuICAgIH1cclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTQgLyogWF9WX01PREVMX0FSR19PTl9FTEVNRU5UICovLCBkaXIuYXJnLmxvYykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVkVmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaW5kUHJvcChub2RlLCAndmFsdWUnKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTYgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovLCB2YWx1ZS5sb2MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGNvbnRleHQuaXNDdXN0b21FbGVtZW50KHRhZyk7XHJcbiAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8XHJcbiAgICAgICAgdGFnID09PSAndGV4dGFyZWEnIHx8XHJcbiAgICAgICAgdGFnID09PSAnc2VsZWN0JyB8fFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfVEVYVDtcclxuICAgICAgICBsZXQgaXNJbnZhbGlkVHlwZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBmaW5kUHJvcChub2RlLCBgdHlwZWApO1xyXG4gICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA6dHlwZT1cImZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlLnZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1JBRElPO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZFR5cGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTUgLyogWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBoYXMgYmluZGluZ3Mgd2l0aCBkeW5hbWljIGtleXMsIHdoaWNoIGNhbiBwb3NzaWJseSBjb250YWluXHJcbiAgICAgICAgICAgICAgICAvLyBcInR5cGVcIi5cclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9TRUxFQ1Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IHJ1bnRpbWUgZGlyZWN0aXZlXHJcbiAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBoZWxwZXIgc3ltYm9sIHZpYSBuZWVkUnVudGltZVxyXG4gICAgICAgIC8vIHRoZSBpbXBvcnQgd2lsbCByZXBsYWNlZCBhIHJlc29sdmVEaXJlY3RpdmUgY2FsbC5cclxuICAgICAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgYmFzZVJlc3VsdC5uZWVkUnVudGltZSA9IGNvbnRleHQuaGVscGVyKGRpcmVjdGl2ZVRvVXNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MyAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovLCBkaXIubG9jKSk7XHJcbiAgICB9XHJcbiAgICAvLyBuYXRpdmUgdm1vZGVsIGRvZXNuJ3QgbmVlZCB0aGUgYG1vZGVsVmFsdWVgIHByb3BzIHNpbmNlIHRoZXkgYXJlIGFsc29cclxuICAgIC8vIHBhc3NlZCB0byB0aGUgcnVudGltZSBhcyBgYmluZGluZy52YWx1ZWAuIHJlbW92aW5nIGl0IHJlZHVjZXMgY29kZSBzaXplLlxyXG4gICAgYmFzZVJlc3VsdC5wcm9wcyA9IGJhc2VSZXN1bHQucHJvcHMuZmlsdGVyKHAgPT4gIShwLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgcC5rZXkuY29udGVudCA9PT0gJ21vZGVsVmFsdWUnKSk7XHJcbiAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxufTtcblxuY29uc3QgaXNFdmVudE9wdGlvbk1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBwYXNzaXZlLG9uY2UsY2FwdHVyZWApO1xyXG5jb25zdCBpc05vbktleU1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XHJcbmBzdG9wLHByZXZlbnQsc2VsZixgICtcclxuICAgIC8vIHN5c3RlbSBtb2RpZmllcnMgKyBleGFjdFxyXG4gICAgYGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QsYCArXHJcbiAgICAvLyBtb3VzZVxyXG4gICAgYG1pZGRsZWApO1xyXG4vLyBsZWZ0ICYgcmlnaHQgY291bGQgYmUgbW91c2Ugb3Iga2V5IG1vZGlmaWVycyBiYXNlZCBvbiBldmVudCB0eXBlXHJcbmNvbnN0IG1heWJlS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2xlZnQscmlnaHQnKTtcclxuY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBvbmtleXVwLG9ua2V5ZG93bixvbmtleXByZXNzYCwgdHJ1ZSk7XHJcbmNvbnN0IHJlc29sdmVNb2RpZmllcnMgPSAoa2V5LCBtb2RpZmllcnMpID0+IHtcclxuICAgIGNvbnN0IGtleU1vZGlmaWVycyA9IFtdO1xyXG4gICAgY29uc3Qgbm9uS2V5TW9kaWZpZXJzID0gW107XHJcbiAgICBjb25zdCBldmVudE9wdGlvbk1vZGlmaWVycyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllciA9IG1vZGlmaWVyc1tpXTtcclxuICAgICAgICBpZiAoaXNFdmVudE9wdGlvbk1vZGlmaWVyKG1vZGlmaWVyKSkge1xyXG4gICAgICAgICAgICAvLyBldmVudE9wdGlvbk1vZGlmaWVyczogbW9kaWZpZXJzIGZvciBhZGRFdmVudExpc3RlbmVyKCkgb3B0aW9ucyxcclxuICAgICAgICAgICAgLy8gZS5nLiAucGFzc2l2ZSAmIC5jYXB0dXJlXHJcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcnVudGltZU1vZGlmaWVyczogbW9kaWZpZXJzIHRoYXQgbmVlZHMgcnVudGltZSBndWFyZHNcclxuICAgICAgICAgICAgaWYgKG1heWJlS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTm9uS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBrZXlNb2RpZmllcnMsXHJcbiAgICAgICAgbm9uS2V5TW9kaWZpZXJzLFxyXG4gICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1DbGljayA9IChrZXksIGV2ZW50KSA9PiB7XHJcbiAgICBjb25zdCBpc1N0YXRpY0NsaWNrID0gaXNTdGF0aWNFeHAoa2V5KSAmJiBrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSAnb25jbGljayc7XHJcbiAgICByZXR1cm4gaXNTdGF0aWNDbGlja1xyXG4gICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudCwgdHJ1ZSlcclxuICAgICAgICA6IGtleS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovXHJcbiAgICAgICAgICAgID8gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAoYCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGApID09PSBcIm9uQ2xpY2tcIiA/IFwiJHtldmVudH1cIiA6IChgLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgYClgXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIDoga2V5O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIHJldHVybiB0cmFuc2Zvcm1PbiQxKGRpciwgbm9kZSwgY29udGV4dCwgYmFzZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGRpcjtcclxuICAgICAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG4gICAgICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XHJcbiAgICAgICAgY29uc3QgeyBrZXlNb2RpZmllcnMsIG5vbktleU1vZGlmaWVycywgZXZlbnRPcHRpb25Nb2RpZmllcnMgfSA9IHJlc29sdmVNb2RpZmllcnMoa2V5LCBtb2RpZmllcnMpO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ3JpZ2h0JykpIHtcclxuICAgICAgICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdtaWRkbGUnKSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9NT0RJRklFUlMpLCBbXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyRXhwLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9uS2V5TW9kaWZpZXJzKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gaWYgZXZlbnQgbmFtZSBpcyBkeW5hbWljLCBhbHdheXMgd3JhcCB3aXRoIGtleXMgZ3VhcmRcclxuICAgICAgICAgICAgKCFpc1N0YXRpY0V4cChrZXkpIHx8IGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfS0VZUyksIFtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRPcHRpb25Nb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyUG9zdGZpeCA9IGV2ZW50T3B0aW9uTW9kaWZpZXJzLm1hcChjYXBpdGFsaXplKS5qb2luKCcnKTtcclxuICAgICAgICAgICAga2V5ID0gaXNTdGF0aWNFeHAoa2V5KVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAke2tleS5jb250ZW50fSR7bW9kaWZpZXJQb3N0Zml4fWAsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYChgLCBrZXksIGApICsgXCIke21vZGlmaWVyUG9zdGZpeH1cImBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIGhhbmRsZXJFeHApXVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTcgLyogWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXSxcclxuICAgICAgICBuZWVkUnVudGltZTogY29udGV4dC5oZWxwZXIoVl9TSE9XKVxyXG4gICAgfTtcclxufTtcblxuY29uc3Qgd2FyblRyYW5zaXRpb25DaGlsZHJlbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQobm9kZS50YWcpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTggLyogWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gaGFzTXVsdGlwbGVDaGlsZHJlbihub2RlKSB7XHJcbiAgICAvLyAjMTM1MiBmaWx0ZXIgb3V0IHBvdGVudGlhbCBjb21tZW50IG5vZGVzLlxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSAobm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pKTtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICByZXR1cm4gKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fFxyXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDExIC8qIEZPUiAqLyB8fFxyXG4gICAgICAgIChjaGlsZC50eXBlID09PSA5IC8qIElGICovICYmIGNoaWxkLmJyYW5jaGVzLnNvbWUoaGFzTXVsdGlwbGVDaGlsZHJlbikpKTtcclxufVxuXG5jb25zdCBpZ25vcmVTaWRlRWZmZWN0VGFncyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIChub2RlLnRhZyA9PT0gJ3NjcmlwdCcgfHwgbm9kZS50YWcgPT09ICdzdHlsZScpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTkgLyogWF9JR05PUkVEX1NJREVfRUZGRUNUX1RBRyAqLywgbm9kZS5sb2MpKTtcclxuICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcclxuICAgIH1cclxufTtcblxuY29uc3QgRE9NTm9kZVRyYW5zZm9ybXMgPSBbXHJcbiAgICB0cmFuc2Zvcm1TdHlsZSxcclxuICAgIC4uLigocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBbd2FyblRyYW5zaXRpb25DaGlsZHJlbl0gOiBbXSlcclxuXTtcclxuY29uc3QgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcyA9IHtcclxuICAgIGNsb2FrOiBub29wRGlyZWN0aXZlVHJhbnNmb3JtLFxyXG4gICAgaHRtbDogdHJhbnNmb3JtVkh0bWwsXHJcbiAgICB0ZXh0OiB0cmFuc2Zvcm1WVGV4dCxcclxuICAgIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbCxcclxuICAgIG9uOiB0cmFuc2Zvcm1PbixcclxuICAgIHNob3c6IHRyYW5zZm9ybVNob3dcclxufTtcclxuZnVuY3Rpb24gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucywge1xyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSA8c2NyaXB0PiBhbmQgPHRhZz5cclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgcHV0IGluc2lkZSBET01Ob2RlVHJhbnNmb3JtcyBiZWNhdXNlIHRoYXQgbGlzdCBpcyB1c2VkXHJcbiAgICAgICAgICAgIC8vIGJ5IGNvbXBpbGVyLXNzciB0byBnZW5lcmF0ZSB2bm9kZSBmYWxsYmFjayBicmFuY2hlc1xyXG4gICAgICAgICAgICBpZ25vcmVTaWRlRWZmZWN0VGFncyxcclxuICAgICAgICAgICAgLi4uRE9NTm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdKVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogZXh0ZW5kKHt9LCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge30pLFxyXG4gICAgICAgIHRyYW5zZm9ybUhvaXN0OiBudWxsIFxyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBiYXNlUGFyc2UodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucykpO1xyXG59XG5cbmV4cG9ydCB7IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsIERPTU5vZGVUcmFuc2Zvcm1zLCBUUkFOU0lUSU9OLCBUUkFOU0lUSU9OX0dST1VQLCBWX01PREVMX0NIRUNLQk9YLCBWX01PREVMX0RZTkFNSUMsIFZfTU9ERUxfUkFESU8sIFZfTU9ERUxfU0VMRUNULCBWX01PREVMX1RFWFQsIFZfT05fV0lUSF9LRVlTLCBWX09OX1dJVEhfTU9ESUZJRVJTLCBWX1NIT1csIGNvbXBpbGUsIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IsIHBhcnNlLCBwYXJzZXJPcHRpb25zLCB0cmFuc2Zvcm1TdHlsZSB9O1xuIiwiaW1wb3J0ICogYXMgcnVudGltZURvbSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4sIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGNvbXBpbGUgfSBmcm9tICdAdnVlL2NvbXBpbGVyLWRvbSc7XG5pbXBvcnQgeyBpc1N0cmluZywgTk9PUCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcclxuICAgIHtcclxuICAgICAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbn1cblxuLy8gVGhpcyBlbnRyeSBpcyB0aGUgXCJmdWxsLWJ1aWxkXCIgdGhhdCBpbmNsdWRlcyBib3RoIHRoZSBydW50aW1lXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGluaXREZXYoKTtcclxufVxyXG5jb25zdCBjb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246IGAsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIE5PT1A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5ID0gdGVtcGxhdGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjb21waWxlQ2FjaGVba2V5XTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKHRlbXBsYXRlWzBdID09PSAnIycpIHtcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGVtcGxhdGUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWVsKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke3RlbXBsYXRlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cclxuICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3MgcmVuZGVyZWRcclxuICAgICAgICAvLyBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgdGVtcGxhdGUgPSBlbCA/IGVsLmlubmVySFRNTCA6IGBgO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBjb2RlIH0gPSBjb21waWxlKHRlbXBsYXRlLCBleHRlbmQoe1xyXG4gICAgICAgIGhvaXN0U3RhdGljOiB0cnVlLFxyXG4gICAgICAgIG9uRXJyb3IoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVGcmFtZSA9IGVyci5sb2MgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZXJyLmxvYy5zdGFydC5vZmZzZXQsIGVyci5sb2MuZW5kLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGNvZGVGcmFtZSA/IGAke21lc3NhZ2V9XFxuJHtjb2RlRnJhbWV9YCA6IG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIG9wdGlvbnMpKTtcclxuICAgIC8vIFRoZSB3aWxkY2FyZCBpbXBvcnQgcmVzdWx0cyBpbiBhIGh1Z2Ugb2JqZWN0IHdpdGggZXZlcnkgZXhwb3J0XHJcbiAgICAvLyB3aXRoIGtleXMgdGhhdCBjYW5ub3QgYmUgbWFuZ2xlZCwgYW5kIGNhbiBiZSBxdWl0ZSBoZWF2eSBzaXplLXdpc2UuXHJcbiAgICAvLyBJbiB0aGUgZ2xvYmFsIGJ1aWxkIHdlIGtub3cgYFZ1ZWAgaXMgYXZhaWxhYmxlIGdsb2JhbGx5IHNvIHdlIGNhbiBhdm9pZFxyXG4gICAgLy8gdGhlIHdpbGRjYXJkIG9iamVjdC5cclxuICAgIGNvbnN0IHJlbmRlciA9IChuZXcgRnVuY3Rpb24oJ1Z1ZScsIGNvZGUpKHJ1bnRpbWVEb20pKTtcclxuICAgIHJlbmRlci5fcmMgPSB0cnVlO1xyXG4gICAgcmV0dXJuIChjb21waWxlQ2FjaGVba2V5XSA9IHJlbmRlcik7XHJcbn1cclxucmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoY29tcGlsZVRvRnVuY3Rpb24pO1xuXG5leHBvcnQgeyBjb21waWxlVG9GdW5jdGlvbiBhcyBjb21waWxlIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--8-0!./src/layouts/Main.vue?vue&type=template&id=74babf21\n\n\nvar _hoisted_1 = /*#__PURE__*/Object(vue_esm_bundler["d" /* createTextVNode */])("Home");\n\nvar _hoisted_2 = /*#__PURE__*/Object(vue_esm_bundler["d" /* createTextVNode */])("About");\n\nvar _hoisted_3 = /*#__PURE__*/Object(vue_esm_bundler["d" /* createTextVNode */])("Under Construction");\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_v_link = Object(vue_esm_bundler["j" /* resolveComponent */])("v-link");\n\n  return Object(vue_esm_bundler["g" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(vue_esm_bundler["a" /* Fragment */], null, [Object(vue_esm_bundler["e" /* createVNode */])("ul", null, [Object(vue_esm_bundler["e" /* createVNode */])("li", null, [Object(vue_esm_bundler["e" /* createVNode */])(_component_v_link, {\n    href: "/"\n  }, {\n    "default": Object(vue_esm_bundler["l" /* withCtx */])(function () {\n      return [_hoisted_1];\n    }),\n    _: 1\n    /* STABLE */\n\n  })]), Object(vue_esm_bundler["e" /* createVNode */])("li", null, [Object(vue_esm_bundler["e" /* createVNode */])(_component_v_link, {\n    href: "/about"\n  }, {\n    "default": Object(vue_esm_bundler["l" /* withCtx */])(function () {\n      return [_hoisted_2];\n    }),\n    _: 1\n    /* STABLE */\n\n  })]), Object(vue_esm_bundler["e" /* createVNode */])("li", null, [Object(vue_esm_bundler["e" /* createVNode */])(_component_v_link, {\n    href: "/foo"\n  }, {\n    "default": Object(vue_esm_bundler["l" /* withCtx */])(function () {\n      return [_hoisted_3];\n    }),\n    _: 1\n    /* STABLE */\n\n  })])]), Object(vue_esm_bundler["i" /* renderSlot */])(_ctx.$slots, "default")], 64\n  /* STABLE_FRAGMENT */\n  );\n}\n// CONCATENATED MODULE: ./src/layouts/Main.vue?vue&type=template&id=74babf21\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--8-0!./src/components/VLink.vue?vue&type=template&id=19fc4ad4\n\nfunction VLinkvue_type_template_id_19fc4ad4_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(vue_esm_bundler["g" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("a", {\n    href: $props.href,\n    onClick: _cache[1] || (_cache[1] = Object(vue_esm_bundler["m" /* withModifiers */])(function () {\n      return $options.go && $options.go.apply($options, arguments);\n    }, ["prevent"]))\n  }, [Object(vue_esm_bundler["i" /* renderSlot */])(_ctx.$slots, "default")], 8\n  /* PROPS */\n  , ["href"]);\n}\n// CONCATENATED MODULE: ./src/components/VLink.vue?vue&type=template&id=19fc4ad4\n\n// EXTERNAL MODULE: ./src/routes.js\nvar routes = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--8-0!./src/components/VLink.vue?vue&type=script&lang=js\n\n/* harmony default export */ var VLinkvue_type_script_lang_js = ({\n  props: {\n    href: {\n      type: String,\n      required: true\n    }\n  },\n  methods: {\n    go: function go() {\n      this.$root.currentRoute = this.href;\n      window.history.pushState(null, routes["a" /* default */][this.href], this.href);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/VLink.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/components/VLink.vue\n\n\n\nVLinkvue_type_script_lang_js.render = VLinkvue_type_template_id_19fc4ad4_render\n\n/* harmony default export */ var VLink = (VLinkvue_type_script_lang_js);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--8-0!./src/layouts/Main.vue?vue&type=script&lang=js\n\n/* harmony default export */ var Mainvue_type_script_lang_js = ({\n  components: {\n    VLink: VLink\n  }\n});\n// CONCATENATED MODULE: ./src/layouts/Main.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/layouts/Main.vue\n\n\n\nMainvue_type_script_lang_js.render = render\n\n/* harmony default export */ var Main = __webpack_exports__["a"] = (Mainvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5b3V0cy9NYWluLnZ1ZT84ZTMxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1ZMaW5rLnZ1ZT8zZDdjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1ZMaW5rLnZ1ZT9lNzQ5Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1ZMaW5rLnZ1ZT83MDU0Iiwid2VicGFjazovLy8uL3NyYy9sYXlvdXRzL01haW4udnVlPzI1MDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheW91dHMvTWFpbi52dWU/MWUwOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O2lGQUV5QixNOztpRkFDSyxPOztpRkFDRixvQjs7Ozs7b0pBSDFCLCtDQUlLLElBSkwsRUFJSyxJQUpMLEVBSUssQ0FISCwrQ0FBdUMsSUFBdkMsRUFBdUMsSUFBdkMsRUFBdUMsQ0FBbkMsK0NBQThCLGlCQUE5QixFQUE4QjtBQUF0QixRQUFJLEVBQUM7QUFBaUIsR0FBOUIsRUFBZ0I7MERBQUM7QUFBQSxhQUFJLEMsVUFBQSxDQUFKO0FBQUEsSyxDQUFEOzs7O0FBQUEsR0FBaEIsQ0FBbUMsQ0FBdkMsQ0FHRyxFQUZILCtDQUE2QyxJQUE3QyxFQUE2QyxJQUE3QyxFQUE2QyxDQUF6QywrQ0FBb0MsaUJBQXBDLEVBQW9DO0FBQTVCLFFBQUksRUFBQztBQUF1QixHQUFwQyxFQUFxQjswREFBQztBQUFBLGFBQUssQyxVQUFBLENBQUw7QUFBQSxLLENBQUQ7Ozs7QUFBQSxHQUFyQixDQUF5QyxDQUE3QyxDQUVHLEVBREgsK0NBQXdELElBQXhELEVBQXdELElBQXhELEVBQXdELENBQXBELCtDQUErQyxpQkFBL0MsRUFBK0M7QUFBdkMsUUFBSSxFQUFDO0FBQWtDLEdBQS9DLEVBQW1COzBEQUFDO0FBQUEsYUFBa0IsQyxVQUFBLENBQWxCO0FBQUEsSyxDQUFEOzs7O0FBQUEsR0FBbkIsQ0FBb0QsQ0FBeEQsQ0FDRyxDQUpMLEMsRUFNQSw4Q0FBYSxXQUFiLEVBQWEsU0FBYixDOzs7Ozs7Ozs7eURDTkEsK0NBS0ksR0FMSixFQUtJO0FBSkQsUUFBSSxFQUFFLFdBSUw7QUFIRCxXQUFLO0FBQUEsYUFBVSxxREFBVjtBQUFBLE9BQVksV0FBWjtBQUdKLEdBTEosRSxDQUlFLDhDQUFhLFdBQWIsRUFBYSxTQUFiLEMsQ0FKRixFOztBQUFBLEksUUFBQSxDOzs7Ozs7OztBQVNGO0FBRWU7QUFDYixPQUFLLEVBQUU7QUFDTCxRQUFJLEVBQUU7QUFDSixVQUFJLEVBQUMsTUFERDtBQUVKLGNBQVEsRUFBRTtBQUZOO0FBREQsR0FETTtBQVFiLFNBQU8sRUFBRTtBQUNQLE1BRE8sZ0JBQ0Q7QUFDSixXQUFLLEtBQUwsQ0FBVyxZQUFYLEdBQTBCLEtBQUssSUFBL0I7QUFDQSxZQUFNLENBQUMsT0FBUCxDQUFlLFNBQWYsQ0FBeUIsSUFBekIsRUFBK0IseUJBQU0sQ0FBQyxLQUFLLElBQU4sQ0FBckMsRUFBa0QsS0FBSyxJQUF2RDtBQUNGO0FBSk87QUFSSSxDQUFmLEU7O0FDWm1LLEM7O0FDQWpHO0FBQ1Y7QUFDTDtBQUNuRCw0QkFBTSxVQUFVLHlDQUFNOztBQUVQLHNFOztBSE1mO0FBRWU7QUFDYixZQUFVLEVBQUU7QUFDVixTQUFJLEVBQUosS0FBSztBQURLO0FBREMsQ0FBZixFOztBSWJrSyxDOztBQ0FqRztBQUNWO0FBQ0w7QUFDbEQsMkJBQU0sVUFBVSxNQUFNOztBQUVQLCtGIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDx1bD5cbiAgICA8bGk+PHYtbGluayBocmVmPVwiL1wiPkhvbWU8L3YtbGluaz48L2xpPlxuICAgIDxsaT48di1saW5rIGhyZWY9XCIvYWJvdXRcIj5BYm91dDwvdi1saW5rPjwvbGk+XG4gICAgPGxpPjx2LWxpbmsgaHJlZj1cIi9mb29cIj5VbmRlciBDb25zdHJ1Y3Rpb248L3YtbGluaz48L2xpPlxuICA8L3VsPlxuXG4gIDxzbG90Pjwvc2xvdD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgVkxpbmsgZnJvbSAnLi4vY29tcG9uZW50cy9WTGluay52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIFZMaW5rXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YVxuICAgIDpocmVmPVwiaHJlZlwiXG4gICAgQGNsaWNrLnByZXZlbnQ9XCJnb1wiXG4gID5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgcm91dGVzIGZyb20gJy4uL3JvdXRlcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIGhyZWY6IHtcbiAgICAgIHR5cGU6U3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdvICgpIHtcbiAgICAgIHRoaXMuJHJvb3QuY3VycmVudFJvdXRlID0gdGhpcy5ocmVmXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgcm91dGVzW3RoaXMuaHJlZl0sIHRoaXMuaHJlZilcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOC0wIS4vVkxpbmsudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOC0wIS4vVkxpbmsudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9WTGluay52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTlmYzRhZDRcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9WTGluay52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vVkxpbmsudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbnNjcmlwdC5yZW5kZXIgPSByZW5kZXJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOC0wIS4vTWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS04LTAhLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vTWFpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NzRiYWJmMjFcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  '/': 'Home',\n  '/about': 'About'\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcm91dGVzLmpzPzU2NjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWU7QUFDYixPQUFLLE1BRFE7QUFFYixZQUFVO0FBRkcsQ0FBZiIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICAnLyc6ICdIb21lJyxcbiAgJy9hYm91dCc6ICdBYm91dCdcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell\r\n// X11 (MIT) Licensed. (See LICENSE.)\r\n\r\nvoid (function(root, factory) {\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else {}\r\n}(this, function() {\r\n\r\n  function resolveUrl(/* ...urls */) {\r\n    var numUrls = arguments.length\r\n\r\n    if (numUrls === 0) {\r\n      throw new Error("resolveUrl requires at least one argument; got none.")\r\n    }\r\n\r\n    var base = document.createElement("base")\r\n    base.href = arguments[0]\r\n\r\n    if (numUrls === 1) {\r\n      return base.href\r\n    }\r\n\r\n    var head = document.getElementsByTagName("head")[0]\r\n    head.insertBefore(base, head.firstChild)\r\n\r\n    var a = document.createElement("a")\r\n    var resolved\r\n\r\n    for (var index = 1; index < numUrls; index++) {\r\n      a.href = arguments[index]\r\n      resolved = a.href\r\n      base.href = resolved\r\n    }\r\n\r\n    head.removeChild(base)\r\n\r\n    return resolved\r\n  }\r\n\r\n  return resolveUrl\r\n\r\n}));\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS11cmwvcmVzb2x2ZS11cmwuanM/M2UxNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRCxJQUFJLG9DQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNuQixHQUFHLE1BQU0sRUFJTjtBQUNILENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE0IFNpbW9uIEx5ZGVsbFxyXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXHJcblxyXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZmFjdG9yeSlcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LnJlc29sdmVVcmwgPSBmYWN0b3J5KClcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24oKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoLyogLi4udXJscyAqLykge1xyXG4gICAgdmFyIG51bVVybHMgPSBhcmd1bWVudHMubGVuZ3RoXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZVVybCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ7IGdvdCBub25lLlwiKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJhc2VcIilcclxuICAgIGJhc2UuaHJlZiA9IGFyZ3VtZW50c1swXVxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBiYXNlLmhyZWZcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXVxyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoYmFzZSwgaGVhZC5maXJzdENoaWxkKVxyXG5cclxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcclxuICAgIHZhciByZXNvbHZlZFxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBudW1VcmxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGEuaHJlZiA9IGFyZ3VtZW50c1tpbmRleF1cclxuICAgICAgcmVzb2x2ZWQgPSBhLmhyZWZcclxuICAgICAgYmFzZS5ocmVmID0gcmVzb2x2ZWRcclxuICAgIH1cclxuXHJcbiAgICBoZWFkLnJlbW92ZUNoaWxkKGJhc2UpXHJcblxyXG4gICAgcmV0dXJuIHJlc29sdmVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzb2x2ZVVybFxyXG5cclxufSkpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports){eval("let logging = false;\nlet customLogger = () => {};\n\nconst setLogging = (_logging) => {\n  logging = _logging;\n};\n\nconst setCustomLogger = (logger) => {\n  customLogger = logger;\n};\n\nconst log = (type, message) => {\n  customLogger({ type, message });\n  if (logging) {\n    console.log(`[${type}] ${message}`);\n  }\n};\n\nmodule.exports = {\n  logging,\n  setLogging,\n  setCustomLogger,\n  log,\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL3V0aWxzL2xvZy5qcz85MDhlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQSxvQkFBb0IsS0FBSyxJQUFJLFFBQVE7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBsb2dnaW5nID0gZmFsc2U7XG5sZXQgY3VzdG9tTG9nZ2VyID0gKCkgPT4ge307XG5cbmNvbnN0IHNldExvZ2dpbmcgPSAoX2xvZ2dpbmcpID0+IHtcbiAgbG9nZ2luZyA9IF9sb2dnaW5nO1xufTtcblxuY29uc3Qgc2V0Q3VzdG9tTG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICBjdXN0b21Mb2dnZXIgPSBsb2dnZXI7XG59O1xuXG5jb25zdCBsb2cgPSAodHlwZSwgbWVzc2FnZSkgPT4ge1xuICBjdXN0b21Mb2dnZXIoeyB0eXBlLCBtZXNzYWdlIH0pO1xuICBpZiAobG9nZ2luZykge1xuICAgIGNvbnNvbGUubG9nKGBbJHt0eXBlfV0gJHttZXNzYWdlfWApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nZ2luZyxcbiAgc2V0TG9nZ2luZyxcbiAgc2V0Q3VzdG9tTG9nZ2VyLFxuICBsb2csXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){eval("const defaultOptions = __webpack_require__(16);\nconst getCreateFFmpegCore = __webpack_require__(18);\nconst fetchFile = __webpack_require__(19);\n\nmodule.exports = {\n  defaultOptions,\n  getCreateFFmpegCore,\n  fetchFile,\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL2Jyb3dzZXIvaW5kZXguanM/YjhkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx1QkFBdUIsbUJBQU8sQ0FBQyxFQUFrQjtBQUNqRCw0QkFBNEIsbUJBQU8sQ0FBQyxFQUF1QjtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFhOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vZGVmYXVsdE9wdGlvbnMnKTtcbmNvbnN0IGdldENyZWF0ZUZGbXBlZ0NvcmUgPSByZXF1aXJlKCcuL2dldENyZWF0ZUZGbXBlZ0NvcmUnKTtcbmNvbnN0IGZldGNoRmlsZSA9IHJlcXVpcmUoJy4vZmV0Y2hGaWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWZhdWx0T3B0aW9ucyxcbiAgZ2V0Q3JlYXRlRkZtcGVnQ29yZSxcbiAgZmV0Y2hGaWxlLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module){eval('module.exports = JSON.parse("{\\"_from\\":\\"@ffmpeg/ffmpeg\\",\\"_id\\":\\"@ffmpeg/ffmpeg@0.9.7\\",\\"_inBundle\\":false,\\"_integrity\\":\\"sha512-WpZkNnqYGoaMcMd1EpaDi7nxRyEd05OjOTAfItH/ZwvAKJpr7ksvHKTC/NjP0li6mFrTFLGudP81J1tG0babdg==\\",\\"_location\\":\\"/@ffmpeg/ffmpeg\\",\\"_phantomChildren\\":{},\\"_requested\\":{\\"type\\":\\"tag\\",\\"registry\\":true,\\"raw\\":\\"@ffmpeg/ffmpeg\\",\\"name\\":\\"@ffmpeg/ffmpeg\\",\\"escapedName\\":\\"@ffmpeg%2fffmpeg\\",\\"scope\\":\\"@ffmpeg\\",\\"rawSpec\\":\\"\\",\\"saveSpec\\":null,\\"fetchSpec\\":\\"latest\\"},\\"_requiredBy\\":[\\"#USER\\",\\"/\\"],\\"_resolved\\":\\"https://registry.npmjs.org/@ffmpeg/ffmpeg/-/ffmpeg-0.9.7.tgz\\",\\"_shasum\\":\\"f309d689c59e35d345c049bf5e35f1ccde28c215\\",\\"_spec\\":\\"@ffmpeg/ffmpeg\\",\\"_where\\":\\"C:\\\\\\\\Users\\\\\\\\super\\\\\\\\source\\\\\\\\videoencoderV2\\",\\"author\\":{\\"name\\":\\"Jerome Wu\\",\\"email\\":\\"jeromewus@gmail.com\\"},\\"browser\\":{\\"./src/node/index.js\\":\\"./src/browser/index.js\\"},\\"bugs\\":{\\"url\\":\\"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\\"},\\"bundleDependencies\\":false,\\"dependencies\\":{\\"is-url\\":\\"^1.2.4\\",\\"node-fetch\\":\\"^2.6.1\\",\\"regenerator-runtime\\":\\"^0.13.7\\",\\"resolve-url\\":\\"^0.2.1\\"},\\"deprecated\\":false,\\"description\\":\\"FFmpeg WebAssembly version\\",\\"devDependencies\\":{\\"@babel/core\\":\\"^7.12.3\\",\\"@babel/preset-env\\":\\"^7.12.1\\",\\"@ffmpeg/core\\":\\"^0.8.5\\",\\"@types/emscripten\\":\\"^1.39.4\\",\\"babel-loader\\":\\"^8.1.0\\",\\"chai\\":\\"^4.2.0\\",\\"cors\\":\\"^2.8.5\\",\\"eslint\\":\\"^7.12.1\\",\\"eslint-config-airbnb-base\\":\\"^14.1.0\\",\\"eslint-plugin-import\\":\\"^2.22.1\\",\\"express\\":\\"^4.17.1\\",\\"mocha\\":\\"^8.2.1\\",\\"mocha-headless-chrome\\":\\"^2.0.3\\",\\"npm-run-all\\":\\"^4.1.5\\",\\"wait-on\\":\\"^5.2.0\\",\\"webpack\\":\\"^5.3.2\\",\\"webpack-cli\\":\\"^4.1.0\\",\\"webpack-dev-middleware\\":\\"^4.0.0\\"},\\"directories\\":{\\"example\\":\\"examples\\"},\\"engines\\":{\\"node\\":\\">=12.16.1\\"},\\"homepage\\":\\"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\\",\\"keywords\\":[\\"ffmpeg\\",\\"WebAssembly\\",\\"video\\"],\\"license\\":\\"MIT\\",\\"main\\":\\"src/index.js\\",\\"name\\":\\"@ffmpeg/ffmpeg\\",\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\\"},\\"scripts\\":{\\"build\\":\\"rimraf dist && webpack --config scripts/webpack.config.prod.js\\",\\"lint\\":\\"eslint src\\",\\"prepublishOnly\\":\\"npm run build\\",\\"start\\":\\"node scripts/server.js\\",\\"test\\":\\"npm-run-all -p -r start test:all\\",\\"test:all\\":\\"npm-run-all wait test:browser:ffmpeg test:node:all\\",\\"test:browser\\":\\"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\\",\\"test:browser:ffmpeg\\":\\"npm run test:browser -- -f ./tests/ffmpeg.test.html\\",\\"test:node\\":\\"node --experimental-wasm-threads --experimental-wasm-bulk-memory node_modules/.bin/_mocha --exit --bail --require ./scripts/test-helper.js\\",\\"test:node:all\\":\\"npm run test:node -- ./tests/*.test.js\\",\\"wait\\":\\"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\\"},\\"types\\":\\"src/index.d.ts\\",\\"version\\":\\"0.9.7\\"}");\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI3LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(11);\nconst createFFmpeg = __webpack_require__(12);\nconst { fetchFile } = __webpack_require__(6);\n\nmodule.exports = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg,\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile,\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL2luZGV4LmpzPzkxMTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQU8sQ0FBQyxFQUE2QjtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFnQjtBQUM3QyxPQUFPLFlBQVksR0FBRyxtQkFBTyxDQUFDLENBQVE7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZScpO1xuY29uc3QgY3JlYXRlRkZtcGVnID0gcmVxdWlyZSgnLi9jcmVhdGVGRm1wZWcnKTtcbmNvbnN0IHsgZmV0Y2hGaWxlIH0gPSByZXF1aXJlKCcuL25vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qXG4gICAqIENyZWF0ZSBmZm1wZWcgaW5zdGFuY2UuXG4gICAqIEVhY2ggZmZtcGVnIGluc3RhbmNlIG93bnMgYW4gaXNvbGF0ZWQgTUVNRlMgYW5kIHdvcmtzXG4gICAqIGluZGVwZW5kZW50bHkuXG4gICAqXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZmZtcGVnID0gY3JlYXRlRkZtcGVnKHtcbiAgICogIGxvZzogdHJ1ZSxcbiAgICogIGxvZ2dlcjogKCkgPT4ge30sXG4gICAqICBwcm9ncmVzczogKCkgPT4ge30sXG4gICAqICBjb3JlUGF0aDogJycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBGb3IgdGhlIHVzYWdlIG9mIHRoZXNlIGZvdXIgYXJndW1lbnRzLCBjaGVjayBjb25maWcuanNcbiAgICpcbiAgICovXG4gIGNyZWF0ZUZGbXBlZyxcbiAgLypcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBmZXRjaGluZyBmaWxlcyBmcm9tIHZhcmlvdXMgcmVzb3VyY2UuXG4gICAqIFNvbWV0aW1lcyB0aGUgdmlkZW8vYXVkaW8gZmlsZSB5b3Ugd2FudCB0byBwcm9jZXNzIG1heSBsb2NhdGVkXG4gICAqIGluIGEgcmVtb3RlIFVSTCBhbmQgc29tZXdoZXJlIGluIHlvdXIgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gICAqXG4gICAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGhlbHBzIHlvdSB0byBmZXRjaCB0byBmaWxlIGFuZCByZXR1cm4gYW5cbiAgICogVWludDhBcnJheSB2YXJpYWJsZSBmb3IgZmZtcGVnLndhc20gdG8gY29uc3VtZS5cbiAgICpcbiAgICovXG4gIGZldGNoRmlsZSxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _routes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);\n/* harmony import */ var _ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_2__);\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n\nvar SimpleRouterApp = {\n  data: function data() {\n    return {\n      currentRoute: window.location.pathname\n    };\n  },\n  computed: {\n    ViewComponent: function ViewComponent() {\n      var matchingPage = _routes__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"][this.currentRoute] || \'404\';\n      return __webpack_require__(20)("./".concat(matchingPage, ".vue"))["default"];\n    }\n  },\n  render: function render() {\n    return Object(vue__WEBPACK_IMPORTED_MODULE_0__[/* h */ "f"])(this.ViewComponent);\n  },\n  created: function created() {\n    var _this = this;\n\n    window.addEventListener(\'popstate\', function () {\n      _this.currentRoute = window.location.pathname;\n    });\n  }\n};\nvar app = Object(vue__WEBPACK_IMPORTED_MODULE_0__[/* createApp */ "b"])(SimpleRouterApp);\napp.config.globalProperties.onprogress = {\n  target: function target() {},\n  register: function register(func) {\n    this.target = func;\n  }\n};\napp.config.globalProperties.ffmpeg = Object(_ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_2__["createFFmpeg"])({\n  log: true,\n  progress: function progress(_ref) {\n    var ratio = _ref.ratio;\n    console.log("rati", ratio);\n    app.config.globalProperties.onprogress.target(ratio);\n  }\n});\n\n/*#__PURE__*/\n_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n  return regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return app.config.globalProperties.ffmpeg.load();\n\n        case 2:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}));\n\napp.mount(\'#app\');\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbIlNpbXBsZVJvdXRlckFwcCIsImRhdGEiLCJjdXJyZW50Um91dGUiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiY29tcHV0ZWQiLCJWaWV3Q29tcG9uZW50IiwibWF0Y2hpbmdQYWdlIiwicm91dGVzIiwicmVxdWlyZSIsInJlbmRlciIsImgiLCJjcmVhdGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFwcCIsImNyZWF0ZUFwcCIsImNvbmZpZyIsImdsb2JhbFByb3BlcnRpZXMiLCJvbnByb2dyZXNzIiwidGFyZ2V0IiwicmVnaXN0ZXIiLCJmdW5jIiwiZmZtcGVnIiwiY3JlYXRlRkZtcGVnIiwibG9nIiwicHJvZ3Jlc3MiLCJyYXRpbyIsImNvbnNvbGUiLCJsb2FkIiwibW91bnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBLElBQU1BLGVBQWUsR0FBRztBQUN0QkMsTUFBSSxFQUFFO0FBQUEsV0FBTztBQUNYQyxrQkFBWSxFQUFFQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDO0FBRG5CLEtBQVA7QUFBQSxHQURnQjtBQUt0QkMsVUFBUSxFQUFFO0FBQ1JDLGlCQURRLDJCQUNTO0FBQ2YsVUFBTUMsWUFBWSxHQUFHQyx1REFBTSxDQUFDLEtBQUtQLFlBQU4sQ0FBTixJQUE2QixLQUFsRDtBQUNBLGFBQU9RLHdCQUFRLFlBQVdGLFlBQVosVUFBUCxXQUFQO0FBQ0Q7QUFKTyxHQUxZO0FBWXRCRyxRQVpzQixvQkFZWjtBQUNSLFdBQU9DLHFEQUFDLENBQUMsS0FBS0wsYUFBTixDQUFSO0FBQ0QsR0FkcUI7QUFnQnRCTSxTQWhCc0IscUJBZ0JYO0FBQUE7O0FBQ1RWLFVBQU0sQ0FBQ1csZ0JBQVAsQ0FBd0IsVUFBeEIsRUFBb0MsWUFBTTtBQUN4QyxXQUFJLENBQUNaLFlBQUwsR0FBb0JDLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsUUFBcEM7QUFDRCxLQUZEO0FBR0Q7QUFwQnFCLENBQXhCO0FBdUJBLElBQUlVLEdBQUcsR0FBR0MsNkRBQVMsQ0FBQ2hCLGVBQUQsQ0FBbkI7QUFDQWUsR0FBRyxDQUFDRSxNQUFKLENBQVdDLGdCQUFYLENBQTRCQyxVQUE1QixHQUF5QztBQUN2Q0MsUUFBTSxFQUFDLGtCQUFVLENBQUUsQ0FEb0I7QUFFdkNDLFVBQVEsRUFBQyxrQkFBU0MsSUFBVCxFQUFjO0FBQ3JCLFNBQUtGLE1BQUwsR0FBY0UsSUFBZDtBQUNEO0FBSnNDLENBQXpDO0FBTUFQLEdBQUcsQ0FBQ0UsTUFBSixDQUFXQyxnQkFBWCxDQUE0QkssTUFBNUIsR0FBcUNDLG1FQUFZLENBQUM7QUFDaERDLEtBQUcsRUFBRSxJQUQyQztBQUVoREMsVUFBUSxFQUFFLHdCQUFlO0FBQUEsUUFBWkMsS0FBWSxRQUFaQSxLQUFZO0FBQ3ZCQyxXQUFPLENBQUNILEdBQVIsQ0FBWSxNQUFaLEVBQW1CRSxLQUFuQjtBQUNBWixPQUFHLENBQUNFLE1BQUosQ0FBV0MsZ0JBQVgsQ0FBNEJDLFVBQTVCLENBQXVDQyxNQUF2QyxDQUE4Q08sS0FBOUM7QUFDRDtBQUwrQyxDQUFELENBQWpEOztBQVFBO0FBQUEsd0RBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQ09aLEdBQUcsQ0FBQ0UsTUFBSixDQUFXQyxnQkFBWCxDQUE0QkssTUFBNUIsQ0FBbUNNLElBQW5DLEVBRFA7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsQ0FBRDs7QUFJQWQsR0FBRyxDQUFDZSxLQUFKLENBQVUsTUFBViIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQXBwLCBoIH0gZnJvbSAndnVlJ1xuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcydcbmltcG9ydCB7IGNyZWF0ZUZGbXBlZywgZmV0Y2hGaWxlIH0gZnJvbSAnQGZmbXBlZy9mZm1wZWcnO1xuXG5jb25zdCBTaW1wbGVSb3V0ZXJBcHAgPSB7XG4gIGRhdGE6ICgpID0+ICh7XG4gICAgY3VycmVudFJvdXRlOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVcbiAgfSksXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBWaWV3Q29tcG9uZW50ICgpIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nUGFnZSA9IHJvdXRlc1t0aGlzLmN1cnJlbnRSb3V0ZV0gfHwgJzQwNCdcbiAgICAgIHJldHVybiByZXF1aXJlKGAuL3BhZ2VzLyR7bWF0Y2hpbmdQYWdlfS52dWVgKS5kZWZhdWx0XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIGgodGhpcy5WaWV3Q29tcG9uZW50KVxuICB9LFxuXG4gIGNyZWF0ZWQgKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsICgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFJvdXRlID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSlcbiAgfVxufVxuXG52YXIgYXBwID0gY3JlYXRlQXBwKFNpbXBsZVJvdXRlckFwcClcbmFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy5vbnByb2dyZXNzID0ge1xuICB0YXJnZXQ6ZnVuY3Rpb24oKXt9LFxuICByZWdpc3RlcjpmdW5jdGlvbihmdW5jKXtcbiAgICB0aGlzLnRhcmdldCA9IGZ1bmM7XG4gIH1cbn1cbmFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy5mZm1wZWcgPSBjcmVhdGVGRm1wZWcoe1xuICBsb2c6IHRydWUsXG4gIHByb2dyZXNzOiAoeyByYXRpbyB9KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJyYXRpXCIscmF0aW8pO1xuICAgIGFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy5vbnByb2dyZXNzLnRhcmdldChyYXRpbylcbiAgfVxufSk7XG5cbihhc3luYyBmdW5jdGlvbigpe1xuICBhd2FpdCBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuZmZtcGVnLmxvYWQoKTtcbn0pXG5cbmFwcC5tb3VudCgnI2FwcCcpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, "");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: "normal", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: "throw", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    "GeneratorFunction"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === "GeneratorFunction"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, "GeneratorFunction");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === "object" &&\n            hasOwn.call(value, "__await")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke("next", value, resolve, reject);\n          }, function(err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke("throw", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === "throw") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        // Note: ["return"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator["return"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError(\n          "The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, "Generator");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return "[object Generator]";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: "root" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = "next";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, "finallyLoc") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === "break" ||\n           type === "continue") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" ||\n          record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    "catch": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error("illegal catch attempt");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you\'ve misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you\'re not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function("r", "regeneratorRuntime = r")(runtime);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBMEIsb0JBQW9CLFNBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval("const { defaultArgs, baseOptions } = __webpack_require__(13);\nconst { setLogging, setCustomLogger, log } = __webpack_require__(5);\nconst parseProgress = __webpack_require__(14);\nconst parseArgs = __webpack_require__(15);\nconst { defaultOptions, getCreateFFmpegCore } = __webpack_require__(6);\nconst { version } = __webpack_require__(7);\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    FS,\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL2NyZWF0ZUZGbXBlZy5qcz85NDIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sMkJBQTJCLEdBQUcsbUJBQU8sQ0FBQyxFQUFVO0FBQ3ZELE9BQU8sbUNBQW1DLEdBQUcsbUJBQU8sQ0FBQyxDQUFhO0FBQ2xFLHNCQUFzQixtQkFBTyxDQUFDLEVBQXVCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLEVBQW1CO0FBQzdDLE9BQU8sc0NBQXNDLEdBQUcsbUJBQU8sQ0FBQyxDQUFRO0FBQ2hFLE9BQU8sVUFBVSxHQUFHLG1CQUFPLENBQUMsQ0FBaUI7O0FBRTdDOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RSwwQ0FBMEMseUJBQXlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTyxHQUFHLHVEQUF1RCxXQUFXLGlDQUFpQztBQUN2STtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZELFNBQVM7QUFDVCxnREFBZ0QsUUFBUTtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGRlZmF1bHRBcmdzLCBiYXNlT3B0aW9ucyB9ID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmNvbnN0IHsgc2V0TG9nZ2luZywgc2V0Q3VzdG9tTG9nZ2VyLCBsb2cgfSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJyk7XG5jb25zdCBwYXJzZVByb2dyZXNzID0gcmVxdWlyZSgnLi91dGlscy9wYXJzZVByb2dyZXNzJyk7XG5jb25zdCBwYXJzZUFyZ3MgPSByZXF1aXJlKCcuL3V0aWxzL3BhcnNlQXJncycpO1xuY29uc3QgeyBkZWZhdWx0T3B0aW9ucywgZ2V0Q3JlYXRlRkZtcGVnQ29yZSB9ID0gcmVxdWlyZSgnLi9ub2RlJyk7XG5jb25zdCB7IHZlcnNpb24gfSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5jb25zdCBOT19MT0FEID0gRXJyb3IoJ2ZmbXBlZy53YXNtIGlzIG5vdCByZWFkeSwgbWFrZSBzdXJlIHlvdSBoYXZlIGNvbXBsZXRlZCBsb2FkKCkuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKF9vcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIGxvZzogbG9nZ2luZyxcbiAgICBsb2dnZXIsXG4gICAgcHJvZ3Jlc3M6IG9wdFByb2dyZXNzLFxuICAgIC4uLm9wdGlvbnNcbiAgfSA9IHtcbiAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5fb3B0aW9ucyxcbiAgfTtcbiAgbGV0IENvcmUgPSBudWxsO1xuICBsZXQgZmZtcGVnID0gbnVsbDtcbiAgbGV0IHJ1blJlc29sdmUgPSBudWxsO1xuICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICBsZXQgcHJvZ3Jlc3MgPSBvcHRQcm9ncmVzcztcbiAgY29uc3QgZGV0ZWN0Q29tcGxldGlvbiA9IChtZXNzYWdlKSA9PiB7XG4gICAgaWYgKG1lc3NhZ2UgPT09ICdGRk1QRUdfRU5EJyAmJiBydW5SZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBydW5SZXNvbHZlKCk7XG4gICAgICBydW5SZXNvbHZlID0gbnVsbDtcbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhcnNlTWVzc2FnZSA9ICh7IHR5cGUsIG1lc3NhZ2UgfSkgPT4ge1xuICAgIGxvZyh0eXBlLCBtZXNzYWdlKTtcbiAgICBwYXJzZVByb2dyZXNzKG1lc3NhZ2UsIHByb2dyZXNzKTtcbiAgICBkZXRlY3RDb21wbGV0aW9uKG1lc3NhZ2UpO1xuICB9O1xuXG4gIC8qXG4gICAqIExvYWQgZmZtcGVnLndhc20tY29yZSBzY3JpcHQuXG4gICAqIEluIGJyb3dzZXIgZW52aXJvbm1lbnQsIHRoZSBmZm1wZWcud2FzbS1jb3JlIHNjcmlwdCBpcyBmZXRjaCBmcm9tXG4gICAqIENETiBhbmQgY2FuIGJlIGFzc2lnbiB0byBhIGxvY2FsIHBhdGggYnkgYXNzaWduaW5nIGBjb3JlUGF0aGAuXG4gICAqIEluIG5vZGUgZW52aXJvbm1lbnQsIHdlIHVzZSBkeW5hbWljIHJlcXVpcmUgYW5kIHRoZSBkZWZhdWx0IGBjb3JlUGF0aGBcbiAgICogaXMgYCRmZm1wZWcvY29yZWAuXG4gICAqXG4gICAqIFR5cGljYWxseSB0aGUgbG9hZCgpIGZ1bmMgbWlnaHQgdGFrZSBmZXcgc2Vjb25kcyB0byBtaW51dGVzIHRvIGNvbXBsZXRlLFxuICAgKiBiZXR0ZXIgdG8gZG8gaXQgYXMgZWFybHkgYXMgcG9zc2libGUuXG4gICAqXG4gICAqL1xuICBjb25zdCBsb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgIGxvZygnaW5mbycsICdsb2FkIGZmbXBlZy1jb3JlJyk7XG4gICAgaWYgKENvcmUgPT09IG51bGwpIHtcbiAgICAgIGxvZygnaW5mbycsICdsb2FkaW5nIGZmbXBlZy1jb3JlJyk7XG4gICAgICAvKlxuICAgICAgICogSW4gbm9kZSBlbnZpcm9ubWVudCwgYWxsIHBhdGhzIGFyZSB1bmRlZmluZWQgYXMgdGhlcmVcbiAgICAgICAqIGlzIG5vIG5lZWQgdG8gc2V0IHRoZW0uXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3JlYXRlRkZtcGVnQ29yZSxcbiAgICAgICAgY29yZVBhdGgsXG4gICAgICAgIHdvcmtlclBhdGgsXG4gICAgICAgIHdhc21QYXRoLFxuICAgICAgfSA9IGF3YWl0IGdldENyZWF0ZUZGbXBlZ0NvcmUob3B0aW9ucyk7XG4gICAgICBDb3JlID0gYXdhaXQgY3JlYXRlRkZtcGVnQ29yZSh7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEFzc2lnbiBtYWluU2NyaXB0VXJsT3JCbG9iIGZpeGVzIGNocm9tZSBleHRlbnNpb24gd2ViIHdvcmtlciBpc3N1ZVxuICAgICAgICAgKiBhcyB0aGVyZSBpcyBubyBkb2N1bWVudC5jdXJyZW50U2NyaXB0IGluIHRoZSBjb250ZXh0IG9mIGNvbnRlbnRfc2NyaXB0c1xuICAgICAgICAgKi9cbiAgICAgICAgbWFpblNjcmlwdFVybE9yQmxvYjogY29yZVBhdGgsXG4gICAgICAgIHByaW50RXJyOiAobWVzc2FnZSkgPT4gcGFyc2VNZXNzYWdlKHsgdHlwZTogJ2ZmZXJyJywgbWVzc2FnZSB9KSxcbiAgICAgICAgcHJpbnQ6IChtZXNzYWdlKSA9PiBwYXJzZU1lc3NhZ2UoeyB0eXBlOiAnZmZvdXQnLCBtZXNzYWdlIH0pLFxuICAgICAgICAvKlxuICAgICAgICAgKiBsb2NhdGVGaWxlIG92ZXJyaWRlcyBwYXRocyBvZiBmaWxlcyB0aGF0IGlzIGxvYWRlZCBieSBtYWluIHNjcmlwdCAoZmZtcGVnLWNvcmUuanMpLlxuICAgICAgICAgKiBJdCBpcyBjcml0aWNhbCBmb3IgYnJvd3NlciBlbnZpcm9ubWVudCBhbmQgd2Ugb3ZlcnJpZGUgYm90aCB3YXNtIGFuZCB3b3JrZXIgcGF0aHNcbiAgICAgICAgICogYXMgd2UgYXJlIHVzaW5nIGJsb2IgVVJMIGluc3RlYWQgb2Ygb3JpZ2luYWwgVVJMIHRvIGF2b2lkIGNyb3NzIG9yaWdpbiBpc3N1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhdGVGaWxlOiAocGF0aCwgcHJlZml4KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdhc21QYXRoICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAmJiBwYXRoLmVuZHNXaXRoKCdmZm1wZWctY29yZS53YXNtJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdhc21QYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3b3JrZXJQYXRoICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAmJiBwYXRoLmVuZHNXaXRoKCdmZm1wZWctY29yZS53b3JrZXIuanMnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gd29ya2VyUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIHBhdGg7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGZmbXBlZyA9IENvcmUuY3dyYXAoJ3Byb3h5X21haW4nLCAnbnVtYmVyJywgWydudW1iZXInLCAnbnVtYmVyJ10pO1xuICAgICAgbG9nKCdpbmZvJywgJ2ZmbXBlZy1jb3JlIGxvYWRlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignZmZtcGVnLndhc20gd2FzIGxvYWRlZCwgeW91IHNob3VsZCBub3QgbG9hZCBpdCBhZ2FpbiwgdXNlIGZmbXBlZy5pc0xvYWRlZCgpIHRvIGNoZWNrIG5leHQgdGltZS4nKTtcbiAgICB9XG4gIH07XG5cblxuICAvKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgQ29yZSBpcyBsb2FkZWQuXG4gICAqL1xuICBjb25zdCBpc0xvYWRlZCA9ICgpID0+IENvcmUgIT09IG51bGw7XG5cbiAgLypcbiAgICogUnVuIGZmbXBlZyBjb21tYW5kLlxuICAgKiBUaGlzIGlzIHRoZSBtYWpvciBmdW5jdGlvbiBpbiBmZm1wZWcud2FzbSwgeW91IGNhbiBqdXN0IGltYWdpbmUgaXRcbiAgICogYXMgZmZtcGVnIG5hdGl2ZSBjbGkgYW5kIHdoYXQgeW91IG5lZWQgdG8gcGFzcyBpcyB0aGUgc2FtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHlvdSBjYW4gY29udmVydCBuYXRpdmUgY29tbWFuZCBiZWxvdzpcbiAgICpcbiAgICogYGBgXG4gICAqICQgZmZtcGVnIC1pIHZpZGVvLmF2aSAtYzp2IGxpYngyNjQgdmlkZW8ubXA0XG4gICAqIGBgYFxuICAgKlxuICAgKiBUb1xuICAgKlxuICAgKiBgYGBcbiAgICogYXdhaXQgZmZtcGVnLnJ1bignLWknLCAndmlkZW8uYXZpJywgJy1jOnYnLCAnbGlieDI2NCcsICd2aWRlby5tcDQnKTtcbiAgICogYGBgXG4gICAqXG4gICAqL1xuICBjb25zdCBydW4gPSAoLi4uX2FyZ3MpID0+IHtcbiAgICBsb2coJ2luZm8nLCBgcnVuIGZmbXBlZyBjb21tYW5kOiAke19hcmdzLmpvaW4oJyAnKX1gKTtcbiAgICBpZiAoQ29yZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgTk9fTE9BRDtcbiAgICB9IGVsc2UgaWYgKHJ1bm5pbmcpIHtcbiAgICAgIHRocm93IEVycm9yKCdmZm1wZWcud2FzbSBjYW4gb25seSBydW4gb25lIGNvbW1hbmQgYXQgYSB0aW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbLi4uZGVmYXVsdEFyZ3MsIC4uLl9hcmdzXS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcnVuUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGZmbXBlZyguLi5wYXJzZUFyZ3MoQ29yZSwgYXJncykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIFJ1biBGUyBvcGVyYXRpb25zLlxuICAgKiBGb3IgaW5wdXQvb3V0cHV0IGZpbGUgb2YgZmZtcGVnLndhc20sIGl0IGlzIHJlcXVpcmVkIHRvIHNhdmUgdGhlbSB0byBNRU1GU1xuICAgKiBmaXJzdCBzbyB0aGF0IGZmbXBlZy53YXNtIGlzIGFibGUgdG8gY29uc3VtZSB0aGVtLiBIZXJlIHdlIHJlbHkgb24gdGhlIEZTXG4gICAqIG1ldGhvZHMgcHJvdmlkZWQgYnkgRW1zY3JpcHRlbi5cbiAgICpcbiAgICogQ29tbW9uIG1ldGhvZHMgdG8gdXNlIGFyZTpcbiAgICogZmZtcGVnLkZTKCd3cml0ZUZpbGUnLCAndmlkZW8uYXZpJywgbmV3IFVpbnQ4QXJyYXkoLi4uKSk6IHdyaXRlRmlsZSB3cml0ZXNcbiAgICogZGF0YSB0byBNRU1GUy4gWW91IG5lZWQgdG8gdXNlIFVpbnQ4QXJyYXkgZm9yIGJpbmFyeSBkYXRhLlxuICAgKiBmZm1wZWcuRlMoJ3JlYWRGaWxlJywgJ3ZpZGVvLm1wNCcpOiByZWFkRmlsZSBmcm9tIE1FTUZTLlxuICAgKiBmZm1wZWcuRlMoJ3VubGluaycsICd2aWRlby5tYXAnKTogZGVsZXRlIGZpbGUgZnJvbSBNRU1GUy5cbiAgICpcbiAgICogRm9yIG1vcmUgaW5mbywgY2hlY2sgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2FwaV9yZWZlcmVuY2UvRmlsZXN5c3RlbS1BUEkuaHRtbFxuICAgKlxuICAgKi9cbiAgY29uc3QgRlMgPSAobWV0aG9kLCAuLi5hcmdzKSA9PiB7XG4gICAgbG9nKCdpbmZvJywgYHJ1biBGUy4ke21ldGhvZH0gJHthcmdzLm1hcCgoYXJnKSA9PiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBhcmcgOiBgPCR7YXJnLmxlbmd0aH0gYnl0ZXMgYmluYXJ5IGZpbGU+YCkpLmpvaW4oJyAnKX1gKTtcbiAgICBpZiAoQ29yZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgTk9fTE9BRDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJldCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBDb3JlLkZTW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdyZWFkZGlyJykge1xuICAgICAgICAgIHRocm93IEVycm9yKGBmZm1wZWcuRlMoJ3JlYWRkaXInLCAnJHthcmdzWzBdfScpIGVycm9yLiBDaGVjayBpZiB0aGUgcGF0aCBleGlzdHMsIGV4OiBmZm1wZWcuRlMoJ3JlYWRkaXInLCAnLycpYCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAncmVhZEZpbGUnKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGZmbXBlZy5GUygncmVhZEZpbGUnLCAnJHthcmdzWzBdfScpIGVycm9yLiBDaGVjayBpZiB0aGUgcGF0aCBleGlzdHNgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignT29wcywgc29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gRlMgb3BlcmF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRQcm9ncmVzcyA9IChfcHJvZ3Jlc3MpID0+IHtcbiAgICBwcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgfTtcblxuICBjb25zdCBzZXRMb2dnZXIgPSAoX2xvZ2dlcikgPT4ge1xuICAgIHNldEN1c3RvbUxvZ2dlcihfbG9nZ2VyKTtcbiAgfTtcblxuICBzZXRMb2dnaW5nKGxvZ2dpbmcpO1xuICBzZXRDdXN0b21Mb2dnZXIobG9nZ2VyKTtcblxuICBsb2coJ2luZm8nLCBgdXNlIGZmbXBlZy53YXNtIHYke3ZlcnNpb259YCk7XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9ncmVzcyxcbiAgICBzZXRMb2dnZXIsXG4gICAgc2V0TG9nZ2luZyxcbiAgICBsb2FkLFxuICAgIGlzTG9hZGVkLFxuICAgIHJ1bixcbiAgICBGUyxcbiAgfTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")},function(module,exports){eval("module.exports = {\n  defaultArgs: [\n    /* args[0] is always the binary path */\n    './ffmpeg',\n    /* Disable interaction mode */\n    '-nostdin',\n    /* Force to override output file */\n    '-y',\n  ],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: false,\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: () => {},\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: () => {},\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: '',\n  },\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL2NvbmZpZy5qcz9jNGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmF1bHRBcmdzOiBbXG4gICAgLyogYXJnc1swXSBpcyBhbHdheXMgdGhlIGJpbmFyeSBwYXRoICovXG4gICAgJy4vZmZtcGVnJyxcbiAgICAvKiBEaXNhYmxlIGludGVyYWN0aW9uIG1vZGUgKi9cbiAgICAnLW5vc3RkaW4nLFxuICAgIC8qIEZvcmNlIHRvIG92ZXJyaWRlIG91dHB1dCBmaWxlICovXG4gICAgJy15JyxcbiAgXSxcbiAgYmFzZU9wdGlvbnM6IHtcbiAgICAvKiBGbGFnIHRvIHR1cm4gb24vb2ZmIGxvZyBtZXNzYWdlcyBpbiBjb25zb2xlICovXG4gICAgbG9nOiBmYWxzZSxcbiAgICAvKlxuICAgICAqIEN1c3RvbSBsb2dnZXIgdG8gZ2V0IGZmbXBlZy53YXNtIG91dHB1dCBtZXNzYWdlcy5cbiAgICAgKiBhIHNhbXBsZSBsb2dnZXIgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogbG9nZ2VyID0gKHsgdHlwZSwgbWVzc2FnZSB9KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyh0eXBlLCBtZXNzYWdlKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB0eXBlIGNhbiBiZSBvbmUgb2YgZm9sbG93aW5nOlxuICAgICAqXG4gICAgICogaW5mbzogaW50ZXJuYWwgd29ya2Zsb3cgZGVidWcgbWVzc2FnZXNcbiAgICAgKiBmZmVycjogZmZtcGVnIG5hdGl2ZSBzdGRlcnIgb3V0cHV0XG4gICAgICogZmZvdXQ6IGZmbXBlZyBuYXRpdmUgc3Rkb3V0IG91dHB1dFxuICAgICAqL1xuICAgIGxvZ2dlcjogKCkgPT4ge30sXG4gICAgLypcbiAgICAgKiBQcm9ncmVzcyBoYW5kbGVyIHRvIGdldCBjdXJyZW50IHByb2dyZXNzIG9mIGZmbXBlZyBjb21tYW5kLlxuICAgICAqIGEgc2FtcGxlIHByb2dyZXNzIGhhbmRsZXIgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogcHJvZ3Jlc3MgPSAoeyByYXRpbyB9KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhyYXRpbyk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogcmF0aW8gaXMgYSBmbG9hdCBudW1iZXIgYmV0d2VlbiAwIHRvIDEuXG4gICAgICovXG4gICAgcHJvZ3Jlc3M6ICgpID0+IHt9LFxuICAgIC8qXG4gICAgICogUGF0aCB0byBmaW5kL2Rvd25sb2FkIGZmbXBlZy53YXNtLWNvcmUsXG4gICAgICogdGhpcyB2YWx1ZSBzaG91bGQgYmUgb3ZlcndyaXRlbiBieSBgZGVmYXVsdE9wdGlvbnNgIGluXG4gICAgICogZWFjaCBlbnZpcm9ubWVudC5cbiAgICAgKi9cbiAgICBjb3JlUGF0aDogJycsXG4gIH0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n")},function(module,exports){eval("let duration = 0;\n\nconst ts2sec = (ts) => {\n  const [h, m, s] = ts.split(':');\n  return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);\n};\n\nmodule.exports = (message, progress) => {\n  if (typeof message === 'string') {\n    if (message.startsWith('  Duration')) {\n      const ts = message.split(', ')[0].split(': ')[1];\n      const d = ts2sec(ts);\n      if (duration === 0 || duration > d) {\n        duration = d;\n      }\n    } else if (message.startsWith('frame') || message.startsWith('size')) {\n      const ts = message.split('time=')[1].split(' ')[0];\n      const t = ts2sec(ts);\n      progress({ ratio: t / duration });\n    } else if (message.startsWith('video:')) {\n      progress({ ratio: 1 });\n      duration = 0;\n    }\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL3V0aWxzL3BhcnNlUHJvZ3Jlc3MuanM/ZjFjMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDLEtBQUs7QUFDTCxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBkdXJhdGlvbiA9IDA7XG5cbmNvbnN0IHRzMnNlYyA9ICh0cykgPT4ge1xuICBjb25zdCBbaCwgbSwgc10gPSB0cy5zcGxpdCgnOicpO1xuICByZXR1cm4gKHBhcnNlRmxvYXQoaCkgKiA2MCAqIDYwKSArIChwYXJzZUZsb2F0KG0pICogNjApICsgcGFyc2VGbG9hdChzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKG1lc3NhZ2UsIHByb2dyZXNzKSA9PiB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAobWVzc2FnZS5zdGFydHNXaXRoKCcgIER1cmF0aW9uJykpIHtcbiAgICAgIGNvbnN0IHRzID0gbWVzc2FnZS5zcGxpdCgnLCAnKVswXS5zcGxpdCgnOiAnKVsxXTtcbiAgICAgIGNvbnN0IGQgPSB0czJzZWModHMpO1xuICAgICAgaWYgKGR1cmF0aW9uID09PSAwIHx8IGR1cmF0aW9uID4gZCkge1xuICAgICAgICBkdXJhdGlvbiA9IGQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ2ZyYW1lJykgfHwgbWVzc2FnZS5zdGFydHNXaXRoKCdzaXplJykpIHtcbiAgICAgIGNvbnN0IHRzID0gbWVzc2FnZS5zcGxpdCgndGltZT0nKVsxXS5zcGxpdCgnICcpWzBdO1xuICAgICAgY29uc3QgdCA9IHRzMnNlYyh0cyk7XG4gICAgICBwcm9ncmVzcyh7IHJhdGlvOiB0IC8gZHVyYXRpb24gfSk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3ZpZGVvOicpKSB7XG4gICAgICBwcm9ncmVzcyh7IHJhdGlvOiAxIH0pO1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n")},function(module,exports){eval("module.exports = (Core, args) => {\n  const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n  args.forEach((s, idx) => {\n    const buf = Core._malloc(s.length + 1);\n    Core.writeAsciiToMemory(s, buf);\n    Core.setValue(argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');\n  });\n  return [args.length, argsPtr];\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL3V0aWxzL3BhcnNlQXJncy5qcz8xYmQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoQ29yZSwgYXJncykgPT4ge1xuICBjb25zdCBhcmdzUHRyID0gQ29yZS5fbWFsbG9jKGFyZ3MubGVuZ3RoICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICBhcmdzLmZvckVhY2goKHMsIGlkeCkgPT4ge1xuICAgIGNvbnN0IGJ1ZiA9IENvcmUuX21hbGxvYyhzLmxlbmd0aCArIDEpO1xuICAgIENvcmUud3JpdGVBc2NpaVRvTWVtb3J5KHMsIGJ1Zik7XG4gICAgQ29yZS5zZXRWYWx1ZShhcmdzUHRyICsgKFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogaWR4KSwgYnVmLCAnaTMyJyk7XG4gIH0pO1xuICByZXR1cm4gW2FyZ3MubGVuZ3RoLCBhcmdzUHRyXTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {const resolveURL = __webpack_require__(4);\nconst { devDependencies } = __webpack_require__(7);\n\n/*\n * Default options for browser environment\n */\nmodule.exports = {\n  corePath: (typeof process !== 'undefined' && process.env.FFMPEG_ENV === 'development')\n    ? resolveURL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js')\n    : `https://unpkg.com/@ffmpeg/core@${devDependencies['@ffmpeg/core'].substring(1)}/dist/ffmpeg-core.js`,\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL2Jyb3dzZXIvZGVmYXVsdE9wdGlvbnMuanM/NmNmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrRUFBbUIsbUJBQU8sQ0FBQyxDQUFhO0FBQ3hDLE9BQU8sa0JBQWtCLEdBQUcsbUJBQU8sQ0FBQyxDQUFvQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZDQUE2QztBQUNyRiIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlc29sdmVVUkwgPSByZXF1aXJlKCdyZXNvbHZlLXVybCcpO1xuY29uc3QgeyBkZXZEZXBlbmRlbmNpZXMgfSA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpO1xuXG4vKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBicm93c2VyIGVudmlyb25tZW50XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3JlUGF0aDogKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5GRk1QRUdfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgID8gcmVzb2x2ZVVSTCgnL25vZGVfbW9kdWxlcy9AZmZtcGVnL2NvcmUvZGlzdC9mZm1wZWctY29yZS5qcycpXG4gICAgOiBgaHR0cHM6Ly91bnBrZy5jb20vQGZmbXBlZy9jb3JlQCR7ZGV2RGVwZW5kZW5jaWVzWydAZmZtcGVnL2NvcmUnXS5zdWJzdHJpbmcoMSl9L2Rpc3QvZmZtcGVnLWNvcmUuanNgLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n")},function(module,exports,__webpack_require__){eval("/* eslint-disable no-undef */\nconst resolveURL = __webpack_require__(4);\nconst { log } = __webpack_require__(5);\n\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */\nconst toBlobURL = async (url, mimeType) => {\n  log('info', `fetch ${url}`);\n  const buf = await (await fetch(url)).arrayBuffer();\n  log('info', `${url} file size = ${buf.byteLength} bytes`);\n  const blob = new Blob([buf], { type: mimeType });\n  const blobURL = URL.createObjectURL(blob);\n  log('info', `${url} blob URL = ${blobURL}`);\n  return blobURL;\n};\n\nmodule.exports = async ({ corePath: _corePath }) => {\n  if (typeof _corePath !== 'string') {\n    throw Error('corePath should be a string!');\n  }\n  const coreRemotePath = resolveURL(_corePath);\n  const corePath = await toBlobURL(\n    coreRemotePath,\n    'application/javascript',\n  );\n  const wasmPath = await toBlobURL(\n    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n    'application/wasm',\n  );\n  const workerPath = await toBlobURL(\n    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n    'application/javascript',\n  );\n  if (typeof createFFmpegCore === 'undefined') {\n    return new Promise((resolve) => {\n      const script = document.createElement('script');\n      const eventHandler = () => {\n        script.removeEventListener('load', eventHandler);\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      };\n      script.src = corePath;\n      script.type = 'text/javascript';\n      script.addEventListener('load', eventHandler);\n      document.getElementsByTagName('head')[0].appendChild(script);\n    });\n  }\n  log('info', 'ffmpeg-core.js script is loaded already');\n  return Promise.resolve({\n    createFFmpegCore,\n    corePath,\n    wasmPath,\n    workerPath,\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL2Jyb3dzZXIvZ2V0Q3JlYXRlRkZtcGVnQ29yZS5qcz8yNjJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsQ0FBYTtBQUN4QyxPQUFPLE1BQU0sR0FBRyxtQkFBTyxDQUFDLENBQWM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBLGlCQUFpQixJQUFJLGVBQWUsZUFBZTtBQUNuRCxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0EsaUJBQWlCLElBQUksY0FBYyxRQUFRO0FBQzNDO0FBQ0E7O0FBRUEseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5jb25zdCByZXNvbHZlVVJMID0gcmVxdWlyZSgncmVzb2x2ZS11cmwnKTtcbmNvbnN0IHsgbG9nIH0gPSByZXF1aXJlKCcuLi91dGlscy9sb2cnKTtcblxuLypcbiAqIEZldGNoIGRhdGEgZnJvbSByZW1vdGUgVVJMIGFuZCBjb252ZXJ0IHRvIGJsb2IgVVJMXG4gKiB0byBhdm9pZCBDT1JTIGlzc3VlXG4gKi9cbmNvbnN0IHRvQmxvYlVSTCA9IGFzeW5jICh1cmwsIG1pbWVUeXBlKSA9PiB7XG4gIGxvZygnaW5mbycsIGBmZXRjaCAke3VybH1gKTtcbiAgY29uc3QgYnVmID0gYXdhaXQgKGF3YWl0IGZldGNoKHVybCkpLmFycmF5QnVmZmVyKCk7XG4gIGxvZygnaW5mbycsIGAke3VybH0gZmlsZSBzaXplID0gJHtidWYuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZdLCB7IHR5cGU6IG1pbWVUeXBlIH0pO1xuICBjb25zdCBibG9iVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgbG9nKCdpbmZvJywgYCR7dXJsfSBibG9iIFVSTCA9ICR7YmxvYlVSTH1gKTtcbiAgcmV0dXJuIGJsb2JVUkw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jICh7IGNvcmVQYXRoOiBfY29yZVBhdGggfSkgPT4ge1xuICBpZiAodHlwZW9mIF9jb3JlUGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBFcnJvcignY29yZVBhdGggc2hvdWxkIGJlIGEgc3RyaW5nIScpO1xuICB9XG4gIGNvbnN0IGNvcmVSZW1vdGVQYXRoID0gcmVzb2x2ZVVSTChfY29yZVBhdGgpO1xuICBjb25zdCBjb3JlUGF0aCA9IGF3YWl0IHRvQmxvYlVSTChcbiAgICBjb3JlUmVtb3RlUGF0aCxcbiAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICk7XG4gIGNvbnN0IHdhc21QYXRoID0gYXdhaXQgdG9CbG9iVVJMKFxuICAgIGNvcmVSZW1vdGVQYXRoLnJlcGxhY2UoJ2ZmbXBlZy1jb3JlLmpzJywgJ2ZmbXBlZy1jb3JlLndhc20nKSxcbiAgICAnYXBwbGljYXRpb24vd2FzbScsXG4gICk7XG4gIGNvbnN0IHdvcmtlclBhdGggPSBhd2FpdCB0b0Jsb2JVUkwoXG4gICAgY29yZVJlbW90ZVBhdGgucmVwbGFjZSgnZmZtcGVnLWNvcmUuanMnLCAnZmZtcGVnLWNvcmUud29ya2VyLmpzJyksXG4gICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICApO1xuICBpZiAodHlwZW9mIGNyZWF0ZUZGbXBlZ0NvcmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2NyaXB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICBsb2coJ2luZm8nLCAnZmZtcGVnLWNvcmUuanMgc2NyaXB0IGxvYWRlZCcpO1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgICAgICAgIGNvcmVQYXRoLFxuICAgICAgICAgIHdhc21QYXRoLFxuICAgICAgICAgIHdvcmtlclBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNjcmlwdC5zcmMgPSBjb3JlUGF0aDtcbiAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGV2ZW50SGFuZGxlcik7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG4gIH1cbiAgbG9nKCdpbmZvJywgJ2ZmbXBlZy1jb3JlLmpzIHNjcmlwdCBpcyBsb2FkZWQgYWxyZWFkeScpO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgIGNvcmVQYXRoLFxuICAgIHdhc21QYXRoLFxuICAgIHdvcmtlclBhdGgsXG4gIH0pO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports,__webpack_require__){eval("const resolveURL = __webpack_require__(4);\n\nconst readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\nmodule.exports = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    /* From remote server/URL */\n    } else {\n      const res = await fetch(resolveURL(_data));\n      data = await res.arrayBuffer();\n    }\n  /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZmbXBlZy9mZm1wZWcvc3JjL2Jyb3dzZXIvZmV0Y2hGaWxlLmpzPzVhYjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQW1CLG1CQUFPLENBQUMsQ0FBYTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsU0FBUyxPQUFPLEVBQUUsRUFBRTtBQUN6RCxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZXNvbHZlVVJMID0gcmVxdWlyZSgncmVzb2x2ZS11cmwnKTtcblxuY29uc3QgcmVhZEZyb21CbG9iT3JGaWxlID0gKGJsb2IpID0+IChcbiAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZShmaWxlUmVhZGVyLnJlc3VsdCk7XG4gICAgfTtcbiAgICBmaWxlUmVhZGVyLm9uZXJyb3IgPSAoeyB0YXJnZXQ6IHsgZXJyb3I6IHsgY29kZSB9IH0gfSkgPT4ge1xuICAgICAgcmVqZWN0KEVycm9yKGBGaWxlIGNvdWxkIG5vdCBiZSByZWFkISBDb2RlPSR7Y29kZX1gKSk7XG4gICAgfTtcbiAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICB9KVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAoX2RhdGEpID0+IHtcbiAgbGV0IGRhdGEgPSBfZGF0YTtcbiAgaWYgKHR5cGVvZiBfZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgX2RhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLyogRnJvbSBiYXNlNjQgZm9ybWF0ICovXG4gICAgaWYgKC9kYXRhOl9kYXRhXFwvKFthLXpBLVpdKik7YmFzZTY0LChbXlwiXSopLy50ZXN0KF9kYXRhKSkge1xuICAgICAgZGF0YSA9IGF0b2IoX2RhdGEuc3BsaXQoJywnKVsxXSlcbiAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuICAgIC8qIEZyb20gcmVtb3RlIHNlcnZlci9VUkwgKi9cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gocmVzb2x2ZVVSTChfZGF0YSkpO1xuICAgICAgZGF0YSA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgIH1cbiAgLyogRnJvbSBCbG9iIG9yIEZpbGUgKi9cbiAgfSBlbHNlIGlmIChfZGF0YSBpbnN0YW5jZW9mIEZpbGUgfHwgX2RhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgZGF0YSA9IGF3YWl0IHJlYWRGcm9tQmxvYk9yRmlsZShfZGF0YSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n")},function(module,exports,__webpack_require__){eval('var map = {\n\t"./404.vue": 22,\n\t"./About.vue": 23,\n\t"./Home.vue": 21\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module \'" + req + "\'");\n\t\te.code = \'MODULE_NOT_FOUND\';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 20;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMgc3luYyBeXFwuXFwvLipcXC52dWUkP2MxN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuLzQwNC52dWVcIjogMjIsXG5cdFwiLi9BYm91dC52dWVcIjogMjMsXG5cdFwiLi9Ib21lLnZ1ZVwiOiAyMVxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDIwOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--8-0!./src/pages/Home.vue?vue&type=template&id=07b536f8\n\n\nvar _hoisted_1 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("h1", null, "HOME", -1\n/* HOISTED */\n);\n\nvar _hoisted_2 = {\n  "class": "startButtonDiv"\n};\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_Upload = Object(vue_esm_bundler["j" /* resolveComponent */])("Upload");\n\n  var _component_main_layout = Object(vue_esm_bundler["j" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["g" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["l" /* withCtx */])(function () {\n      return [_hoisted_1, Object(vue_esm_bundler["e" /* createVNode */])(_component_Upload, {\n        ref: "uploadBox"\n      }, null, 512\n      /* NEED_PATCH */\n      ), Object(vue_esm_bundler["e" /* createVNode */])("div", _hoisted_2, [Object(vue_esm_bundler["e" /* createVNode */])("button", {\n        "class": "startButton",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.startButtonPressed && $options.startButtonPressed.apply($options, arguments);\n        })\n      }, "Start Encoding")])];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/Home.vue?vue&type=template&id=07b536f8\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 9 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--8-0!./src/components/Upload.vue?vue&type=template&id=72634781\n\nvar Uploadvue_type_template_id_72634781_hoisted_1 = {\n  style: {\n    "font-size": "20px",\n    "text-align": "center",\n    "padding-top": "200px"\n  }\n};\n\nvar Uploadvue_type_template_id_72634781_hoisted_2 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("label", {\n  "for": "fileUpload",\n  style: {\n    "cursor": "pointer"\n  }\n}, [/*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("strong", null, "Choose a file"), /*#__PURE__*/Object(vue_esm_bundler["d" /* createTextVNode */])(" or drag it here")], -1\n/* HOISTED */\n);\n\nvar _hoisted_3 = {\n  "class": "styled-table"\n};\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("thead", null, [/*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("tr", null, [/*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("th", null, "Name"), /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("th", {\n  style: {\n    "width": "100px"\n  }\n}, "Processed"), /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("th", {\n  style: {\n    "width": "100px"\n  }\n}, "Size"), /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("th", {\n  style: {\n    "width": "100px"\n  }\n}, "Controls")])], -1\n/* HOISTED */\n);\n\nfunction Uploadvue_type_template_id_72634781_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(vue_esm_bundler["g" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(vue_esm_bundler["a" /* Fragment */], null, [Object(vue_esm_bundler["e" /* createVNode */])("div", {\n    "class": "dropbox",\n    style: {\n      "width": "100%",\n      "height": "300px",\n      "background-color": "rgb(225 250 255)",\n      "border": "4px dashed"\n    },\n    onDrop: _cache[2] || (_cache[2] = Object(vue_esm_bundler["m" /* withModifiers */])(function () {\n      return $options.addFile && $options.addFile.apply($options, arguments);\n    }, ["prevent"])),\n    onDragover: _cache[3] || (_cache[3] = Object(vue_esm_bundler["m" /* withModifiers */])(function () {}, ["prevent"]))\n  }, [Object(vue_esm_bundler["e" /* createVNode */])("div", Uploadvue_type_template_id_72634781_hoisted_1, [Object(vue_esm_bundler["e" /* createVNode */])("input", {\n    type: "file",\n    style: {\n      "height": "0.1px",\n      "opacity": "0",\n      "overflow": "hidden",\n      "position": "absolute",\n      "z-index": "-1"\n    },\n    multiple: "",\n    onChange: _cache[1] || (_cache[1] = function ($event) {\n      $options.filesChange($event.target.name, $event.target.files);\n      _ctx.fileCount = $event.target.files.length;\n    }),\n    accept: "image/*",\n    id: "fileUpload",\n    "class": "input-file"\n  }, null, 32\n  /* HYDRATE_EVENTS */\n  ), Uploadvue_type_template_id_72634781_hoisted_2])], 32\n  /* HYDRATE_EVENTS */\n  ), Object(vue_esm_bundler["e" /* createVNode */])("table", _hoisted_3, [_hoisted_4, Object(vue_esm_bundler["e" /* createVNode */])("tbody", null, [(Object(vue_esm_bundler["g" /* openBlock */])(true), Object(vue_esm_bundler["c" /* createBlock */])(vue_esm_bundler["a" /* Fragment */], null, Object(vue_esm_bundler["h" /* renderList */])($data.uploadedFiles, function (upload) {\n    return Object(vue_esm_bundler["g" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("tr", {\n      key: upload.id\n    }, [Object(vue_esm_bundler["e" /* createVNode */])("td", null, Object(vue_esm_bundler["k" /* toDisplayString */])(upload.name), 1\n    /* TEXT */\n    ), Object(vue_esm_bundler["e" /* createVNode */])("td", null, Object(vue_esm_bundler["k" /* toDisplayString */])(upload.processedPercent), 1\n    /* TEXT */\n    ), Object(vue_esm_bundler["e" /* createVNode */])("td", null, Object(vue_esm_bundler["k" /* toDisplayString */])($options.bytesToSize(upload.fileRef.size)), 1\n    /* TEXT */\n    ), Object(vue_esm_bundler["e" /* createVNode */])("td", null, [Object(vue_esm_bundler["e" /* createVNode */])("img", {\n      onClick: function onClick($event) {\n        return $options.deleteUpload(upload);\n      },\n      src: "/assets/icons/x.svg"\n    }, null, 8\n    /* PROPS */\n    , ["onClick"]), Object(vue_esm_bundler["e" /* createVNode */])("img", {\n      onClick: function onClick($event) {\n        return $options.moveUpUpload(upload);\n      },\n      src: "/assets/icons/arrow-up.svg"\n    }, null, 8\n    /* PROPS */\n    , ["onClick"]), Object(vue_esm_bundler["e" /* createVNode */])("img", {\n      onClick: function onClick($event) {\n        return $options.moveDownUpload(upload);\n      },\n      src: "/assets/icons/arrow-down.svg"\n    }, null, 8\n    /* PROPS */\n    , ["onClick"])])]);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])])], 64\n  /* STABLE_FRAGMENT */\n  );\n}\n// CONCATENATED MODULE: ./src/components/Upload.vue?vue&type=template&id=72634781\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--8-0!./src/components/Upload.vue?vue&type=script&lang=js\n/* harmony default export */ var Uploadvue_type_script_lang_js = ({\n  components: {},\n  data: function data() {\n    return {\n      uploadedFiles: []\n    };\n  },\n  computed: {},\n  methods: {\n    bytesToSize: function bytesToSize(bytes) {\n      var sizes = [\'Bytes\', \'KB\', \'MB\', \'GB\', \'TB\'];\n      if (bytes == 0) return \'0 Byte\';\n      var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));\n      return Math.round(bytes / Math.pow(1024, i), 2) + \' \' + sizes[i];\n    },\n    moveUpUpload: function moveUpUpload(upload) {\n      var index = this.uploadedFiles.indexOf(upload);\n\n      if (index > 0) {\n        var temp = this.uploadedFiles[index];\n        this.uploadedFiles[index] = this.uploadedFiles[index - 1];\n        this.uploadedFiles[index - 1] = temp;\n      }\n    },\n    moveDownUpload: function moveDownUpload(upload) {\n      var index = this.uploadedFiles.indexOf(upload);\n\n      if (index < this.uploadedFiles.length - 1) {\n        var temp = this.uploadedFiles[index];\n        this.uploadedFiles[index] = this.uploadedFiles[index + 1];\n        this.uploadedFiles[index + 1] = temp;\n      }\n    },\n    deleteUpload: function deleteUpload(upload) {\n      var index = this.uploadedFiles.indexOf(upload);\n\n      if (index >= 0) {\n        this.uploadedFiles.splice(index, 1);\n      }\n    },\n    addFile: function addFile(e) {\n      var _this = this;\n\n      var newFiles = Array.from(Array(e.dataTransfer.files.length).keys()).map(function (x) {\n        var fileObj = {\n          "fileRef": e.dataTransfer.files[x],\n          "name": e.dataTransfer.files[x].name,\n          "fileData": null,\n          "uploadPercent": 0,\n          "processedPercent": 0,\n          "id": Math.floor(Math.random() * 10000000)\n        };\n        var fileReader = new FileReader();\n\n        fileReader.onprogress = function (event) {\n          fileObj.uploadPercent = event.total / event.loaded * 100;\n        };\n\n        fileReader.onload = function (event) {\n          fileObj.uploadPercent = 100;\n          fileObj.fileData = new Uint8Array(event.target.result);\n        };\n\n        fileReader.readAsArrayBuffer(fileObj.fileRef);\n        return fileObj;\n      });\n      newFiles.forEach(function (e) {\n        _this.uploadedFiles.push(e);\n      });\n      console.log(this.uploadedFiles);\n    },\n    filesChange: function filesChange(eventName, fileList) {\n      var _this2 = this;\n\n      var newFiles = Array.from(Array(fileList.length).keys()).map(function (x) {\n        var fileObj = {\n          "fileRef": fileList[x],\n          "name": fileList[x].name,\n          "fileData": null,\n          "uploadPercent": 0,\n          "processedPercent": 0,\n          "id": Math.floor(Math.random() * 10000000)\n        };\n        var fileReader = new FileReader();\n\n        fileReader.onprogress = function (event) {\n          fileObj.uploadPercent = event.total / event.loaded * 100;\n        };\n\n        fileReader.onload = function (event) {\n          fileObj.uploadPercent = 100;\n          fileObj.fileData = new Uint8Array(event.target.result);\n        };\n\n        fileReader.readAsArrayBuffer(fileObj.fileRef);\n        return fileObj;\n      });\n      newFiles.forEach(function (e) {\n        _this2.uploadedFiles.push(e);\n      });\n      console.log(this.uploadedFiles);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/Upload.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/components/Upload.vue\n\n\n\nUploadvue_type_script_lang_js.render = Uploadvue_type_template_id_72634781_render\n\n/* harmony default export */ var Upload = (Uploadvue_type_script_lang_js);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--8-0!./src/pages/Home.vue?vue&type=script&lang=js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n/* harmony default export */ var Homevue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */],\n    Upload: Upload\n  },\n  data: function data() {\n    return {};\n  },\n  computed: {},\n  methods: {\n    startButtonPressed: function startButtonPressed() {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var filesToEncode, nextToBeProcessed, data;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                filesToEncode = _this.$refs.uploadBox.uploadedFiles;\n\n                if (_this.ffmpeg.isLoaded()) {\n                  _context.next = 4;\n                  break;\n                }\n\n                _context.next = 4;\n                return _this.ffmpeg.load();\n\n              case 4:\n                if (!filesToEncode.some(function (a) {\n                  return a.processedPercent < 1;\n                })) {\n                  _context.next = 15;\n                  break;\n                }\n\n                nextToBeProcessed = filesToEncode.find(function (a) {\n                  return a.processedPercent < 100;\n                });\n\n                _this.onprogress.register(function (ratio) {\n                  nextToBeProcessed.processedPercent = ratio;\n                });\n\n                _this.ffmpeg.FS(\'writeFile\', \'test.mp4\', nextToBeProcessed.fileData);\n\n                _context.next = 10;\n                return _this.ffmpeg.run(\'-i\', \'test.mp4\', \'test.avi\');\n\n              case 10:\n                nextToBeProcessed.processedPercent = 1;\n                data = _this.ffmpeg.FS(\'readFile\', \'test.mp4\');\n                console.log("WE HAVE DONE IT");\n                _context.next = 4;\n                break;\n\n              case 15:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/Home.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/Home.vue\n\n\n\nHomevue_type_script_lang_js.render = render\n\n/* harmony default export */ var Home = __webpack_exports__["default"] = (Homevue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS52dWU/YmMxMyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9VcGxvYWQudnVlP2Q0NDMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvVXBsb2FkLnZ1ZT9lYTA4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1VwbG9hZC52dWU/MTE1NSIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS52dWU/N2E2NyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS52dWU/NzUzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OEJBRUksK0NBQWEsSUFBYixFQUFhLElBQWIsRUFBSSxNQUFKLEVBQVE7QUFBQTtBQUFSLEM7OztBQUVLLFdBQU07Ozs7Ozs7eURBSGIsK0NBTWMsc0JBTmQsRUFNYyxJQU5kLEVBTWM7MERBTFo7QUFBQSxhQUFhLENBQWIsVUFBYSxFQUNiLCtDQUFpQyxpQkFBakMsRUFBaUM7QUFBekIsV0FBRyxFQUFDO0FBQXFCLE9BQWpDLEVBQXVCLElBQXZCLEVBQXVCO0FBQUE7QUFBdkIsT0FEYSxFQUViLCtDQUVNLEtBRk4sY0FFTSxDQUROLCtDQUFtRixRQUFuRixFQUFtRjtBQUEzRSxpQkFBTSxhQUFxRTtBQUFsRCxlQUFLO0FBQUEsaUJBQUUscUZBQUY7QUFBQTtBQUE2QyxPQUFuRixFQUE0RCxnQkFBNUQsQ0FDTSxDQUZOLENBRmEsQ0FBYjtBQUFBLEssQ0FLWTs7OztBQUFBLEdBTmQsQzs7Ozs7Ozs7OztBQ0VXLE9BQThELEVBQTlEO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztpRUFHRCwrQ0FBcUcsT0FBckcsRUFBcUc7QUFBOUYsU0FBSSxZQUEwRjtBQUE3RSxPQUFzQixFQUF0QjtBQUFBO0FBQUE7QUFBNkUsQ0FBckcsRSxjQUErQywrQ0FBOEIsUUFBOUIsRUFBOEIsSUFBOUIsRUFBUSxlQUFSLEMsa0VBQThCLGtCLEVBQTdFLEU7O0FBQUEsQzs7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QUFBQTtBQUFBO0FBQUE7QUFrQjFCO0FBbkJNO0FBWkssQ0FBZixFOztBSWRrSyxDOztBQ0FqRztBQUNWO0FBQ0w7QUFDbEQsMkJBQU0sVUFBVSxNQUFNOztBQUVQLHFHIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8bWFpbi1sYXlvdXQ+XG4gICAgPGgxPkhPTUU8L2gxPlxuICAgIDxVcGxvYWQgcmVmPVwidXBsb2FkQm94XCI+PC9VcGxvYWQ+XG4gICAgPGRpdiBjbGFzcz1cInN0YXJ0QnV0dG9uRGl2XCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cInN0YXJ0QnV0dG9uXCIgdi1vbjpjbGljaz1cInN0YXJ0QnV0dG9uUHJlc3NlZFwiPlN0YXJ0IEVuY29kaW5nPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvbWFpbi1sYXlvdXQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1haW5MYXlvdXQgZnJvbSAnLi4vbGF5b3V0cy9NYWluLnZ1ZSdcbmltcG9ydCBVcGxvYWQgZnJvbSAnLi4vY29tcG9uZW50cy9VcGxvYWQudnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBNYWluTGF5b3V0LFxuICAgIFVwbG9hZFxuICB9LFxuICBkYXRhKCl7XG4gICAgcmV0dXJuIHtcblxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgfSwgIFxuICBtZXRob2RzOntcbiAgICBhc3luYyBzdGFydEJ1dHRvblByZXNzZWQoKXtcbiAgICAgIHZhciBmaWxlc1RvRW5jb2RlID0gdGhpcy4kcmVmcy51cGxvYWRCb3gudXBsb2FkZWRGaWxlcztcbiAgICAgIFxuICAgICAgaWYoIXRoaXMuZmZtcGVnLmlzTG9hZGVkKCkpe1xuICAgICAgICBhd2FpdCB0aGlzLmZmbXBlZy5sb2FkKClcbiAgICAgIH1cblxuICAgICAgd2hpbGUoZmlsZXNUb0VuY29kZS5zb21lKGE9PmEucHJvY2Vzc2VkUGVyY2VudCA8IDEpKXtcbiAgICAgICAgdmFyIG5leHRUb0JlUHJvY2Vzc2VkID0gZmlsZXNUb0VuY29kZS5maW5kKGE9PmEucHJvY2Vzc2VkUGVyY2VudCA8IDEwMClcbiAgICAgICAgdGhpcy5vbnByb2dyZXNzLnJlZ2lzdGVyKGZ1bmN0aW9uKHJhdGlvKXtcbiAgICAgICAgICBuZXh0VG9CZVByb2Nlc3NlZC5wcm9jZXNzZWRQZXJjZW50ID0gcmF0aW87XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZmbXBlZy5GUygnd3JpdGVGaWxlJywgJ3Rlc3QubXA0JywgbmV4dFRvQmVQcm9jZXNzZWQuZmlsZURhdGEpO1xuICAgICAgICBhd2FpdCB0aGlzLmZmbXBlZy5ydW4oJy1pJywgJ3Rlc3QubXA0JywgJ3Rlc3QuYXZpJyk7XG4gICAgICAgIG5leHRUb0JlUHJvY2Vzc2VkLnByb2Nlc3NlZFBlcmNlbnQgPSAxO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5mZm1wZWcuRlMoJ3JlYWRGaWxlJywgJ3Rlc3QubXA0Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiV0UgSEFWRSBET05FIElUXCIpXG4gICAgICB9XG4gICAgfVxuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiXHJcbjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJkcm9wYm94XCIgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDozMDBweDtiYWNrZ3JvdW5kLWNvbG9yOnJnYigyMjUgMjUwIDI1NSk7Ym9yZGVyOjRweCBkYXNoZWRcIiB2LWNsb2FrIEBkcm9wLnByZXZlbnQ9XCJhZGRGaWxlXCIgQGRyYWdvdmVyLnByZXZlbnQ+XHJcbiAgICAgICAgPGRpdiBzdHlsZT1cImZvbnQtc2l6ZTogMjBweDt0ZXh0LWFsaWduOiBjZW50ZXI7cGFkZGluZy10b3A6IDIwMHB4O1wiPlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBzdHlsZT1cIndpZHRoPTAuMXB4O2hlaWdodDowLjFweDtvcGFjaXR5OjA7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6LTFcIiBtdWx0aXBsZSBAY2hhbmdlPVwiZmlsZXNDaGFuZ2UoJGV2ZW50LnRhcmdldC5uYW1lLCAkZXZlbnQudGFyZ2V0LmZpbGVzKTsgZmlsZUNvdW50ID0gJGV2ZW50LnRhcmdldC5maWxlcy5sZW5ndGhcIlxyXG4gICAgICAgICAgICAgICAgYWNjZXB0PVwiaW1hZ2UvKlwiIGlkPVwiZmlsZVVwbG9hZFwiIGNsYXNzPVwiaW5wdXQtZmlsZVwiPlxyXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiZmlsZVVwbG9hZFwiIHN0eWxlPVwiY3Vyc29yOnBvaW50ZXJcIj48c3Ryb25nPkNob29zZSBhIGZpbGU8L3N0cm9uZz4gb3IgZHJhZyBpdCBoZXJlPC9sYWJlbD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPHRhYmxlIGNsYXNzPVwic3R5bGVkLXRhYmxlXCI+XHJcbiAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICA8dGg+TmFtZTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggc3R5bGU9XCJ3aWR0aDoxMDBweDtcIj5Qcm9jZXNzZWQ8L3RoPlxyXG4gICAgICAgICAgICAgICAgPHRoIHN0eWxlPVwid2lkdGg6MTAwcHg7XCI+U2l6ZTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggc3R5bGU9XCJ3aWR0aDoxMDBweDtcIj5Db250cm9sczwvdGg+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgPC90aGVhZD5cclxuICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgIDx0ciB2LWZvcj1cInVwbG9hZCBpbiB1cGxvYWRlZEZpbGVzXCIgOmtleT1cInVwbG9hZC5pZFwiPlxyXG4gICAgICAgICAgICAgICAgPHRkPnt7dXBsb2FkLm5hbWV9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8dGQ+e3t1cGxvYWQucHJvY2Vzc2VkUGVyY2VudH19PC90ZD5cclxuICAgICAgICAgICAgICAgIDx0ZD57e2J5dGVzVG9TaXplKHVwbG9hZC5maWxlUmVmLnNpemUpfX08L3RkPlxyXG4gICAgICAgICAgICAgICAgPHRkPjxpbWcgdi1vbjpjbGljaz1cImRlbGV0ZVVwbG9hZCh1cGxvYWQpXCIgc3JjPVwiL2Fzc2V0cy9pY29ucy94LnN2Z1wiIC8+PGltZyB2LW9uOmNsaWNrPVwibW92ZVVwVXBsb2FkKHVwbG9hZClcIiBzcmM9XCIvYXNzZXRzL2ljb25zL2Fycm93LXVwLnN2Z1wiIC8+PGltZyB2LW9uOmNsaWNrPVwibW92ZURvd25VcGxvYWQodXBsb2FkKVwiIHNyYz1cIi9hc3NldHMvaWNvbnMvYXJyb3ctZG93bi5zdmdcIiAvPjwvdGQ+XHJcbiAgICAgICAgICAgIDwvdHI+ICAgICAgICAgICAgXHJcbiAgICAgICAgPC90Ym9keT5cclxuICAgIDwvdGFibGU+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiBjb21wb25lbnRzOiB7XHJcblxyXG4gIH0sXHJcbiAgZGF0YSgpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1cGxvYWRlZEZpbGVzOltdXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gIH0sICBcclxuICBtZXRob2RzOntcclxuICAgIGJ5dGVzVG9TaXplKGJ5dGVzKSB7XHJcbiAgICAgICAgdmFyIHNpemVzID0gWydCeXRlcycsICdLQicsICdNQicsICdHQicsICdUQiddO1xyXG4gICAgICAgIGlmIChieXRlcyA9PSAwKSByZXR1cm4gJzAgQnl0ZSc7XHJcbiAgICAgICAgdmFyIGkgPSBwYXJzZUludChNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKDEwMjQpKSk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYnl0ZXMgLyBNYXRoLnBvdygxMDI0LCBpKSwgMikgKyAnICcgKyBzaXplc1tpXTtcclxuICAgIH0sXHJcbiAgICBtb3ZlVXBVcGxvYWQodXBsb2FkKXtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnVwbG9hZGVkRmlsZXMuaW5kZXhPZih1cGxvYWQpO1xyXG4gICAgICAgIGlmKGluZGV4ID4gMCl7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy51cGxvYWRlZEZpbGVzW2luZGV4XVxyXG4gICAgICAgICAgICB0aGlzLnVwbG9hZGVkRmlsZXNbaW5kZXhdID0gdGhpcy51cGxvYWRlZEZpbGVzW2luZGV4LTFdXHJcbiAgICAgICAgICAgIHRoaXMudXBsb2FkZWRGaWxlc1tpbmRleC0xXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmVEb3duVXBsb2FkKHVwbG9hZCl7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy51cGxvYWRlZEZpbGVzLmluZGV4T2YodXBsb2FkKTtcclxuICAgICAgICBpZihpbmRleCA8IHRoaXMudXBsb2FkZWRGaWxlcy5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy51cGxvYWRlZEZpbGVzW2luZGV4XVxyXG4gICAgICAgICAgICB0aGlzLnVwbG9hZGVkRmlsZXNbaW5kZXhdID0gdGhpcy51cGxvYWRlZEZpbGVzW2luZGV4KzFdXHJcbiAgICAgICAgICAgIHRoaXMudXBsb2FkZWRGaWxlc1tpbmRleCsxXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRlbGV0ZVVwbG9hZCh1cGxvYWQpe1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMudXBsb2FkZWRGaWxlcy5pbmRleE9mKHVwbG9hZCk7XHJcbiAgICAgICAgaWYoaW5kZXg+PTApe1xyXG4gICAgICAgICAgICB0aGlzLnVwbG9hZGVkRmlsZXMuc3BsaWNlKGluZGV4LDEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBhZGRGaWxlOmZ1bmN0aW9uKGUpe1xyXG4gICAgICB2YXIgbmV3RmlsZXMgPSBBcnJheVxyXG4gICAgICAgICAgLmZyb20oQXJyYXkoZS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKS5rZXlzKCkpXHJcbiAgICAgICAgICAubWFwKHggPT4ge1xyXG4gICAgICAgICAgICBsZXQgZmlsZU9iaiA9IHtcclxuICAgICAgICAgICAgICAgIFwiZmlsZVJlZlwiOmUuZGF0YVRyYW5zZmVyLmZpbGVzW3hdLCBcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOmUuZGF0YVRyYW5zZmVyLmZpbGVzW3hdLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBcImZpbGVEYXRhXCI6bnVsbCxcclxuICAgICAgICAgICAgICAgIFwidXBsb2FkUGVyY2VudFwiOjAsXHJcbiAgICAgICAgICAgICAgICBcInByb2Nlc3NlZFBlcmNlbnRcIjowLFxyXG4gICAgICAgICAgICAgICAgXCJpZFwiOk1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwMDAwMCl9O1xyXG5cclxuICAgICAgICAgICAgbGV0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ucHJvZ3Jlc3MgPSAoZXZlbnQpPT57IFxyXG4gICAgICAgICAgICAgICAgZmlsZU9iai51cGxvYWRQZXJjZW50ID0gKGV2ZW50LnRvdGFsL2V2ZW50LmxvYWRlZCkqMTAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IChldmVudCk9PntcclxuICAgICAgICAgICAgICAgIGZpbGVPYmoudXBsb2FkUGVyY2VudCA9IDEwMDtcclxuICAgICAgICAgICAgICAgIGZpbGVPYmouZmlsZURhdGEgPSBuZXcgVWludDhBcnJheShldmVudC50YXJnZXQucmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlT2JqLmZpbGVSZWYpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVPYmo7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgIG5ld0ZpbGVzLmZvckVhY2goKGUpPT57XHJcbiAgICAgICAgICB0aGlzLnVwbG9hZGVkRmlsZXMucHVzaChlKTtcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMudXBsb2FkZWRGaWxlcylcclxuICAgIH0sXHJcbiAgICBmaWxlc0NoYW5nZTpmdW5jdGlvbihldmVudE5hbWUsZmlsZUxpc3Qpe1xyXG4gICAgICB2YXIgbmV3RmlsZXMgPSBBcnJheVxyXG4gICAgICAgICAgLmZyb20oQXJyYXkoZmlsZUxpc3QubGVuZ3RoKS5rZXlzKCkpXHJcbiAgICAgICAgICAubWFwKHggPT4ge1xyXG4gICAgICAgICAgICBsZXQgZmlsZU9iaiA9IHtcclxuICAgICAgICAgICAgICAgIFwiZmlsZVJlZlwiOmZpbGVMaXN0W3hdLCBcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOmZpbGVMaXN0W3hdLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBcImZpbGVEYXRhXCI6bnVsbCxcclxuICAgICAgICAgICAgICAgIFwidXBsb2FkUGVyY2VudFwiOjAsXHJcbiAgICAgICAgICAgICAgICBcInByb2Nlc3NlZFBlcmNlbnRcIjowLFxyXG4gICAgICAgICAgICAgICAgXCJpZFwiOk1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwMDAwMCl9O1xyXG5cclxuICAgICAgICAgICAgbGV0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ucHJvZ3Jlc3MgPSAoZXZlbnQpPT57XHJcbiAgICAgICAgICAgICAgICBmaWxlT2JqLnVwbG9hZFBlcmNlbnQgPSAoZXZlbnQudG90YWwvZXZlbnQubG9hZGVkKSoxMDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKGV2ZW50KT0+e1xyXG4gICAgICAgICAgICAgICAgZmlsZU9iai51cGxvYWRQZXJjZW50ID0gMTAwO1xyXG4gICAgICAgICAgICAgICAgZmlsZU9iai5maWxlRGF0YSA9IG5ldyBVaW50OEFycmF5KGV2ZW50LnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGVPYmouZmlsZVJlZik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmlsZU9iajtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgbmV3RmlsZXMuZm9yRWFjaCgoZSk9PntcclxuICAgICAgICAgIHRoaXMudXBsb2FkZWRGaWxlcy5wdXNoKGUpO1xyXG4gICAgICB9KVxyXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLnVwbG9hZGVkRmlsZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn1cclxuPC9zY3JpcHQ+IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOC0wIS4vVXBsb2FkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTgtMCEuL1VwbG9hZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1VwbG9hZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NzI2MzQ3ODFcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9VcGxvYWQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1VwbG9hZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuXG5leHBvcnQgZGVmYXVsdCBzY3JpcHQiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS04LTAhLi9Ib21lLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTgtMCEuL0hvbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9Ib21lLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wN2I1MzZmOFwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0hvbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0hvbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbnNjcmlwdC5yZW5kZXIgPSByZW5kZXJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--8-0!./src/pages/404.vue?vue&type=template&id=3c782a54\n\n\nvar _hoisted_1 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("p", null, "Page not found.", -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["j" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["g" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["l" /* withCtx */])(function () {\n      return [_hoisted_1];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/404.vue?vue&type=template&id=3c782a54\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 9 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--8-0!./src/pages/404.vue?vue&type=script&lang=js\n\n/* harmony default export */ var _404vue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  }\n});\n// CONCATENATED MODULE: ./src/pages/404.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/404.vue\n\n\n\n_404vue_type_script_lang_js.render = render\n\n/* harmony default export */ var _404 = __webpack_exports__["default"] = (_404vue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvNDA0LnZ1ZT9lZTVkIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy80MDQudnVlPzUxZDMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzLzQwNC52dWU/OTc1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OEJBRUksK0NBQXNCLEdBQXRCLEVBQXNCLElBQXRCLEVBQUcsaUJBQUgsRUFBa0I7QUFBQTtBQUFsQixDOzs7Ozt5REFERiwrQ0FFYyxzQkFGZCxFQUVjLElBRmQsRUFFYzswREFEWjtBQUFBLGFBQXNCLENBQXRCLFVBQXNCLENBQXRCO0FBQUEsSyxDQUNZOzs7O0FBQUEsR0FGZCxDOzs7Ozs7OztBQU1GO0FBRWU7QUFDYixZQUFVLEVBQUU7QUFDVixjQUFTLEVBQVQsdUJBQVU7QUFEQTtBQURDLENBQWYsRTs7QUNUaUssQzs7QUNBakc7QUFDVjtBQUNMO0FBQ2pELDJCQUFNLFVBQVUsTUFBTTs7QUFFUCxxRyIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPG1haW4tbGF5b3V0PlxuICAgIDxwPlBhZ2Ugbm90IGZvdW5kLjwvcD5cbiAgPC9tYWluLWxheW91dD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTWFpbkxheW91dCBmcm9tICcuLi9sYXlvdXRzL01haW4udnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBNYWluTGF5b3V0XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOC0wIS4vNDA0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTgtMCEuLzQwNC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuLzQwNC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9M2M3ODJhNTRcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi80MDQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuLzQwNC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuXG5leHBvcnQgZGVmYXVsdCBzY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--8-0!./src/pages/About.vue?vue&type=template&id=0733d9ab\n\n\nvar _hoisted_1 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createVNode */])("p", null, "About page.", -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["j" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["g" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["l" /* withCtx */])(function () {\n      return [_hoisted_1];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/About.vue?vue&type=template&id=0733d9ab\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 9 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--8-0!./src/pages/About.vue?vue&type=script&lang=js\n\n/* harmony default export */ var Aboutvue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  }\n});\n// CONCATENATED MODULE: ./src/pages/About.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/About.vue\n\n\n\nAboutvue_type_script_lang_js.render = render\n\n/* harmony default export */ var About = __webpack_exports__["default"] = (Aboutvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvQWJvdXQudnVlP2ExZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL0Fib3V0LnZ1ZT83OWE5Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9BYm91dC52dWU/ZDU2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OEJBRUksK0NBQWtCLEdBQWxCLEVBQWtCLElBQWxCLEVBQUcsYUFBSCxFQUFjO0FBQUE7QUFBZCxDOzs7Ozt5REFERiwrQ0FFYyxzQkFGZCxFQUVjLElBRmQsRUFFYzswREFEWjtBQUFBLGFBQWtCLENBQWxCLFVBQWtCLENBQWxCO0FBQUEsSyxDQUNZOzs7O0FBQUEsR0FGZCxDOzs7Ozs7OztBQU1GO0FBRWU7QUFDYixZQUFVLEVBQUU7QUFDVixjQUFTLEVBQVQsdUJBQVU7QUFEQTtBQURDLENBQWYsRTs7QUNUbUssQzs7QUNBakc7QUFDVjtBQUNMO0FBQ25ELDRCQUFNLFVBQVUsTUFBTTs7QUFFUCx1RyIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPG1haW4tbGF5b3V0PlxuICAgIDxwPkFib3V0IHBhZ2UuPC9wPlxuICA8L21haW4tbGF5b3V0PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNYWluTGF5b3V0IGZyb20gJy4uL2xheW91dHMvTWFpbi52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIE1haW5MYXlvdXRcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS04LTAhLi9BYm91dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS04LTAhLi9BYm91dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0Fib3V0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNzMzZDlhYlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0Fib3V0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9BYm91dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuXG5leHBvcnQgZGVmYXVsdCBzY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')}]);